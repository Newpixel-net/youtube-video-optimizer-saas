<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Ether Background</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<canvas id="fluid"></canvas>
<script>
(function() {
    'use strict';

    // Config - matches original Liquid Ether defaults
    const CONFIG = {
        colors: ['#5227FF', '#FF9FFC', '#B19EEF'],
        mouseForce: 20,
        cursorSize: 100,
        resolution: 0.5,
        dt: 0.014,
        iterationsPoisson: 32,
        BFECC: true,
        autoDemo: true,
        autoSpeed: 0.5,
        autoIntensity: 2.2,
        autoResumeDelay: 1000
    };

    const canvas = document.getElementById('fluid');
    const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false });

    if (!gl) {
        document.body.style.background = 'linear-gradient(135deg, rgba(82,39,255,0.6) 0%, rgba(255,159,252,0.4) 50%, rgba(177,158,239,0.5) 100%)';
        return;
    }

    // Extensions
    const ext = gl.getExtension('OES_texture_float') || gl.getExtension('OES_texture_half_float');
    const extLinear = gl.getExtension('OES_texture_float_linear') || gl.getExtension('OES_texture_half_float_linear');

    let texType = gl.UNSIGNED_BYTE;
    if (ext) {
        texType = ext.HALF_FLOAT_OES || gl.FLOAT;
    }

    // Create palette texture from colors
    function createPaletteTexture(colors) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);

        const data = new Uint8Array(colors.length * 4);
        colors.forEach((hex, i) => {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            data[i * 4] = r;
            data[i * 4 + 1] = g;
            data[i * 4 + 2] = b;
            data[i * 4 + 3] = 255;
        });

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, colors.length, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        return tex;
    }

    const paletteTex = createPaletteTexture(CONFIG.colors);

    // Shaders
    const baseVS = `
        attribute vec2 aPosition;
        varying vec2 vUv;
        varying vec2 vL, vR, vT, vB;
        uniform vec2 texelSize;
        void main() {
            vUv = aPosition * 0.5 + 0.5;
            vL = vUv - vec2(texelSize.x, 0.0);
            vR = vUv + vec2(texelSize.x, 0.0);
            vT = vUv + vec2(0.0, texelSize.y);
            vB = vUv - vec2(0.0, texelSize.y);
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    `;

    // Advection with BFECC (Back and Forth Error Correction)
    const advectionFS = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D velocity;
        uniform float dt;
        uniform bool isBFECC;
        uniform vec2 fboSize;
        uniform vec2 texelSize;
        void main() {
            vec2 ratio = max(fboSize.x, fboSize.y) / fboSize;
            if (!isBFECC) {
                vec2 vel = texture2D(velocity, vUv).xy;
                vec2 uv2 = vUv - vel * dt * ratio;
                vec2 newVel = texture2D(velocity, uv2).xy;
                gl_FragColor = vec4(newVel, 0.0, 0.0);
            } else {
                vec2 spot_new = vUv;
                vec2 vel_old = texture2D(velocity, vUv).xy;
                vec2 spot_old = spot_new - vel_old * dt * ratio;
                vec2 vel_new1 = texture2D(velocity, spot_old).xy;
                vec2 spot_new2 = spot_old + vel_new1 * dt * ratio;
                vec2 error = spot_new2 - spot_new;
                vec2 spot_new3 = spot_new - error / 2.0;
                vec2 vel_2 = texture2D(velocity, spot_new3).xy;
                vec2 spot_old2 = spot_new3 - vel_2 * dt * ratio;
                vec2 newVel2 = texture2D(velocity, spot_old2).xy;
                gl_FragColor = vec4(newVel2, 0.0, 0.0);
            }
        }
    `;

    // External force (mouse interaction)
    const forceVS = `
        attribute vec2 aPosition;
        attribute vec2 aUv;
        uniform vec2 center;
        uniform vec2 scale;
        uniform vec2 texelSize;
        varying vec2 vUv;
        void main() {
            vec2 pos = aPosition * scale * 2.0 * texelSize + center;
            vUv = aUv;
            gl_Position = vec4(pos, 0.0, 1.0);
        }
    `;

    const forceFS = `
        precision highp float;
        uniform vec2 force;
        varying vec2 vUv;
        void main() {
            vec2 circle = (vUv - 0.5) * 2.0;
            float d = 1.0 - min(length(circle), 1.0);
            d *= d;
            gl_FragColor = vec4(force * d, 0.0, 1.0);
        }
    `;

    const divergenceFS = `
        precision highp float;
        varying vec2 vUv, vL, vR, vT, vB;
        uniform sampler2D velocity;
        uniform float dt;
        uniform vec2 texelSize;
        void main() {
            float x0 = texture2D(velocity, vL).x;
            float x1 = texture2D(velocity, vR).x;
            float y0 = texture2D(velocity, vB).y;
            float y1 = texture2D(velocity, vT).y;
            float divergence = (x1 - x0 + y1 - y0) / 2.0;
            gl_FragColor = vec4(divergence / dt, 0.0, 0.0, 1.0);
        }
    `;

    const poissonFS = `
        precision highp float;
        varying vec2 vUv, vL, vR, vT, vB;
        uniform sampler2D pressure;
        uniform sampler2D divergence;
        void main() {
            float p0 = texture2D(pressure, vR).r;
            float p1 = texture2D(pressure, vL).r;
            float p2 = texture2D(pressure, vT).r;
            float p3 = texture2D(pressure, vB).r;
            float div = texture2D(divergence, vUv).r;
            float newP = (p0 + p1 + p2 + p3) / 4.0 - div;
            gl_FragColor = vec4(newP, 0.0, 0.0, 1.0);
        }
    `;

    const pressureFS = `
        precision highp float;
        varying vec2 vUv, vL, vR, vT, vB;
        uniform sampler2D pressure;
        uniform sampler2D velocity;
        uniform float dt;
        void main() {
            float p0 = texture2D(pressure, vR).r;
            float p1 = texture2D(pressure, vL).r;
            float p2 = texture2D(pressure, vT).r;
            float p3 = texture2D(pressure, vB).r;
            vec2 v = texture2D(velocity, vUv).xy;
            vec2 gradP = vec2(p0 - p1, p2 - p3) * 0.5;
            v = v - gradP * dt;
            gl_FragColor = vec4(v, 0.0, 1.0);
        }
    `;

    // Color output - maps velocity to palette colors
    const colorFS = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D velocity;
        uniform sampler2D palette;
        void main() {
            vec2 vel = texture2D(velocity, vUv).xy;
            float lenv = clamp(length(vel) * 1.5, 0.0, 1.0);
            vec3 c = texture2D(palette, vec2(lenv, 0.5)).rgb;
            float alpha = lenv;
            gl_FragColor = vec4(c * alpha, alpha);
        }
    `;

    function compileShader(type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
        }
        return shader;
    }

    function createProgram(vsSrc, fsSrc) {
        const prog = gl.createProgram();
        gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vsSrc));
        gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fsSrc));
        gl.linkProgram(prog);

        const uniforms = {};
        const count = gl.getProgramParameter(prog, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < count; i++) {
            const info = gl.getActiveUniform(prog, i);
            uniforms[info.name] = gl.getUniformLocation(prog, info.name);
        }

        return { program: prog, uniforms };
    }

    // Programs
    const advectionProg = createProgram(baseVS, advectionFS);
    const divergenceProg = createProgram(baseVS, divergenceFS);
    const poissonProg = createProgram(baseVS, poissonFS);
    const pressureProg = createProgram(baseVS, pressureFS);
    const colorProg = createProgram(baseVS, colorFS);
    const forceProg = createProgram(forceVS, forceFS);

    // Quad buffer
    const quadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    // Force mesh buffer (with UVs)
    const forceBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, forceBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1, 0,0,
         1,-1, 1,0,
        -1, 1, 0,1,
         1, 1, 1,1
    ]), gl.STATIC_DRAW);

    // FBO helpers
    function createFBO(w, h) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, texType, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return { texture: tex, fbo, width: w, height: h };
    }

    function createDoubleFBO(w, h) {
        let a = createFBO(w, h), b = createFBO(w, h);
        return {
            get read() { return a; },
            get write() { return b; },
            swap() { const t = a; a = b; b = t; }
        };
    }

    // State
    let velocity, pressure, divergence;
    let texelSize, fboSize, simW, simH;

    function resize() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        simW = Math.floor(canvas.width * CONFIG.resolution);
        simH = Math.floor(canvas.height * CONFIG.resolution);
        texelSize = [1/simW, 1/simH];
        fboSize = [simW, simH];
        velocity = createDoubleFBO(simW, simH);
        pressure = createDoubleFBO(simW, simH);
        divergence = createFBO(simW, simH);
    }

    resize();
    window.addEventListener('resize', resize);

    function bindQuad(prog) {
        const loc = gl.getAttribLocation(prog.program, 'aPosition');
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
    }

    function blit(target) {
        if (target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            gl.viewport(0, 0, target.width, target.height);
        } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    // Apply force at position
    function applyForce(x, y, dx, dy) {
        gl.useProgram(forceProg.program);
        const u = forceProg.uniforms;

        // Bind force mesh
        const posLoc = gl.getAttribLocation(forceProg.program, 'aPosition');
        const uvLoc = gl.getAttribLocation(forceProg.program, 'aUv');
        gl.bindBuffer(gl.ARRAY_BUFFER, forceBuffer);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
        gl.enableVertexAttribArray(uvLoc);
        gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);

        gl.uniform2fv(u.texelSize, texelSize);
        gl.uniform2f(u.center, x * 2 - 1, y * 2 - 1);
        gl.uniform2f(u.scale, CONFIG.cursorSize, CONFIG.cursorSize);
        gl.uniform2f(u.force, dx * CONFIG.mouseForce, dy * CONFIG.mouseForce);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);

        gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.write.fbo);
        gl.viewport(0, 0, simW, simH);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.disable(gl.BLEND);
        velocity.swap();
    }

    function step() {
        // Advection
        gl.useProgram(advectionProg.program);
        bindQuad(advectionProg);
        const advU = advectionProg.uniforms;
        gl.uniform2fv(advU.texelSize, texelSize);
        gl.uniform2fv(advU.fboSize, fboSize);
        gl.uniform1f(advU.dt, CONFIG.dt);
        gl.uniform1i(advU.isBFECC, CONFIG.BFECC);
        gl.uniform1i(advU.velocity, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        blit(velocity.write);
        velocity.swap();

        // Divergence
        gl.useProgram(divergenceProg.program);
        bindQuad(divergenceProg);
        const divU = divergenceProg.uniforms;
        gl.uniform2fv(divU.texelSize, texelSize);
        gl.uniform1f(divU.dt, CONFIG.dt);
        gl.uniform1i(divU.velocity, 0);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        blit(divergence);

        // Poisson iterations
        gl.useProgram(poissonProg.program);
        bindQuad(poissonProg);
        const poisU = poissonProg.uniforms;
        gl.uniform2fv(poisU.texelSize, texelSize);
        for (let i = 0; i < CONFIG.iterationsPoisson; i++) {
            gl.uniform1i(poisU.pressure, 0);
            gl.uniform1i(poisU.divergence, 1);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, divergence.texture);
            blit(pressure.write);
            pressure.swap();
        }

        // Pressure gradient subtraction
        gl.useProgram(pressureProg.program);
        bindQuad(pressureProg);
        const presU = pressureProg.uniforms;
        gl.uniform2fv(presU.texelSize, texelSize);
        gl.uniform1f(presU.dt, CONFIG.dt);
        gl.uniform1i(presU.pressure, 0);
        gl.uniform1i(presU.velocity, 1);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        blit(velocity.write);
        velocity.swap();
    }

    function render() {
        gl.useProgram(colorProg.program);
        bindQuad(colorProg);
        const colU = colorProg.uniforms;
        gl.uniform2fv(colU.texelSize, texelSize);
        gl.uniform1i(colU.velocity, 0);
        gl.uniform1i(colU.palette, 1);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, paletteTex);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.disable(gl.BLEND);
    }

    // Mouse/touch handling
    let mouse = { x: 0.5, y: 0.5, px: 0.5, py: 0.5, isHovering: false };
    let lastInteraction = 0;

    function updateMouse(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        mouse.px = mouse.x;
        mouse.py = mouse.y;
        mouse.x = (clientX - rect.left) / rect.width;
        mouse.y = 1 - (clientY - rect.top) / rect.height;
        mouse.isHovering = true;
        lastInteraction = performance.now();
    }

    canvas.addEventListener('mousemove', (e) => updateMouse(e.clientX, e.clientY));
    canvas.addEventListener('mouseleave', () => { mouse.isHovering = false; });
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        updateMouse(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    canvas.addEventListener('touchend', () => { mouse.isHovering = false; });

    // Auto demo cursor
    let autoCursor = { x: 0.5, y: 0.5, targetX: 0.7, targetY: 0.3 };

    function pickNewTarget() {
        autoCursor.targetX = 0.2 + Math.random() * 0.6;
        autoCursor.targetY = 0.2 + Math.random() * 0.6;
    }

    function updateAutoCursor(dt) {
        const dx = autoCursor.targetX - autoCursor.x;
        const dy = autoCursor.targetY - autoCursor.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 0.02) {
            pickNewTarget();
            return;
        }

        const speed = CONFIG.autoSpeed * dt;
        const move = Math.min(speed, dist);
        autoCursor.x += (dx / dist) * move;
        autoCursor.y += (dy / dist) * move;
    }

    // Animation loop
    let lastTime = performance.now();

    function animate() {
        const now = performance.now();
        const dt = Math.min((now - lastTime) / 1000, 0.05);
        lastTime = now;

        // Check if we should use auto cursor or real mouse
        const idleTime = now - lastInteraction;
        const useAuto = CONFIG.autoDemo && (idleTime > CONFIG.autoResumeDelay || !mouse.isHovering);

        if (useAuto) {
            updateAutoCursor(dt);
            const dx = (autoCursor.x - mouse.px) * CONFIG.autoIntensity;
            const dy = (autoCursor.y - mouse.py) * CONFIG.autoIntensity;
            mouse.px = autoCursor.x;
            mouse.py = autoCursor.y;
            applyForce(autoCursor.x, autoCursor.y, dx * 0.5, dy * 0.5);
        } else if (mouse.isHovering) {
            const dx = mouse.x - mouse.px;
            const dy = mouse.y - mouse.py;
            if (Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001) {
                applyForce(mouse.x, mouse.y, dx, dy);
            }
        }

        step();
        render();
        requestAnimationFrame(animate);
    }

    animate();
})();
</script>
</body>
</html>
