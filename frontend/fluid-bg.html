<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Background</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0f;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<canvas id="fluid"></canvas>
<script>
(function() {
    'use strict';

    const canvas = document.getElementById('fluid');
    const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false });

    if (!gl) {
        document.body.style.background = 'radial-gradient(ellipse at 30% 30%, rgba(139,92,246,0.4) 0%, transparent 50%), radial-gradient(ellipse at 70% 70%, rgba(236,72,153,0.4) 0%, transparent 50%), #0a0a0f';
        return;
    }

    // Extensions
    const ext = {
        float: gl.getExtension('OES_texture_float'),
        floatLinear: gl.getExtension('OES_texture_float_linear'),
        halfFloat: gl.getExtension('OES_texture_half_float'),
        halfFloatLinear: gl.getExtension('OES_texture_half_float_linear')
    };

    let texType = gl.UNSIGNED_BYTE;
    if (ext.float && ext.floatLinear) texType = gl.FLOAT;
    else if (ext.halfFloat && ext.halfFloatLinear) texType = ext.halfFloat.HALF_FLOAT_OES;

    // Config
    const CONFIG = {
        colors: ['#8b5cf6', '#ec4899', '#3b82f6', '#06b6d4'],
        mouseForce: 100,
        splatRadius: 0.005,
        resolution: 0.5,
        densityDissipation: 0.97,
        velocityDissipation: 0.98,
        pressureIterations: 20
    };

    function hexToRgb(hex) {
        const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return r ? [parseInt(r[1],16)/255, parseInt(r[2],16)/255, parseInt(r[3],16)/255] : [0.5,0.3,0.8];
    }

    // Shaders
    const baseVS = `
        attribute vec2 aPosition;
        varying vec2 vUv, vL, vR, vT, vB;
        uniform vec2 texelSize;
        void main() {
            vUv = aPosition * 0.5 + 0.5;
            vL = vUv - vec2(texelSize.x, 0.0);
            vR = vUv + vec2(texelSize.x, 0.0);
            vT = vUv + vec2(0.0, texelSize.y);
            vB = vUv - vec2(0.0, texelSize.y);
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    `;

    const splatFS = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uTarget;
        uniform float aspectRatio;
        uniform vec3 color;
        uniform vec2 point;
        uniform float radius;
        void main() {
            vec2 p = vUv - point;
            p.x *= aspectRatio;
            vec3 splat = exp(-dot(p, p) / radius) * color;
            vec3 base = texture2D(uTarget, vUv).xyz;
            gl_FragColor = vec4(base + splat, 1.0);
        }
    `;

    const advectionFS = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uVelocity, uSource;
        uniform vec2 texelSize;
        uniform float dt, dissipation;
        void main() {
            vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
            gl_FragColor = dissipation * texture2D(uSource, coord);
        }
    `;

    const divergenceFS = `
        precision highp float;
        varying vec2 vL, vR, vT, vB;
        uniform sampler2D uVelocity;
        void main() {
            float L = texture2D(uVelocity, vL).x;
            float R = texture2D(uVelocity, vR).x;
            float T = texture2D(uVelocity, vT).y;
            float B = texture2D(uVelocity, vB).y;
            gl_FragColor = vec4(0.5 * (R - L + T - B), 0.0, 0.0, 1.0);
        }
    `;

    const pressureFS = `
        precision highp float;
        varying vec2 vUv, vL, vR, vT, vB;
        uniform sampler2D uPressure, uDivergence;
        void main() {
            float L = texture2D(uPressure, vL).x;
            float R = texture2D(uPressure, vR).x;
            float T = texture2D(uPressure, vT).x;
            float B = texture2D(uPressure, vB).x;
            float C = texture2D(uDivergence, vUv).x;
            gl_FragColor = vec4((L + R + B + T - C) * 0.25, 0.0, 0.0, 1.0);
        }
    `;

    const gradientFS = `
        precision highp float;
        varying vec2 vUv, vL, vR, vT, vB;
        uniform sampler2D uPressure, uVelocity;
        void main() {
            float L = texture2D(uPressure, vL).x;
            float R = texture2D(uPressure, vR).x;
            float T = texture2D(uPressure, vT).x;
            float B = texture2D(uPressure, vB).x;
            vec2 v = texture2D(uVelocity, vUv).xy - vec2(R - L, T - B);
            gl_FragColor = vec4(v, 0.0, 1.0);
        }
    `;

    const clearFS = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        uniform float value;
        void main() { gl_FragColor = value * texture2D(uTexture, vUv); }
    `;

    const displayFS = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        void main() {
            vec3 c = texture2D(uTexture, vUv).rgb;
            c = pow(c, vec3(0.8)) * 1.5;
            float a = min(max(c.r, max(c.g, c.b)) * 1.2, 1.0);
            gl_FragColor = vec4(c, a);
        }
    `;

    function compile(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        return s;
    }

    function createProgram(vs, fs) {
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(p);
        const u = {};
        const n = gl.getProgramParameter(p, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; i++) {
            const info = gl.getActiveUniform(p, i);
            u[info.name] = gl.getUniformLocation(p, info.name);
        }
        return { program: p, uniforms: u };
    }

    const vs = compile(gl.VERTEX_SHADER, baseVS);
    const splatProg = createProgram(vs, splatFS);
    const advectionProg = createProgram(vs, advectionFS);
    const divergenceProg = createProgram(vs, divergenceFS);
    const pressureProg = createProgram(vs, pressureFS);
    const gradientProg = createProgram(vs, gradientFS);
    const clearProg = createProgram(vs, clearFS);
    const displayProg = createProgram(vs, displayFS);

    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

    function createFBO(w, h) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, texType, null);
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return { texture: tex, fbo, width: w, height: h };
    }

    function createDoubleFBO(w, h) {
        let a = createFBO(w, h), b = createFBO(w, h);
        return {
            get read() { return a; },
            get write() { return b; },
            swap() { const t = a; a = b; b = t; }
        };
    }

    let velocity, density, pressure, divergence;
    let texelSize, aspectRatio, simW, simH;

    function resize() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        simW = Math.floor(canvas.width * CONFIG.resolution);
        simH = Math.floor(canvas.height * CONFIG.resolution);
        texelSize = [1/simW, 1/simH];
        aspectRatio = canvas.width / canvas.height;
        velocity = createDoubleFBO(simW, simH);
        density = createDoubleFBO(simW, simH);
        pressure = createDoubleFBO(simW, simH);
        divergence = createFBO(simW, simH);
    }

    resize();
    window.addEventListener('resize', resize);

    function useProgram(prog) {
        gl.useProgram(prog.program);
        gl.uniform2fv(prog.uniforms.texelSize, texelSize);
        const loc = gl.getAttribLocation(prog.program, 'aPosition');
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
        return prog.uniforms;
    }

    function blit(target) {
        if (target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            gl.viewport(0, 0, target.width, target.height);
        } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function splat(x, y, dx, dy, color) {
        const u = useProgram(splatProg);
        gl.uniform1i(u.uTarget, 0);
        gl.uniform1f(u.aspectRatio, aspectRatio);
        gl.uniform2f(u.point, x, y);
        gl.uniform1f(u.radius, CONFIG.splatRadius);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        gl.uniform3f(u.color, dx * CONFIG.mouseForce, dy * CONFIG.mouseForce, 0);
        blit(velocity.write);
        velocity.swap();

        gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
        gl.uniform3f(u.color, color[0] * 0.8, color[1] * 0.8, color[2] * 0.8);
        gl.uniform1f(u.radius, CONFIG.splatRadius * 1.5);
        blit(density.write);
        density.swap();
    }

    function step(dt) {
        // Advect velocity
        let u = useProgram(advectionProg);
        gl.uniform1f(u.dt, dt);
        gl.uniform1f(u.dissipation, CONFIG.velocityDissipation);
        gl.uniform1i(u.uVelocity, 0);
        gl.uniform1i(u.uSource, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        blit(velocity.write);
        velocity.swap();

        // Advect density
        gl.uniform1f(u.dissipation, CONFIG.densityDissipation);
        gl.uniform1i(u.uSource, 1);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        blit(density.write);
        density.swap();

        // Divergence
        u = useProgram(divergenceProg);
        gl.uniform1i(u.uVelocity, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        blit(divergence);

        // Clear pressure
        u = useProgram(clearProg);
        gl.uniform1i(u.uTexture, 0);
        gl.uniform1f(u.value, 0.8);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
        blit(pressure.write);
        pressure.swap();

        // Pressure solve
        u = useProgram(pressureProg);
        gl.uniform1i(u.uDivergence, 1);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, divergence.texture);
        for (let i = 0; i < CONFIG.pressureIterations; i++) {
            gl.uniform1i(u.uPressure, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
            blit(pressure.write);
            pressure.swap();
        }

        // Gradient subtract
        u = useProgram(gradientProg);
        gl.uniform1i(u.uPressure, 0);
        gl.uniform1i(u.uVelocity, 1);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
        blit(velocity.write);
        velocity.swap();
    }

    function render() {
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        const u = useProgram(displayProg);
        gl.uniform1i(u.uTexture, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, density.read.texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.039, 0.039, 0.059, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    // Pointer handling
    let pointer = { x: 0.5, y: 0.5, dx: 0, dy: 0, moved: false, down: false };
    let colorIndex = 0;

    function updatePointer(x, y) {
        const rect = canvas.getBoundingClientRect();
        const px = (x - rect.left) / rect.width;
        const py = 1 - (y - rect.top) / rect.height;
        pointer.dx = (px - pointer.x) * 30;
        pointer.dy = (py - pointer.y) * 30;
        pointer.x = px;
        pointer.y = py;
        pointer.moved = true;
    }

    canvas.addEventListener('mousedown', (e) => {
        pointer.down = true;
        colorIndex = (colorIndex + 1) % CONFIG.colors.length;
        updatePointer(e.clientX, e.clientY);
    });
    canvas.addEventListener('mousemove', (e) => updatePointer(e.clientX, e.clientY));
    canvas.addEventListener('mouseup', () => pointer.down = false);
    canvas.addEventListener('mouseleave', () => pointer.down = false);

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        pointer.down = true;
        colorIndex = (colorIndex + 1) % CONFIG.colors.length;
        updatePointer(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        updatePointer(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    canvas.addEventListener('touchend', () => pointer.down = false);

    // Animation
    let autoTime = 0;
    let lastTime = performance.now();

    function animate() {
        const now = performance.now();
        const dt = Math.min((now - lastTime) / 1000, 0.016);
        lastTime = now;

        // Auto demo - multiple points
        autoTime += dt * 1.2;
        const pts = [
            { ox: 0.3, oy: 0.3, sx: 0.7, sy: 0.5 },
            { ox: 0.7, oy: 0.7, sx: 0.5, sy: 0.7 },
            { ox: 0.5, oy: 0.5, sx: 0.6, sy: 0.6 }
        ];
        for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const t = autoTime + i * 2;
            const ax = p.ox + 0.25 * Math.sin(t * p.sx);
            const ay = p.oy + 0.25 * Math.cos(t * p.sy);
            const adx = Math.cos(t * 1.1) * 0.15;
            const ady = Math.sin(t * 0.9) * 0.15;
            const ci = (i + Math.floor(autoTime * 0.3)) % CONFIG.colors.length;
            splat(ax, ay, adx, ady, hexToRgb(CONFIG.colors[ci]));
        }

        // User input
        if (pointer.moved || pointer.down) {
            const force = pointer.down ? 2 : 1;
            splat(pointer.x, pointer.y, pointer.dx * force, pointer.dy * force, hexToRgb(CONFIG.colors[colorIndex]));
            pointer.moved = false;
            pointer.dx *= 0.8;
            pointer.dy *= 0.8;
        }

        step(dt);
        render();
        requestAnimationFrame(animate);
    }

    animate();
})();
</script>
</body>
</html>
