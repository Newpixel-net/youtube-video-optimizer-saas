<!-- ================================================================
     YOUTUBE VIDEO OPTIMIZER - VIDEO CREATION WIZARD
     ================================================================

     Structure:
     - SECTION 1: External Dependencies (CDN)
     - SECTION 2: Styles (CSS)
     - SECTION 3: HTML Container
     - SECTION 4: Configuration Data (Platforms, Niches, Styles)
     - SECTION 5: State Management
     - SECTION 6: Core Functions
     - SECTION 7: Render Functions

     Wizard Steps:
     1. Platform & Format - Select target platform and aspect ratio
     2. Niche & Style - Choose content niche and visual style
     3. Script Generation - AI generates video script with scenes
     4. Storyboard - Generate images for each scene
     5. Animation - Animate images to video (Runpod/Veo)
     6. Assembly - Combine scenes, add music, captions
     7. Export - Final render and download

     Video Generation Engines:
     - Runpod Multi-talk: 15-second clips, ~$0.03-0.05/clip
     - Google Veo 3.1: 8-second base (extendable), $0.15-0.40/second

     Access: All authenticated users (with token system)
     Last Updated: December 2025
     ================================================================ -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Video Creation Wizard - YouTubeHub</title>

    <!-- PWA Manifest & Theme -->
    <link rel="manifest" href='data:application/manifest+json,{"name":"YouTubeHub Video Creator","short_name":"Video Creator","description":"AI-powered video creation from scratch","start_url":"/video-creation-wizard","display":"standalone","background_color":"#0f172a","theme_color":"#8b5cf6","orientation":"portrait-primary","icons":[{"src":"https://ytseo.siteuo.com/icon-192.png","sizes":"192x192","type":"image/png","purpose":"any maskable"},{"src":"https://ytseo.siteuo.com/icon-512.png","sizes":"512x512","type":"image/png","purpose":"any maskable"}]}'>
    <meta name="theme-color" content="#8b5cf6">

    <!-- ============================================
         SECTION 1: EXTERNAL DEPENDENCIES
         ============================================ -->

    <!-- 1.0 Performance: Preconnect & DNS Prefetch -->
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://firebasestorage.googleapis.com" crossorigin>
    <link rel="dns-prefetch" href="https://www.gstatic.com">
    <link rel="dns-prefetch" href="https://firestore.googleapis.com">

    <!-- 1.1 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 1.2 Google Fonts for Caption Styling -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Bebas+Neue&family=Inter:wght@400;600;700&family=Montserrat:wght@400;600;700;800&family=Oswald:wght@400;600;700&family=Playfair+Display:wght@400;600;700&family=Poppins:wght@400;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- 1.3 Firebase SDKs -->
    <link rel="preload" href="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js" as="script">
    <link rel="preload" href="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js" as="script">
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-functions-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-storage-compat.js"></script>

    <!-- VideoPreviewEngine (inlined to avoid path issues with Firebase rewrites) -->
    <script>
    /**
     * VideoPreviewEngine - Client-side video preview compositor
     * Renders scenes to a canvas with synchronized audio, transitions,
     * Ken Burns effects, and caption overlays.
     */
    class VideoPreviewEngine {
        constructor(canvas, options = {}) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');

            // Dimensions
            this.width = options.width || 1280;
            this.height = options.height || 720;
            canvas.width = this.width;
            canvas.height = this.height;

            // State
            this.scenes = [];
            this.currentTime = 0;
            this.isPlaying = false;
            this.isSeeking = false;
            this.totalDuration = 0;
            this.currentSceneIndex = -1;

            // Audio
            this.audioElements = new Map();
            this.musicElement = null;
            this.musicVolume = 0.3;
            this.voiceVolume = 1.0;

            // Media cache
            this.imageCache = new Map();
            this.videoCache = new Map();

            // Animation
            this.animationFrameId = null;
            this.lastFrameTime = 0;

            // Callbacks
            this.onTimeUpdate = options.onTimeUpdate || (() => {});
            this.onSceneChange = options.onSceneChange || (() => {});
            this.onEnded = options.onEnded || (() => {});
            this.onLoadProgress = options.onLoadProgress || (() => {});
            this.onReady = options.onReady || (() => {});

            // Captions - unified system matching export styles
            this.captionsEnabled = true;
            this.captionStyle = 'karaoke';  // Default style
            this.captionPosition = 'bottom';
            this.captionSize = 1.0;  // Size multiplier (0.7 - 1.5)

            // Enhanced caption properties (Phase 2)
            this.captionMode = 'word';           // 'word' or 'sentence'
            this.captionFontFamily = 'Montserrat';
            this.captionFontWeight = 600;
            this.captionFillColor = '#FFFFFF';
            this.captionStrokeColor = '#000000';
            this.captionStrokeWidth = 2;
            this.captionEffect = 'none';         // 'none', 'pop', 'fade', 'zoom', 'bounce'
            this.captionHighlightColor = '#FBBF24';

            this._renderLoop = this._renderLoop.bind(this);
        }

        async loadScenes(scenes) {
            this.scenes = scenes.map((scene, index) => ({
                ...scene,
                index,
                startTime: 0,
                endTime: 0
            }));

            this._calculateTiming();
            await this._preloadMedia();
            this._renderFrame();
            this.onReady();
        }

        _calculateTiming() {
            let currentTime = 0;
            for (const scene of this.scenes) {
                scene.startTime = currentTime;
                scene.endTime = currentTime + (scene.visualDuration || scene.duration || 5);
                currentTime = scene.endTime;
            }
            this.totalDuration = currentTime;
        }

        async _preloadMedia() {
            const loadPromises = [];
            let loaded = 0;
            let total = 0;

            // Count total media items to load
            for (const scene of this.scenes) {
                if (scene.imageUrl && !scene.videoUrl) total++;
                if (scene.videoUrl) total++;
                if (scene.voiceoverUrl) total++;
            }

            // If no media to load, still report progress
            if (total === 0) {
                this.onLoadProgress(1);
                return;
            }

            const updateProgress = () => {
                loaded++;
                this.onLoadProgress(Math.min(loaded / total, 1));
            };

            for (const scene of this.scenes) {
                if (scene.imageUrl && !scene.videoUrl) {
                    loadPromises.push(
                        this._loadImage(scene.imageUrl)
                            .then(updateProgress)
                            .catch(updateProgress) // Still update progress on error
                    );
                }

                if (scene.videoUrl) {
                    loadPromises.push(
                        this._loadVideo(scene.videoUrl)
                            .then(updateProgress)
                            .catch(updateProgress)
                    );
                }

                if (scene.voiceoverUrl) {
                    loadPromises.push(
                        this._loadAudio(scene.id, scene.voiceoverUrl)
                            .then(updateProgress)
                            .catch(updateProgress)
                    );
                }
            }

            // Use allSettled to ensure we complete even if some fail
            await Promise.allSettled(loadPromises);
        }

        _loadImage(url) {
            return new Promise((resolve) => {
                if (this.imageCache.has(url)) {
                    resolve(this.imageCache.get(url));
                    return;
                }

                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    this.imageCache.set(url, img);
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn('Failed to load image:', url);
                    resolve(null);
                };
                img.src = url;
            });
        }

        _loadVideo(url) {
            return new Promise((resolve) => {
                if (this.videoCache.has(url)) {
                    resolve(this.videoCache.get(url));
                    return;
                }

                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.muted = true;
                video.playsInline = true;
                video.preload = 'auto';

                video.onloadeddata = () => {
                    this.videoCache.set(url, video);
                    resolve(video);
                };
                video.onerror = () => {
                    console.warn('Failed to load video:', url);
                    resolve(null);
                };
                video.src = url;
                video.load();
            });
        }

        _loadAudio(sceneId, url) {
            return new Promise((resolve) => {
                if (this.audioElements.has(sceneId)) {
                    resolve(this.audioElements.get(sceneId));
                    return;
                }

                const audio = new Audio();
                audio.crossOrigin = 'anonymous';
                audio.preload = 'auto';

                audio.oncanplaythrough = () => {
                    this.audioElements.set(sceneId, audio);
                    resolve(audio);
                };
                audio.onerror = () => {
                    console.warn('Failed to load audio:', url);
                    resolve(null);
                };
                audio.src = url;
                audio.load();
            });
        }

        setBackgroundMusic(url, volume = 0.3) {
            if (this.musicElement) {
                this.musicElement.pause();
                this.musicElement = null;
            }

            if (url) {
                this.musicElement = new Audio(url);
                this.musicElement.loop = true;
                this.musicElement.volume = volume;
                this.musicVolume = volume;

                if (this.isPlaying) {
                    this.musicElement.currentTime = this.currentTime;
                    this.musicElement.play().catch(() => {});
                }
            }
        }

        stopBackgroundMusic() {
            if (this.musicElement) {
                this.musicElement.pause();
                this.musicElement = null;
            }
        }

        play() {
            if (this.isPlaying) return;

            this.isPlaying = true;
            this.lastFrameTime = performance.now();

            if (this.musicElement) {
                this.musicElement.currentTime = this.currentTime;
                this.musicElement.play().catch(() => {});
            }

            this._syncAudio();
            this.animationFrameId = requestAnimationFrame(this._renderLoop);
        }

        pause() {
            this.isPlaying = false;

            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }

            this.audioElements.forEach(audio => audio.pause());
            if (this.musicElement) this.musicElement.pause();
        }

        stop() {
            this.pause();
            this.seek(0);
        }

        seek(time) {
            this.isSeeking = true;
            this.currentTime = Math.max(0, Math.min(time, this.totalDuration));

            this._syncAudio();

            if (this.musicElement) {
                this.musicElement.currentTime = this.currentTime;
            }

            this._renderFrame();
            this.onTimeUpdate(this.currentTime);
            this.isSeeking = false;
        }

        jumpToScene(sceneIndex) {
            const scene = this.scenes[sceneIndex];
            if (scene) {
                this.seek(scene.startTime);
            }
        }

        _syncAudio() {
            const currentScene = this._getSceneAtTime(this.currentTime);

            // Pause audio from other scenes
            this.audioElements.forEach((audio, sceneId) => {
                if (!currentScene || sceneId !== currentScene.id) {
                    if (!audio.paused) {
                        audio.pause();
                    }
                }
            });

            if (currentScene) {
                const audio = this.audioElements.get(currentScene.id);
                if (audio) {
                    const sceneLocalTime = this.currentTime - currentScene.startTime;
                    const voiceoverOffset = currentScene.voiceoverOffset || 0;
                    const audioTime = sceneLocalTime - voiceoverOffset;

                    if (audioTime >= 0 && audioTime < audio.duration) {
                        // Only sync if audio has drifted more than 0.3s to avoid stuttering
                        const drift = Math.abs(audio.currentTime - audioTime);
                        if (drift > 0.3) {
                            audio.currentTime = audioTime;
                        }

                        audio.volume = this.voiceVolume;

                        // Only call play if not already playing
                        if (this.isPlaying && audio.paused) {
                            audio.play().catch(() => {});
                        }
                    } else {
                        if (!audio.paused) {
                            audio.pause();
                        }
                    }
                }
            }
        }

        _renderLoop(timestamp) {
            if (!this.isPlaying) return;

            const deltaTime = (timestamp - this.lastFrameTime) / 1000;
            this.lastFrameTime = timestamp;

            this.currentTime += deltaTime;

            if (this.currentTime >= this.totalDuration) {
                this.currentTime = this.totalDuration;
                this.pause();
                this.onEnded();
                return;
            }

            this._renderFrame();

            if (Math.floor(this.currentTime * 2) !== Math.floor((this.currentTime - deltaTime) * 2)) {
                this._syncAudio();
            }

            this.onTimeUpdate(this.currentTime);
            this.animationFrameId = requestAnimationFrame(this._renderLoop);
        }

        _renderFrame() {
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, this.width, this.height);

            const currentScene = this._getSceneAtTime(this.currentTime);
            const prevScene = this._getPreviousScene(currentScene);

            if (!currentScene) return;

            const transitionProgress = this._getTransitionProgress(currentScene);

            if (transitionProgress !== null && prevScene) {
                this._renderTransition(prevScene, currentScene, transitionProgress);
            } else {
                this._renderScene(currentScene);
            }

            // Only render captions during the voiceover timing window
            if (this.captionsEnabled && currentScene.caption) {
                const sceneLocalTime = this.currentTime - currentScene.startTime;
                const voiceoverOffset = currentScene.voiceoverOffset || 0;
                const voiceoverDuration = currentScene.voiceoverDuration || (currentScene.duration * 0.85);

                // Check if we're within the voiceover window
                const captionStart = voiceoverOffset;
                const captionEnd = voiceoverOffset + voiceoverDuration;

                if (sceneLocalTime >= captionStart && sceneLocalTime < captionEnd) {
                    this._renderCaption(currentScene);
                }
            }

            if (currentScene.index !== this.currentSceneIndex) {
                this.currentSceneIndex = currentScene.index;
                this.onSceneChange(this.currentSceneIndex);
            }
        }

        _getSceneAtTime(time) {
            return this.scenes.find(scene =>
                time >= scene.startTime && time < scene.endTime
            ) || this.scenes[this.scenes.length - 1];
        }

        _getPreviousScene(currentScene) {
            if (!currentScene || currentScene.index === 0) return null;
            return this.scenes[currentScene.index - 1];
        }

        _getTransitionProgress(scene) {
            if (!scene || scene.index === 0) return null;

            const transitionDuration = scene.transitionDuration || 0.5;
            const timeIntoScene = this.currentTime - scene.startTime;

            if (timeIntoScene < transitionDuration) {
                return timeIntoScene / transitionDuration;
            }

            return null;
        }

        _renderScene(scene, opacity = 1) {
            this.ctx.save();
            this.ctx.globalAlpha = opacity;

            if (scene.videoUrl && this.videoCache.has(scene.videoUrl)) {
                this._renderVideoScene(scene);
            } else if (scene.imageUrl) {
                this._renderImageScene(scene);
            } else {
                this._renderPlaceholder(scene);
            }

            this.ctx.restore();
        }

        _renderVideoScene(scene) {
            const video = this.videoCache.get(scene.videoUrl);
            if (!video) return;

            const sceneLocalTime = this.currentTime - scene.startTime;

            if (Math.abs(video.currentTime - sceneLocalTime) > 0.2) {
                video.currentTime = sceneLocalTime;
            }

            if (this.isPlaying && video.paused) {
                video.play().catch(() => {});
            } else if (!this.isPlaying && !video.paused) {
                video.pause();
            }

            this._drawMediaCover(video, video.videoWidth, video.videoHeight);
        }

        _renderImageScene(scene) {
            const img = this.imageCache.get(scene.imageUrl);
            if (!img) {
                this._renderPlaceholder(scene);
                return;
            }

            const progress = (this.currentTime - scene.startTime) / (scene.endTime - scene.startTime);
            const kenBurns = scene.kenBurns || {
                startZoom: 1.0,
                endZoom: 1.15,
                startX: 0.5,
                startY: 0.5,
                endX: 0.5,
                endY: 0.5
            };

            const zoom = kenBurns.startZoom + (kenBurns.endZoom - kenBurns.startZoom) * progress;
            const panX = (kenBurns.startX || 0.5) + ((kenBurns.endX || 0.5) - (kenBurns.startX || 0.5)) * progress;
            const panY = (kenBurns.startY || 0.5) + ((kenBurns.endY || 0.5) - (kenBurns.startY || 0.5)) * progress;

            this.ctx.save();
            this.ctx.translate(this.width / 2, this.height / 2);
            this.ctx.scale(zoom, zoom);
            this.ctx.translate(
                -this.width / 2 + (panX - 0.5) * this.width * 0.1,
                -this.height / 2 + (panY - 0.5) * this.height * 0.1
            );

            this._drawMediaCover(img, img.width, img.height);
            this.ctx.restore();
        }

        _drawMediaCover(media, mediaWidth, mediaHeight) {
            const canvasRatio = this.width / this.height;
            const mediaRatio = mediaWidth / mediaHeight;

            let drawWidth, drawHeight, offsetX, offsetY;

            if (mediaRatio > canvasRatio) {
                drawHeight = this.height;
                drawWidth = this.height * mediaRatio;
                offsetX = (this.width - drawWidth) / 2;
                offsetY = 0;
            } else {
                drawWidth = this.width;
                drawHeight = this.width / mediaRatio;
                offsetX = 0;
                offsetY = (this.height - drawHeight) / 2;
            }

            this.ctx.drawImage(media, offsetX, offsetY, drawWidth, drawHeight);
        }

        _renderPlaceholder(scene) {
            // Gradient background
            const gradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#2d1b4e');
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.width, this.height);

            // Scene number badge
            this.ctx.fillStyle = 'rgba(139, 92, 246, 0.3)';
            this.ctx.beginPath();
            this.ctx.arc(this.width / 2, this.height / 2 - 40, 60, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.font = 'bold 42px system-ui';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(`${scene.index + 1}`, this.width / 2, this.height / 2 - 40);

            // "Scene X" label
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.font = '24px system-ui';
            this.ctx.fillText(`Scene ${scene.index + 1}`, this.width / 2, this.height / 2 + 30);

            // Show first part of narration if available
            const narration = scene.caption || scene.narration || '';
            if (narration) {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.font = '18px system-ui';
                const truncated = narration.length > 80 ? narration.substring(0, 80) + '...' : narration;
                this.ctx.fillText(truncated, this.width / 2, this.height / 2 + 70);
            }

            // Duration indicator
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.font = '16px system-ui';
            this.ctx.fillText(`${scene.duration || 8}s`, this.width / 2, this.height - 30);
        }

        _renderTransition(fromScene, toScene, progress) {
            const transition = toScene.transition || 'cut';

            switch (transition) {
                case 'fade':
                    this._renderFadeTransition(fromScene, toScene, progress);
                    break;
                case 'slide':
                    this._renderSlideTransition(fromScene, toScene, progress);
                    break;
                case 'zoom':
                    this._renderZoomTransition(fromScene, toScene, progress);
                    break;
                case 'cut':
                default:
                    this._renderScene(toScene);
                    break;
            }
        }

        _renderFadeTransition(fromScene, toScene, progress) {
            this._renderScene(fromScene, 1 - progress);
            this._renderScene(toScene, progress);
        }

        _renderSlideTransition(fromScene, toScene, progress) {
            const easeProgress = this._easeInOutCubic(progress);
            const offset = this.width * (1 - easeProgress);

            this.ctx.save();
            this.ctx.translate(-offset, 0);
            this._renderScene(fromScene);
            this.ctx.restore();

            this.ctx.save();
            this.ctx.translate(this.width - offset, 0);
            this._renderScene(toScene);
            this.ctx.restore();
        }

        _renderZoomTransition(fromScene, toScene, progress) {
            const easeProgress = this._easeInOutCubic(progress);

            this.ctx.save();
            this.ctx.globalAlpha = 1 - easeProgress;
            this.ctx.translate(this.width / 2, this.height / 2);
            this.ctx.scale(1 + easeProgress * 0.3, 1 + easeProgress * 0.3);
            this.ctx.translate(-this.width / 2, -this.height / 2);
            this._renderScene(fromScene, 1);
            this.ctx.restore();

            this._renderScene(toScene, easeProgress);
        }

        _easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        /**
         * Style-aware caption rendering - matches export ASS styles
         * Supports: karaoke, beasty, hormozi, ali, podcast, minimal, none
         */
        _renderCaption(scene) {
            // Skip if style is 'none'
            if (this.captionStyle === 'none') return;

            const caption = scene.caption || scene.narration || '';
            if (!caption) return;

            // Use voiceover timing for accurate synchronization
            const voiceoverOffset = scene.voiceoverOffset || 0;
            const voiceoverDuration = scene.voiceoverDuration || (scene.duration * 0.85);
            const sceneLocalTime = this.currentTime - scene.startTime;

            // Calculate time relative to voiceover start (not scene start)
            // This ensures captions sync with audio, not visual scene boundaries
            const captionLocalTime = sceneLocalTime - voiceoverOffset;

            // Generate word timings based on actual voiceover duration
            const wordTimings = this._generateWordTimings(caption, voiceoverDuration);

            // Handle word vs sentence mode
            let displayWords, currentWordIndex;
            if (this.captionMode === 'sentence') {
                // Sentence mode: show all words, no word-by-word highlighting
                displayWords = wordTimings;
                currentWordIndex = -1; // No current word highlighting
            } else {
                // Word mode: show window of words with highlighting
                const wordsPerLine = this._getWordsPerLine();
                currentWordIndex = this._getCurrentWordIndex(wordTimings, captionLocalTime);
                displayWords = this._getDisplayWords(wordTimings, currentWordIndex, wordsPerLine);
            }

            if (displayWords.length === 0) return;

            this.ctx.save();

            // Calculate position
            let y;
            switch (this.captionPosition) {
                case 'top': y = this.height * 0.12; break;
                case 'middle': case 'center': y = this.height * 0.5; break;
                case 'bottom': default: y = this.height * 0.88; break;
            }

            // Render based on style (using captionLocalTime for word highlighting)
            switch (this.captionStyle) {
                case 'karaoke':
                    this._renderKaraokeStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'beasty':
                    this._renderBeastyStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'hormozi':
                    this._renderHormoziStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'ali':
                    this._renderAliStyle(displayWords, y, captionLocalTime);
                    break;
                case 'podp':
                case 'podcast':
                    this._renderPodcastStyle(displayWords, y, captionLocalTime, currentWordIndex);
                    break;
                case 'deepdiver':
                case 'minimal':
                    this._renderMinimalStyle(displayWords, y);
                    break;
                default:
                    this._renderDefaultStyle(displayWords, y, captionLocalTime, currentWordIndex);
            }

            this.ctx.restore();
        }

        _generateWordTimings(text, duration) {
            const words = text.split(/\s+/).filter(w => w.length > 0);
            if (words.length === 0) return [];

            const avgWordDuration = duration / words.length;
            return words.map((word, i) => ({
                text: word,
                start: i * avgWordDuration,
                end: (i + 1) * avgWordDuration,
                index: i
            }));
        }

        _getWordsPerLine() {
            const styleWordCounts = {
                karaoke: 4, beasty: 3, hormozi: 4, ali: 5,
                podp: 5, podcast: 5, deepdiver: 6, minimal: 6
            };
            return styleWordCounts[this.captionStyle] || 4;
        }

        _getCurrentWordIndex(wordTimings, localTime) {
            for (let i = 0; i < wordTimings.length; i++) {
                if (localTime >= wordTimings[i].start && localTime < wordTimings[i].end) {
                    return i;
                }
            }
            // Return last word if past all timings
            return wordTimings.length > 0 ? wordTimings.length - 1 : 0;
        }

        _getDisplayWords(wordTimings, currentIndex, wordsPerLine) {
            // Get a window of words centered around current word
            const halfWindow = Math.floor(wordsPerLine / 2);
            let startIndex = Math.max(0, currentIndex - halfWindow);
            let endIndex = Math.min(wordTimings.length, startIndex + wordsPerLine);

            // Adjust start if we're near the end
            if (endIndex - startIndex < wordsPerLine) {
                startIndex = Math.max(0, endIndex - wordsPerLine);
            }

            return wordTimings.slice(startIndex, endIndex);
        }

        _renderKaraokeStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.045 * this.captionSize);
            // Use custom font family with fallbacks
            const fontFamily = `${this.captionFontFamily}, Arial, sans-serif`;
            this.ctx.font = `${this.captionFontWeight || 'bold'} ${fontSize}px ${fontFamily}`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text).join(' ');
            const x = this.width / 2;

            // Draw text stroke/outline using custom stroke settings
            if (this.captionStrokeWidth > 0) {
                this.ctx.strokeStyle = this.captionStrokeColor;
                this.ctx.lineWidth = this.captionStrokeWidth * 2;
                this.ctx.strokeText(text, x, y);
            }

            // Draw each word with appropriate color
            let xOffset = x - this.ctx.measureText(text).width / 2;
            words.forEach((word, i) => {
                const isCurrentWord = word.index === currentWordIndex;
                const isPastWord = word.index < currentWordIndex;
                const wordX = xOffset + this.ctx.measureText(word.text).width / 2;
                let wordY = y;

                // Apply text effects for current word
                if (isCurrentWord) {
                    this.ctx.save();
                    const wordWidth = this.ctx.measureText(word.text + ' ').width;
                    const wordCenterX = xOffset + wordWidth / 2;

                    // Apply effect based on setting
                    switch (this.captionEffect) {
                        case 'pop':
                            this.ctx.translate(wordCenterX, y);
                            this.ctx.scale(1.15, 1.15);
                            this.ctx.translate(-wordCenterX, -y);
                            break;
                        case 'zoom':
                            const zoomPhase = (localTime * 2) % 1;
                            const zoomScale = 1 + Math.sin(zoomPhase * Math.PI) * 0.1;
                            this.ctx.translate(wordCenterX, y);
                            this.ctx.scale(zoomScale, zoomScale);
                            this.ctx.translate(-wordCenterX, -y);
                            break;
                        case 'bounce':
                            const bouncePhase = (localTime * 4) % 1;
                            wordY = y - Math.sin(bouncePhase * Math.PI) * 5;
                            break;
                        case 'fade':
                            // Fade effect handled via alpha
                            break;
                        default:
                            // Default subtle scale
                            this.ctx.translate(wordCenterX, y);
                            this.ctx.scale(1.1, 1.1);
                            this.ctx.translate(-wordCenterX, -y);
                    }

                    // Use highlight color for current word
                    this.ctx.fillStyle = this.captionHighlightColor;
                } else if (isPastWord) {
                    this.ctx.fillStyle = this.captionFillColor;  // Custom fill for spoken words
                } else {
                    // Dimmed for future words (50% opacity of fill color)
                    const fillColor = this.captionFillColor;
                    this.ctx.fillStyle = this._hexToRgba(fillColor, 0.5);
                }

                this.ctx.fillText(word.text, wordX, wordY);

                if (isCurrentWord) this.ctx.restore();
                xOffset += this.ctx.measureText(word.text + ' ').width;
            });
        }

        // Helper to convert hex to rgba
        _hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        _renderBeastyStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.055 * this.captionSize);
            // Use custom font if not default MrBeast style
            const fontFamily = this.captionFontFamily !== 'Montserrat'
                ? `${this.captionFontFamily}, Impact, Arial Black, sans-serif`
                : 'Impact, Arial Black, sans-serif';
            this.ctx.font = `900 ${fontSize}px ${fontFamily}`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text.toUpperCase()).join(' ');
            const x = this.width / 2;

            // Use custom stroke settings
            this.ctx.strokeStyle = this.captionStrokeColor;
            this.ctx.lineWidth = Math.max(this.captionStrokeWidth * 2, 6);
            this.ctx.strokeText(text, x, y);

            // Use highlight color for beasty style (gold/yellow by default)
            this.ctx.fillStyle = this.captionHighlightColor;
            this.ctx.fillText(text, x, y);

            // Apply effect based on setting
            const currentWord = words.find(w => w.index === currentWordIndex);
            if (currentWord && this.captionEffect !== 'none') {
                let effectOffset = 0;

                switch (this.captionEffect) {
                    case 'bounce':
                        const bouncePhase = (localTime * 4) % 1;
                        effectOffset = Math.sin(bouncePhase * Math.PI) * 5;
                        break;
                    case 'pop':
                        effectOffset = 2; // Slight lift
                        break;
                    case 'zoom':
                        const zoomPhase = (localTime * 3) % 1;
                        effectOffset = Math.sin(zoomPhase * Math.PI) * 3;
                        break;
                }

                // Redraw current word with effect
                let xOffset = x - this.ctx.measureText(text).width / 2;
                words.forEach((word) => {
                    const wordText = word.text.toUpperCase();
                    const wordWidth = this.ctx.measureText(wordText + ' ').width;
                    if (word.index === currentWordIndex) {
                        this.ctx.strokeText(wordText, xOffset + this.ctx.measureText(wordText).width / 2, y - effectOffset);
                        this.ctx.fillText(wordText, xOffset + this.ctx.measureText(wordText).width / 2, y - effectOffset);
                    }
                    xOffset += wordWidth;
                });
            }
        }

        _renderHormoziStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.042 * this.captionSize);
            const fontFamily = `${this.captionFontFamily}, Arial, sans-serif`;
            this.ctx.font = `bold ${fontSize}px ${fontFamily}`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const x = this.width / 2;
            const padding = 8;

            // Calculate total width
            let totalWidth = 0;
            words.forEach((word, i) => {
                totalWidth += this.ctx.measureText(word.text).width;
                if (i < words.length - 1) totalWidth += this.ctx.measureText(' ').width;
            });

            // Draw each word
            let xOffset = x - totalWidth / 2;
            words.forEach((word, i) => {
                const wordWidth = this.ctx.measureText(word.text).width;
                const isHighlighted = word.index === currentWordIndex ||
                                     (word.index === currentWordIndex + 1 && words.length > 2);

                // Apply effect offset
                let effectY = y;
                if (isHighlighted && this.captionEffect !== 'none') {
                    switch (this.captionEffect) {
                        case 'bounce':
                            effectY = y - Math.sin((localTime * 4) % 1 * Math.PI) * 4;
                            break;
                        case 'pop':
                            effectY = y - 2;
                            break;
                    }
                }

                if (isHighlighted) {
                    // Use highlight color for box background
                    const boxX = xOffset - padding / 2;
                    const boxY = effectY - fontSize / 2 - padding / 2;
                    const boxW = wordWidth + padding;
                    const boxH = fontSize + padding;

                    // Draw box with custom highlight color
                    this.ctx.fillStyle = this.captionHighlightColor;
                    this.ctx.beginPath();
                    this.ctx.roundRect(boxX, boxY, boxW, boxH, 4);
                    this.ctx.fill();

                    // White text on colored background
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText(word.text, xOffset + wordWidth / 2, effectY);
                } else {
                    // Regular text with custom stroke
                    this.ctx.strokeStyle = this.captionStrokeColor;
                    this.ctx.lineWidth = this.captionStrokeWidth;
                    this.ctx.strokeText(word.text, xOffset + wordWidth / 2, y);
                    this.ctx.fillStyle = this.captionFillColor;
                    this.ctx.fillText(word.text, xOffset + wordWidth / 2, y);
                }

                xOffset += wordWidth + this.ctx.measureText(' ').width;
            });
        }

        _renderAliStyle(words, y, localTime) {
            const fontSize = Math.round(this.height * 0.04 * this.captionSize);
            const fontFamily = `${this.captionFontFamily}, Arial, sans-serif`;
            this.ctx.font = `bold ${fontSize}px ${fontFamily}`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text).join(' ');
            const x = this.width / 2;

            // Animated glow effect using highlight color
            const glowIntensity = 0.5 + 0.5 * Math.sin(localTime * 3);
            const glowRadius = 10 + 10 * glowIntensity;

            // Draw glow layers with custom highlight color
            this.ctx.shadowColor = this._hexToRgba(this.captionHighlightColor, 0.8);
            this.ctx.shadowBlur = glowRadius;
            this.ctx.fillStyle = this.captionHighlightColor;

            // Multiple passes for stronger glow
            for (let i = 0; i < 3; i++) {
                this.ctx.fillText(text, x, y);
            }

            // Clear shadow for final crisp text
            this.ctx.shadowBlur = 0;
            this.ctx.fillText(text, x, y);
        }

        _renderPodcastStyle(words, y, localTime, currentWordIndex) {
            const fontSize = Math.round(this.height * 0.038 * this.captionSize);
            const fontFamily = `${this.captionFontFamily}, Arial, sans-serif`;
            this.ctx.font = `500 ${fontSize}px ${fontFamily}`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const x = this.width / 2;

            // Draw each word with fade effect
            let totalWidth = 0;
            words.forEach((word, i) => {
                totalWidth += this.ctx.measureText(word.text).width;
                if (i < words.length - 1) totalWidth += this.ctx.measureText(' ').width;
            });

            let xOffset = x - totalWidth / 2;
            words.forEach((word, i) => {
                const wordWidth = this.ctx.measureText(word.text).width;
                const isCurrent = word.index === currentWordIndex;

                // Fade animation: current word is full opacity, others fade
                let opacity;
                if (isCurrent) {
                    opacity = 1;
                } else if (word.index < currentWordIndex) {
                    opacity = 0.7;
                } else {
                    opacity = 0.4;
                }

                // Apply effect to current word
                let effectY = y;
                if (isCurrent && this.captionEffect === 'fade') {
                    const fadePhase = (localTime * 2) % 1;
                    opacity = 0.7 + 0.3 * Math.sin(fadePhase * Math.PI);
                }

                // Shadow with custom stroke color
                const strokeOpacity = opacity * 0.6;
                this.ctx.strokeStyle = this._hexToRgba(this.captionStrokeColor, strokeOpacity);
                this.ctx.lineWidth = this.captionStrokeWidth;
                this.ctx.strokeText(word.text, xOffset + wordWidth / 2, effectY);

                // Text with custom fill color, use highlight for current word
                if (isCurrent) {
                    this.ctx.fillStyle = this._hexToRgba(this.captionHighlightColor, opacity);
                } else {
                    this.ctx.fillStyle = this._hexToRgba(this.captionFillColor, opacity);
                }
                this.ctx.fillText(word.text, xOffset + wordWidth / 2, effectY);

                xOffset += wordWidth + this.ctx.measureText(' ').width;
            });
        }

        _renderMinimalStyle(words, y) {
            const fontSize = Math.round(this.height * 0.032 * this.captionSize);
            const fontFamily = `${this.captionFontFamily}, Arial, sans-serif`;
            this.ctx.font = `400 ${fontSize}px ${fontFamily}`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            const text = words.map(w => w.text.toLowerCase()).join(' ');
            const x = this.width / 2;

            // Subtle shadow with custom stroke color
            if (this.captionStrokeWidth > 0) {
                this.ctx.strokeStyle = this._hexToRgba(this.captionStrokeColor, 0.4);
                this.ctx.lineWidth = this.captionStrokeWidth;
                this.ctx.strokeText(text, x, y);
            }

            // Light text with custom fill color
            this.ctx.fillStyle = this._hexToRgba(this.captionFillColor, 0.85);
            this.ctx.fillText(text, x, y);
        }

        _renderDefaultStyle(words, y, localTime, currentWordIndex) {
            // Fallback to karaoke-like style
            this._renderKaraokeStyle(words, y, localTime, currentWordIndex);
        }

        _wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            for (const word of words) {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                const metrics = this.ctx.measureText(testLine);

                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }

            if (currentLine) {
                lines.push(currentLine);
            }

            return lines;
        }

        setVoiceVolume(volume) {
            this.voiceVolume = Math.max(0, Math.min(1, volume));
            this.audioElements.forEach(audio => {
                audio.volume = this.voiceVolume;
            });
        }

        setMusicVolume(volume) {
            this.musicVolume = Math.max(0, Math.min(1, volume));
            if (this.musicElement) {
                this.musicElement.volume = this.musicVolume;
            }
        }

        setCaptionsEnabled(enabled) {
            this.captionsEnabled = enabled;
            this._renderFrame();
        }

        setCaptionStyle(style) {
            this.captionStyle = style;
            this._renderFrame();
        }

        setCaptionPosition(position) {
            this.captionPosition = position;
            this._renderFrame();
        }

        setCaptionSize(size) {
            this.captionSize = Math.max(0.5, Math.min(2, parseFloat(size) || 1));
            this._renderFrame();
        }

        // Enhanced caption setters (Phase 2)
        setCaptionMode(mode) {
            this.captionMode = mode; // 'word' or 'sentence'
            this._renderFrame();
        }

        setCaptionFontFamily(font) {
            this.captionFontFamily = font;
            this._renderFrame();
        }

        setCaptionFillColor(color) {
            this.captionFillColor = color;
            this._renderFrame();
        }

        setCaptionStrokeColor(color) {
            this.captionStrokeColor = color;
            this._renderFrame();
        }

        setCaptionStrokeWidth(width) {
            this.captionStrokeWidth = Math.max(0, Math.min(8, parseFloat(width) || 2));
            this._renderFrame();
        }

        setCaptionEffect(effect) {
            this.captionEffect = effect;
            this._renderFrame();
        }

        setCaptionHighlightColor(color) {
            this.captionHighlightColor = color;
            this._renderFrame();
        }

        /**
         * Reattach to a new canvas element (used after DOM re-render)
         */
        attachToCanvas(canvas) {
            if (!canvas) return false;

            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            canvas.width = this.width;
            canvas.height = this.height;

            // Render current frame to new canvas immediately
            this._renderFrame();
            return true;
        }

        getState() {
            return {
                currentTime: this.currentTime,
                totalDuration: this.totalDuration,
                isPlaying: this.isPlaying,
                currentSceneIndex: this.currentSceneIndex,
                progress: this.totalDuration > 0 ? this.currentTime / this.totalDuration : 0
            };
        }

        updateScene(sceneId, updates) {
            const scene = this.scenes.find(s => s.id === sceneId);
            if (scene) {
                Object.assign(scene, updates);
                this._calculateTiming();
                this._renderFrame();
            }
        }

        reorderScenes(fromIndex, toIndex) {
            const [scene] = this.scenes.splice(fromIndex, 1);
            this.scenes.splice(toIndex, 0, scene);

            this.scenes.forEach((s, i) => s.index = i);

            this._calculateTiming();
            this._renderFrame();
        }

        // Export video using MediaRecorder (client-side rendering)
        async exportToVideo(onProgress = () => {}) {
            return new Promise(async (resolve, reject) => {
                try {
                    // Pause any current playback
                    this.pause();
                    this.seek(0);

                    // Wait a bit for seek to complete
                    await new Promise(r => setTimeout(r, 100));

                    // Get canvas stream
                    const canvasStream = this.canvas.captureStream(30); // 30 FPS

                    // Create audio context for mixing audio
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const destination = audioContext.createMediaStreamDestination();

                    // Load and connect all audio sources
                    const audioPromises = [];
                    for (const scene of this.scenes) {
                        if (scene.voiceoverUrl) {
                            audioPromises.push(
                                fetch(scene.voiceoverUrl)
                                    .then(r => r.arrayBuffer())
                                    .then(buffer => audioContext.decodeAudioData(buffer))
                                    .then(audioBuffer => ({
                                        buffer: audioBuffer,
                                        startTime: scene.startTime,
                                        sceneId: scene.id
                                    }))
                                    .catch(err => {
                                        console.warn('Failed to load audio for scene:', scene.id, err);
                                        return null;
                                    })
                            );
                        }
                    }

                    const audioBuffers = (await Promise.all(audioPromises)).filter(Boolean);

                    // Combine video and audio streams
                    const combinedStream = new MediaStream([
                        ...canvasStream.getVideoTracks(),
                        ...destination.stream.getAudioTracks()
                    ]);

                    // Setup MediaRecorder
                    const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')
                        ? 'video/webm;codecs=vp9,opus'
                        : MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')
                            ? 'video/webm;codecs=vp8,opus'
                            : 'video/webm';

                    const recorder = new MediaRecorder(combinedStream, {
                        mimeType,
                        videoBitsPerSecond: 5000000 // 5 Mbps
                    });

                    const chunks = [];
                    recorder.ondataavailable = (e) => {
                        if (e.data.size > 0) chunks.push(e.data);
                    };

                    recorder.onstop = () => {
                        audioContext.close();
                        const blob = new Blob(chunks, { type: mimeType });
                        resolve(blob);
                    };

                    recorder.onerror = (e) => {
                        audioContext.close();
                        reject(new Error('Recording failed: ' + e.error));
                    };

                    // Schedule all audio to play at correct times
                    const scheduledSources = [];
                    for (const audio of audioBuffers) {
                        const source = audioContext.createBufferSource();
                        source.buffer = audio.buffer;
                        source.connect(destination);
                        scheduledSources.push({ source, startTime: audio.startTime });
                    }

                    // Start recording
                    recorder.start(100); // Collect data every 100ms

                    // Start audio context time reference
                    const audioStartTime = audioContext.currentTime;

                    // Schedule audio playback
                    for (const { source, startTime } of scheduledSources) {
                        source.start(audioStartTime + startTime);
                    }

                    // Play through the video
                    this.isPlaying = true;
                    this.currentTime = 0;
                    this.lastFrameTime = performance.now();

                    const exportRenderLoop = () => {
                        if (!this.isPlaying) return;

                        const now = performance.now();
                        const delta = (now - this.lastFrameTime) / 1000;
                        this.lastFrameTime = now;

                        this.currentTime += delta;

                        // Update progress
                        const progress = Math.min(this.currentTime / this.totalDuration, 1);
                        onProgress(Math.round(progress * 100));

                        // Render current frame
                        this._renderFrame();

                        if (this.currentTime >= this.totalDuration) {
                            // Export complete
                            this.isPlaying = false;
                            this.currentTime = this.totalDuration;

                            // Stop recording after a small delay to capture final frame
                            setTimeout(() => {
                                recorder.stop();
                                // Stop all audio sources
                                for (const { source } of scheduledSources) {
                                    try { source.stop(); } catch(e) {}
                                }
                            }, 200);
                        } else {
                            requestAnimationFrame(exportRenderLoop);
                        }
                    };

                    requestAnimationFrame(exportRenderLoop);

                } catch (error) {
                    reject(error);
                }
            });
        }

        destroy() {
            this.pause();

            this.audioElements.forEach(audio => {
                audio.pause();
                audio.src = '';
            });
            this.audioElements.clear();

            if (this.musicElement) {
                this.musicElement.pause();
                this.musicElement.src = '';
                this.musicElement = null;
            }

            this.videoCache.forEach(video => {
                video.pause();
                video.src = '';
            });
            this.videoCache.clear();

            this.imageCache.clear();

            this.ctx.clearRect(0, 0, this.width, this.height);
        }
    }
    </script>

    <!-- ============================================
         SECTION 2: STYLES
         ============================================ -->
    <style>
        /* ------------------------------------------
           2.1 BASE & RESET
           ------------------------------------------ */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }

        body {
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 1rem;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            color: white;
        }

        #app-root {
            width: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
        }

        /* ------------------------------------------
           2.2 ANIMATIONS
           ------------------------------------------ */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes gradientFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.3); }
            50% { box-shadow: 0 0 40px rgba(139, 92, 246, 0.6); }
        }

        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }

        .animate-pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        .animate-float {
            animation: float 3s ease-in-out infinite;
        }

        .animate-glow {
            animation: glow 2s ease-in-out infinite;
        }

        .scale-in {
            animation: scaleIn 0.3s ease-out forwards;
        }

        /* ------------------------------------------
           2.3 WIZARD LAYOUT
           ------------------------------------------ */
        .wizard-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            min-height: 100vh;
        }

        .wizard-header {
            text-align: center;
            padding: 1.5rem 1rem;
            margin-bottom: 1rem;
        }

        .wizard-title {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 50%, #10b981 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .wizard-subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
        }

        /* ------------------------------------------
           2.4 STEPPER
           ------------------------------------------ */
        .wizard-stepper {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.25rem;
            padding: 1rem 0.5rem;
            margin-bottom: 2rem;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .wizard-stepper::-webkit-scrollbar {
            display: none;
        }

        .wizard-step {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.6rem 1rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .wizard-step:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .wizard-step.active {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(6, 182, 212, 0.2) 100%);
            border-color: rgba(139, 92, 246, 0.5);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
        }

        .wizard-step.completed {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .wizard-step.completed .step-number {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .step-number {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            flex-shrink: 0;
        }

        .wizard-step.active .step-number {
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
        }

        .step-label {
            font-size: 0.8rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
        }

        .wizard-step.active .step-label {
            color: white;
        }

        /* Step connector line */
        .step-connector {
            width: 20px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .step-connector.completed {
            background: rgba(16, 185, 129, 0.5);
        }

        /* ------------------------------------------
           2.5 CONTENT CARDS
           ------------------------------------------ */
        .content-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 1.5rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .content-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .content-card-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(6, 182, 212, 0.2) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .content-card-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: white;
        }

        .content-card-subtitle {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.6 PLATFORM CARDS
           ------------------------------------------ */
        .platform-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 1rem;
        }

        .platform-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .platform-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .platform-card.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.2);
        }

        .platform-card-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
        }

        .platform-card-name {
            font-size: 1rem;
            font-weight: 600;
            color: white;
            margin-bottom: 0.25rem;
        }

        .platform-card-info {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.7 FORMAT SELECTOR
           ------------------------------------------ */
        .format-selector {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .format-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .format-option:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .format-option.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
        }

        .format-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .format-preview {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .format-preview-box {
            background: rgba(139, 92, 246, 0.3);
            border: 2px solid rgba(139, 92, 246, 0.6);
            border-radius: 4px;
        }

        .format-preview-box.ratio-16-9 {
            width: 64px;
            height: 36px;
        }

        .format-preview-box.ratio-9-16 {
            width: 36px;
            height: 64px;
        }

        .format-preview-box.ratio-1-1 {
            width: 48px;
            height: 48px;
        }

        .format-preview-box.ratio-4-5 {
            width: 40px;
            height: 50px;
        }

        .format-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
        }

        .format-desc {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.8 DURATION SLIDER
           ------------------------------------------ */
        .duration-container {
            margin-top: 1.5rem;
        }

        .duration-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .duration-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        .duration-value {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .duration-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
            transition: transform 0.2s ease;
        }

        .duration-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .duration-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
        }

        .duration-presets {
            display: flex;
            justify-content: space-between;
            margin-top: 0.75rem;
        }

        .duration-preset {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .duration-preset:hover {
            color: rgba(255, 255, 255, 0.8);
        }

        /* ------------------------------------------
           2.9 NICHE GRID
           ------------------------------------------ */
        .niche-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.75rem;
        }

        .niche-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .niche-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .niche-card.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
        }

        .niche-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .niche-name {
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
        }

        /* Sub-niche chips */
        .subniche-container {
            margin-top: 1.5rem;
        }

        .subniche-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .subniche-chip {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .subniche-chip:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .subniche-chip.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3) 0%, rgba(6, 182, 212, 0.3) 100%);
            border-color: rgba(139, 92, 246, 0.5);
            color: white;
        }

        /* ------------------------------------------
           2.10 STYLE GRID
           ------------------------------------------ */
        .style-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }

        .style-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1.25rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .style-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .style-card.selected {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(6, 182, 212, 0.15) 100%);
            border-color: rgba(139, 92, 246, 0.6);
        }

        .style-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .style-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            margin-bottom: 0.25rem;
        }

        .style-desc {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.3;
        }

        /* ------------------------------------------
           2.11 TOPIC INPUT
           ------------------------------------------ */
        .topic-input-container {
            margin-top: 1.5rem;
        }

        .topic-input {
            width: 100%;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            color: white;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .topic-input:focus {
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(255, 255, 255, 0.08);
        }

        .topic-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .topic-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .topic-suggestion {
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .topic-suggestion:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
            color: white;
        }

        /* ------------------------------------------
           2.12 CONFIG TAGS
           ------------------------------------------ */
        .config-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.35rem 0.65rem;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 0.5rem;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        /* ------------------------------------------
           2.13 NAVIGATION BUTTONS
           ------------------------------------------ */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        .nav-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            border-radius: 1rem;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .nav-button-back {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }

        .nav-button-back:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .nav-button-next {
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }

        .nav-button-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
        }

        .nav-button-next:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ------------------------------------------
           2.13 TOKEN DISPLAY
           ------------------------------------------ */
        .token-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2rem;
            font-size: 0.85rem;
        }

        .token-icon {
            font-size: 1rem;
        }

        .token-count {
            font-weight: 700;
            background: linear-gradient(135deg, #f59e0b 0%, #eab308 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* ------------------------------------------
           2.14 HEADER BAR
           ------------------------------------------ */
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .back-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: rgba(255, 255, 255, 0.6);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: white;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* ------------------------------------------
           2.15 LOADING STATE
           ------------------------------------------ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 15, 26, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(139, 92, 246, 0.2);
            border-top-color: #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            margin-top: 1.5rem;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }

        /* ------------------------------------------
           2.16 COST ESTIMATE PANEL
           ------------------------------------------ */
        .cost-estimate {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 1rem;
            padding: 1rem 1.25rem;
            margin-top: 1.5rem;
        }

        .cost-estimate-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .cost-estimate-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        .cost-estimate-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: #8b5cf6;
        }

        .cost-estimate-breakdown {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* ------------------------------------------
           2.17 RESPONSIVE ADJUSTMENTS
           ------------------------------------------ */
        @media (max-width: 768px) {
            .wizard-container {
                padding: 0.5rem;
            }

            .wizard-title {
                font-size: 1.5rem;
            }

            .wizard-stepper {
                justify-content: flex-start;
                padding: 0.75rem;
            }

            .wizard-step {
                padding: 0.5rem 0.75rem;
            }

            .step-label {
                display: none;
            }

            .content-card {
                padding: 1.25rem;
            }

            .platform-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .niche-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .style-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .format-selector {
                flex-direction: column;
                align-items: center;
            }

            .nav-buttons {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-button {
                width: 100%;
                justify-content: center;
            }
        }

        /* NOTE: Caption styles are now rendered directly on canvas by VideoPreviewEngine
           See _renderKaraokeStyle, _renderBeastyStyle, _renderHormoziStyle, etc.
           This provides synchronized word-by-word captions matching the export ASS styles */
    </style>
</head>
<body>
    <!-- ============================================
         SECTION 3: HTML CONTAINER
         ============================================ -->
    <div id="app-root">
        <!-- Content rendered by JavaScript -->
        <div class="loading-overlay" id="initial-loading">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Authenticating...</div>
        </div>
    </div>

    <!-- ============================================
         SECTION 4: CONFIGURATION DATA
         ============================================ -->
    <script>
        // ==========================================
        // 4.1 PLATFORM PRESETS
        // ==========================================
        const PLATFORM_PRESETS = {
            'youtube-long': {
                id: 'youtube-long',
                name: 'YouTube Long-form',
                icon: '',
                formats: ['16:9'],
                defaultFormat: '16:9',
                resolution: { width: 1920, height: 1080 },
                maxDuration: 300,
                minDuration: 60,
                fps: 30,
                bitrate: '8M',
                description: 'Standard videos up to 5 min'
            },
            'youtube-shorts': {
                id: 'youtube-shorts',
                name: 'YouTube Shorts',
                icon: '',
                formats: ['9:16'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 60,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Vertical shorts up to 60s'
            },
            'tiktok': {
                id: 'tiktok',
                name: 'TikTok',
                icon: '',
                formats: ['9:16', '16:9', '1:1'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 180,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Viral content up to 3 min'
            },
            'instagram-reels': {
                id: 'instagram-reels',
                name: 'Instagram Reels',
                icon: '',
                formats: ['9:16'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 180,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Reels up to 3 min'
            },
            'instagram-feed': {
                id: 'instagram-feed',
                name: 'Instagram Feed',
                icon: '',
                formats: ['1:1', '4:5', '16:9'],
                defaultFormat: '1:1',
                resolution: { width: 1080, height: 1080 },
                maxDuration: 60,
                minDuration: 3,
                fps: 30,
                bitrate: '4M',
                description: 'Feed videos up to 60s'
            },
            'facebook-reels': {
                id: 'facebook-reels',
                name: 'Facebook Reels',
                icon: '',
                formats: ['9:16'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 90,
                minDuration: 3,
                fps: 30,
                bitrate: '4M',
                description: 'Reels up to 90s'
            },
            'facebook-feed': {
                id: 'facebook-feed',
                name: 'Facebook Feed',
                icon: '',
                formats: ['16:9', '1:1', '9:16'],
                defaultFormat: '16:9',
                resolution: { width: 1920, height: 1080 },
                maxDuration: 300,
                minDuration: 3,
                fps: 30,
                bitrate: '6M',
                description: 'Feed videos up to 5 min'
            },
            'linkedin': {
                id: 'linkedin',
                name: 'LinkedIn',
                icon: '',
                formats: ['16:9', '1:1', '4:5'],
                defaultFormat: '4:5',
                resolution: { width: 1080, height: 1350 },
                maxDuration: 300,
                minDuration: 3,
                fps: 30,
                bitrate: '5M',
                description: 'Professional videos up to 5 min'
            },
            'multi-platform': {
                id: 'multi-platform',
                name: 'Multi-Platform',
                icon: '',
                formats: ['9:16', '16:9', '1:1'],
                defaultFormat: '9:16',
                resolution: { width: 1080, height: 1920 },
                maxDuration: 60,
                minDuration: 15,
                fps: 30,
                bitrate: '4M',
                description: 'Optimized for all platforms'
            }
        };

        // ==========================================
        // 4.2 VIDEO NICHES
        // ==========================================
        const VIDEO_NICHES = {
            entertainment: {
                id: 'entertainment',
                name: 'Entertainment',
                icon: '',
                subniches: [
                    { id: 'comedy', name: 'Comedy & Humor' },
                    { id: 'stories', name: 'Story Time' },
                    { id: 'reactions', name: 'Reactions' },
                    { id: 'celebrity', name: 'Pop Culture' },
                    { id: 'true-crime', name: 'True Crime' }
                ]
            },
            education: {
                id: 'education',
                name: 'Education',
                icon: '',
                subniches: [
                    { id: 'explainer', name: 'Explainer Videos' },
                    { id: 'tutorials', name: 'Tutorials' },
                    { id: 'science', name: 'Science & Tech' },
                    { id: 'history', name: 'History' },
                    { id: 'language', name: 'Language Learning' }
                ]
            },
            business: {
                id: 'business',
                name: 'Business',
                icon: '',
                subniches: [
                    { id: 'investing', name: 'Investing' },
                    { id: 'entrepreneurship', name: 'Entrepreneurship' },
                    { id: 'productivity', name: 'Productivity' },
                    { id: 'career', name: 'Career Tips' },
                    { id: 'money-tips', name: 'Money Tips' }
                ]
            },
            health: {
                id: 'health',
                name: 'Health',
                icon: '',
                subniches: [
                    { id: 'fitness', name: 'Fitness' },
                    { id: 'nutrition', name: 'Nutrition' },
                    { id: 'mental-health', name: 'Mental Health' },
                    { id: 'meditation', name: 'Meditation' },
                    { id: 'self-improvement', name: 'Self Improvement' }
                ]
            },
            technology: {
                id: 'technology',
                name: 'Technology',
                icon: '',
                subniches: [
                    { id: 'tech-reviews', name: 'Tech Reviews' },
                    { id: 'ai-tech', name: 'AI & Future Tech' },
                    { id: 'coding', name: 'Coding' },
                    { id: 'gadgets', name: 'Gadgets' },
                    { id: 'gaming-tech', name: 'Gaming' }
                ]
            },
            creative: {
                id: 'creative',
                name: 'Creative',
                icon: '',
                subniches: [
                    { id: 'art-tutorials', name: 'Art Tutorials' },
                    { id: 'music', name: 'Music' },
                    { id: 'photography', name: 'Photography' },
                    { id: 'diy-crafts', name: 'DIY & Crafts' },
                    { id: 'animation', name: 'Animation' }
                ]
            },
            travel: {
                id: 'travel',
                name: 'Travel',
                icon: '',
                subniches: [
                    { id: 'travel-guides', name: 'Travel Guides' },
                    { id: 'food-travel', name: 'Food & Cuisine' },
                    { id: 'luxury', name: 'Luxury' },
                    { id: 'minimalism', name: 'Minimalism' },
                    { id: 'adventure', name: 'Adventure' }
                ]
            },
            motivation: {
                id: 'motivation',
                name: 'Motivation',
                icon: '',
                subniches: [
                    { id: 'motivational', name: 'Speeches' },
                    { id: 'quotes', name: 'Quotes' },
                    { id: 'success-stories', name: 'Success Stories' },
                    { id: 'life-lessons', name: 'Life Lessons' },
                    { id: 'spirituality', name: 'Spirituality' }
                ]
            },
            news: {
                id: 'news',
                name: 'News',
                icon: '',
                subniches: [
                    { id: 'world-news', name: 'World News' },
                    { id: 'politics', name: 'Politics' },
                    { id: 'sports', name: 'Sports' },
                    { id: 'social-commentary', name: 'Commentary' }
                ]
            }
        };

        // ==========================================
        // 4.3 VIDEO STYLES
        // ==========================================
        const VIDEO_STYLES = {
            modern: {
                id: 'modern',
                name: 'Modern Minimalist',
                icon: '',
                description: 'Clean, sleek aesthetics',
                imagePromptModifiers: 'minimalist, clean design, modern aesthetic, solid colors, geometric shapes',
                transitionStyle: 'smooth-fade',
                pacing: 'medium'
            },
            cinematic: {
                id: 'cinematic',
                name: 'Cinematic',
                icon: '',
                description: 'Movie-quality visuals',
                imagePromptModifiers: 'cinematic lighting, dramatic, film quality, depth of field, professional photography',
                transitionStyle: 'cinematic-fade',
                pacing: 'slow'
            },
            energetic: {
                id: 'energetic',
                name: 'Energetic',
                icon: '',
                description: 'Fast-paced, bold colors',
                imagePromptModifiers: 'vibrant colors, dynamic composition, energetic, bold, eye-catching',
                transitionStyle: 'quick-cuts',
                pacing: 'fast'
            },
            documentary: {
                id: 'documentary',
                name: 'Documentary',
                icon: '',
                description: 'Authentic, raw style',
                imagePromptModifiers: 'documentary style, realistic, photojournalistic, authentic, raw',
                transitionStyle: 'simple-cut',
                pacing: 'medium'
            },
            retro: {
                id: 'retro',
                name: 'Retro/Vintage',
                icon: '',
                description: 'Nostalgic film grain',
                imagePromptModifiers: 'vintage aesthetic, retro style, film grain, warm tones, nostalgic',
                transitionStyle: 'vhs-glitch',
                pacing: 'medium'
            },
            futuristic: {
                id: 'futuristic',
                name: 'Futuristic',
                icon: '',
                description: 'High-tech, neon aesthetic',
                imagePromptModifiers: 'futuristic, sci-fi, neon lights, cyber, holographic, high-tech',
                transitionStyle: 'digital-glitch',
                pacing: 'medium-fast'
            },
            cartoon: {
                id: 'cartoon',
                name: 'Animated',
                icon: '',
                description: 'Illustrated, playful',
                imagePromptModifiers: 'cartoon style, illustrated, colorful, playful, digital art, animation style',
                transitionStyle: 'bounce',
                pacing: 'medium'
            },
            elegant: {
                id: 'elegant',
                name: 'Elegant & Luxury',
                icon: '',
                description: 'Sophisticated, premium',
                imagePromptModifiers: 'luxury, elegant, sophisticated, premium quality, gold accents, refined',
                transitionStyle: 'smooth-elegant',
                pacing: 'slow'
            },
            nature: {
                id: 'nature',
                name: 'Nature & Organic',
                icon: '',
                description: 'Natural, calming',
                imagePromptModifiers: 'natural, organic, earthy tones, peaceful, nature photography, serene',
                transitionStyle: 'soft-dissolve',
                pacing: 'slow'
            },
            dark: {
                id: 'dark',
                name: 'Dark & Moody',
                icon: '',
                description: 'Dramatic, mysterious',
                imagePromptModifiers: 'dark mood, dramatic shadows, mysterious, noir style, moody lighting',
                transitionStyle: 'fade-dark',
                pacing: 'medium'
            }
        };

        // ==========================================
        // 4.4 FORMAT DISPLAY INFO
        // ==========================================
        const FORMAT_INFO = {
            '16:9': { name: 'Landscape', ratio: '16:9', className: 'ratio-16-9', desc: 'Wide screen' },
            '9:16': { name: 'Portrait', ratio: '9:16', className: 'ratio-9-16', desc: 'Vertical' },
            '1:1': { name: 'Square', ratio: '1:1', className: 'ratio-1-1', desc: 'Square' },
            '4:5': { name: 'Portrait', ratio: '4:5', className: 'ratio-4-5', desc: 'Tall' }
        };

        // ==========================================
        // 4.5 WIZARD STEPS
        // ==========================================
        const WIZARD_STEPS = [
            { num: 1, label: 'Platform', icon: '' },
            { num: 2, label: 'Niche & Style', icon: '' },
            { num: 3, label: 'Script', icon: '' },
            { num: 4, label: 'Storyboard', icon: '' },
            { num: 5, label: 'Animation', icon: '' },
            { num: 6, label: 'Assembly', icon: '' },
            { num: 7, label: 'Export', icon: '' }
        ];

        // ==========================================
        // 4.6 TOPIC SUGGESTIONS BY NICHE
        // ==========================================
        const TOPIC_SUGGESTIONS = {
            entertainment: ['Top 10 plot twists', 'Hidden movie details', 'Celebrity facts you didn\'t know'],
            education: ['How X really works', '5 things school didn\'t teach you', 'The science behind Y'],
            business: ['Money habits of millionaires', 'Side hustle ideas', 'Investing mistakes to avoid'],
            health: ['Morning routine hacks', 'Foods that boost energy', 'Quick workout tips'],
            technology: ['AI tools you need', 'Tech predictions for 2025', 'Hidden phone features'],
            creative: ['Art techniques explained', 'Music production tips', 'Design trends'],
            travel: ['Hidden gem destinations', 'Travel hacks', 'Best street food cities'],
            motivation: ['Success mindset', 'Overcoming failure', 'Daily habits of winners'],
            news: ['Breaking down the headlines', 'What this means for you', 'Expert analysis']
        };
    </script>

    <!-- ============================================
         SECTION 5: STATE MANAGEMENT
         ============================================ -->
    <script>
        // ==========================================
        // 5.1 APPLICATION STATE
        // ==========================================
        const state = {
            // User & Auth
            user: null,
            isLoading: true,

            // Token system
            tokens: {
                balance: 0,
                plan: 'free'
            },

            // Current wizard step
            currentStep: 1,
            maxReachedStep: 1,

            // Project metadata
            project: {
                id: null,
                name: 'Untitled Video',
                createdAt: null,
                updatedAt: null
            },

            // Step 1: Platform & Format
            platform: {
                selected: null,           // Platform ID
                preset: null,             // Full preset object
                aspectRatio: null,        // Selected aspect ratio
                targetDuration: 60        // Target duration in seconds
            },

            // Step 2: Niche & Style
            content: {
                niche: null,              // Niche ID
                subniche: null,           // Sub-niche ID
                style: null,              // Style ID
                topic: '',                // User's topic/theme
                tone: 'engaging',         // casual, professional, humorous, serious
                pacing: 'medium',         // 'fast' | 'medium' | 'slow' - controls scene timing
                contentDepth: 'detailed'  // 'minimal' | 'standard' | 'detailed' | 'comprehensive' - content richness
            },

            // Step 3: Script
            script: {
                status: 'idle',
                title: '',
                hook: '',
                scenes: [],
                cta: '',
                totalDuration: 0,
                expandedScene: null,  // Track which scene is expanded in editor
                metadata: null,       // AI-generated metadata
                generatedAt: null,
                generationConfig: null
            },

            // Step 4: Storyboard
            storyboard: {
                status: 'idle', // idle, generating, ready, error
                scenes: [],     // Array of { sceneId, status, imageUrl, prompt, jobId, source }
                characterReference: null,
                styleReference: null,
                modifyingScene: null,  // Scene ID being modified in modal
                modifyPrompt: null,    // Current prompt in modify modal
                modifyStyle: null,     // Current style in modify modal
                // Image generation settings
                imageModel: 'hidream',  // 'hidream' | 'nanobanana-pro' | 'nanobanana'
                // Edit with AI state
                editingScene: null,     // Scene ID being edited
                editMaskCanvas: null,   // Canvas element for mask
                editMaskCtx: null,      // Canvas 2D context
                editBrushSize: 30,      // Brush size in pixels
                editPrompt: '',         // Edit instruction prompt
                editLoading: false,     // Is edit in progress
                editHistory: [],        // Mask history for undo
                editOriginalData: null  // Original image data for canvas
            },

            // Step 5: Animation (to be implemented)
            animation: {
                status: 'idle',
                scenes: [],
                voiceover: {
                    voice: 'default',
                    speed: 1.0,
                    status: 'idle'
                }
            },

            // Step 6: Assembly
            assembly: {
                status: 'idle',
                sceneOrder: [],
                transitions: {},
                music: { enabled: false, trackId: null, volume: 30 },
                // Enhanced caption settings
                captions: {
                    enabled: true,
                    style: 'karaoke',
                    position: 'bottom',
                    size: 1,
                    // New professional options
                    mode: 'word',              // 'word' or 'sentence'
                    fontFamily: 'Montserrat',
                    fontWeight: 600,
                    fillColor: '#FFFFFF',
                    strokeColor: '#000000',
                    strokeWidth: 2,
                    shadowEnabled: true,
                    effect: 'none',            // 'none', 'pop', 'fade', 'zoom', 'bounce'
                    highlightStyle: 'color',   // 'color', 'background', 'glow'
                    highlightColor: '#FBBF24'
                },
                audioMix: { voiceVolume: 100, musicVolume: 30 },
                musicLibrary: [],
                transitionTypes: [],
                captionStyles: [],
                // UI state for tabbed interface
                activeTab: 'text'              // 'text', 'audio', 'media', 'transitions'
            },

            // Preview Engine State
            preview: {
                isReady: false,
                isPlaying: false,
                currentTime: 0,
                totalDuration: 0,
                currentSceneIndex: 0,
                loadProgress: 0,
                volume: 100
            },

            // Step 7: Export
            export: {
                status: 'idle',
                jobId: null,
                progress: 0,
                currentStage: null,
                outputUrl: null,
                error: null,
                selectedQuality: '1080p',
                selectedRenderQuality: 'balanced'  // fast, balanced, or best
            },

            // Timeline Editor State
            timeline: {
                zoom: 50, // pixels per second
                scrollLeft: 0,
                selectedClipId: null,
                selectedTrack: null,
                snapToGrid: true,
                showWaveforms: true,
                waveformCache: {}, // sceneId -> waveform data
                isInitialized: false
            }
        };

        // ==========================================
        // 5.2 STATE HELPERS
        // ==========================================
        function updateState(path, value) {
            const keys = path.split('.');
            let current = state;
            for (let i = 0; i < keys.length - 1; i++) {
                current = current[keys[i]];
            }
            current[keys[keys.length - 1]] = value;
        }

        function getState(path) {
            const keys = path.split('.');
            let current = state;
            for (const key of keys) {
                current = current[key];
            }
            return current;
        }
    </script>

    <!-- ============================================
         SECTION 6: CORE FUNCTIONS
         ============================================ -->
    <script>
        // ==========================================
        // 6.1 FIREBASE INITIALIZATION
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyAGczY5ZEIJdTq25BpQdia3lv2I556wOZo",
            authDomain: "ytseo-6d1b0.firebaseapp.com",
            projectId: "ytseo-6d1b0",
            storageBucket: "ytseo-6d1b0.firebasestorage.app",
            messagingSenderId: "363779069774",
            appId: "1:363779069774:web:1c9eb0be0abf8d5c2a7f66"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const functions = firebase.functions();
        const storage = firebase.storage();

        // ==========================================
        // 6.2 AUTHENTICATION
        // ==========================================
        let authResolved = false;
        let authTimeoutId = null;

        async function initAuth() {
            return new Promise((resolve, reject) => {
                // Set up a maximum wait time for auth (2.5 seconds)
                // This handles the race condition where Firebase takes time to restore auth state
                authTimeoutId = setTimeout(() => {
                    if (authResolved) return; // Already resolved

                    // Final check before redirecting
                    const currentUser = auth.currentUser;
                    if (currentUser) {
                        authResolved = true;
                        state.user = currentUser;
                        loadUserTokens().then(() => resolve(currentUser));
                    } else {
                        // Truly not authenticated after waiting - redirect to login
                        console.log('Auth timeout: No user found, redirecting to login');
                        window.location.href = '/video-optimizer';
                        reject('Not authenticated');
                    }
                }, 2500);

                // Listen for auth state changes
                const unsubscribe = auth.onAuthStateChanged(async (user) => {
                    // If already resolved, ignore subsequent calls
                    if (authResolved) return;

                    if (user) {
                        // User is authenticated - clear timeout and proceed
                        authResolved = true;
                        if (authTimeoutId) {
                            clearTimeout(authTimeoutId);
                            authTimeoutId = null;
                        }
                        state.user = user;
                        await loadUserTokens();
                        resolve(user);
                        return;
                    }

                    // User is null - this could be:
                    // 1. Initial call before Firebase loads auth from storage (wait for real state)
                    // 2. User is truly not authenticated
                    // The timeout above will handle the final decision
                    console.log('Auth state: waiting for Firebase to restore session...');
                });
            });
        }

        async function loadUserTokens() {
            try {
                const userDoc = await db.collection('users').doc(state.user.uid).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    state.tokens.balance = userData.creativeTokens || userData.tokens || 0;
                    state.tokens.plan = userData.plan || 'free';
                }
            } catch (error) {
                console.error('Error loading tokens:', error);
            }
        }

        // ==========================================
        // 6.3 PROJECT SAVE/LOAD
        // ==========================================
        let saveDebounceTimer = null;
        let isSaving = false;

        function scheduleAutoSave() {
            // Don't auto-save if no project ID yet (new project needs explicit save)
            if (!state.project.id) return;

            // Debounce to avoid too many saves
            if (saveDebounceTimer) {
                clearTimeout(saveDebounceTimer);
            }
            saveDebounceTimer = setTimeout(() => {
                saveProject(true); // true = silent save
            }, 2000);
        }

        async function saveProject(silent = false) {
            if (isSaving) return;
            isSaving = true;

            try {
                const saveProjectFn = functions.httpsCallable('creationWizardSaveProject');

                const projectData = {
                    name: state.project.name || generateProjectName(),
                    status: state.project.status,
                    platform: state.platform,
                    content: state.content,
                    script: state.script,
                    storyboard: state.storyboard,
                    animation: state.animation,
                    assembly: state.assembly,
                    export: state.export
                };

                const result = await saveProjectFn({
                    projectId: state.project.id || null,
                    projectData
                });

                if (result.data.success) {
                    state.project.id = result.data.projectId;
                    state.project.updatedAt = new Date().toISOString();

                    // Update URL with project ID
                    if (window.history.replaceState) {
                        const url = new URL(window.location);
                        url.searchParams.set('project', state.project.id);
                        window.history.replaceState({}, '', url);
                    }

                    if (!silent) {
                        showToast('Project saved', 'success');
                    }
                }
            } catch (error) {
                console.error('Save project error:', error);
                if (!silent) {
                    showToast('Failed to save project', 'error');
                }
            } finally {
                isSaving = false;
            }
        }

        async function loadProject(projectId) {
            state.isLoading = true;
            render();

            try {
                const loadProjectFn = functions.httpsCallable('creationWizardLoadProject');
                const result = await loadProjectFn({ projectId });

                if (result.data.success) {
                    const project = result.data.project;

                    // Restore state from project
                    state.project.id = project.id;
                    state.project.name = project.name;
                    state.project.status = project.status;
                    state.project.createdAt = project.createdAt;
                    state.project.updatedAt = project.updatedAt;

                    // Restore platform config
                    if (project.platform) {
                        state.platform = { ...state.platform, ...project.platform };
                        // Restore preset if platform was selected
                        if (project.platform.selected && PLATFORM_PRESETS[project.platform.selected]) {
                            state.platform.preset = PLATFORM_PRESETS[project.platform.selected];
                        }
                    }

                    // Restore content config
                    if (project.content) {
                        state.content = { ...state.content, ...project.content };
                    }

                    // Restore script data
                    if (project.script) {
                        state.script = { ...state.script, ...project.script };
                    }

                    // Restore storyboard data
                    if (project.storyboard) {
                        state.storyboard = { ...state.storyboard, ...project.storyboard };
                    }

                    // Restore animation data
                    if (project.animation) {
                        state.animation = { ...state.animation, ...project.animation };
                    }

                    // Restore assembly data
                    if (project.assembly) {
                        state.assembly = { ...state.assembly, ...project.assembly };
                    }

                    // Restore export data
                    if (project.export) {
                        state.export = { ...state.export, ...project.export };
                    }

                    // Calculate max reached step based on completed data
                    state.maxReachedStep = calculateMaxReachedStep();

                    showToast('Project loaded', 'success');
                }
            } catch (error) {
                console.error('Load project error:', error);
                showToast('Failed to load project', 'error');
            } finally {
                state.isLoading = false;
                render();
            }
        }

        async function loadProjectsList() {
            try {
                const getProjectsFn = functions.httpsCallable('creationWizardGetProjects');
                const result = await getProjectsFn({ limit: 20 });

                if (result.data.success) {
                    return result.data.projects;
                }
                return [];
            } catch (error) {
                console.error('Load projects list error:', error);
                return [];
            }
        }

        async function deleteProject(projectId) {
            if (!confirm('Are you sure you want to delete this project?')) return;

            try {
                const deleteProjectFn = functions.httpsCallable('creationWizardDeleteProject');
                await deleteProjectFn({ projectId });
                showToast('Project deleted', 'success');

                // If we deleted the current project, start fresh
                if (state.project.id === projectId) {
                    window.location.href = '/video-creation-wizard';
                }
            } catch (error) {
                console.error('Delete project error:', error);
                showToast('Failed to delete project', 'error');
            }
        }

        function generateProjectName() {
            const niche = state.content.niche ? VIDEO_NICHES[state.content.niche]?.name : '';
            const topic = state.content.topic ? ` - ${state.content.topic.slice(0, 30)}` : '';
            const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            return `${niche || 'Video'} Project${topic} (${date})`;
        }

        function calculateMaxReachedStep() {
            if (state.export.status === 'complete') return 7;
            if (state.assembly.status === 'ready') return 7;
            if (state.animation.scenes.length > 0) return 6;
            if (state.storyboard.scenes.length > 0) return 5;
            if (state.script.scenes.length > 0) return 4;
            if (state.content.niche && state.content.style) return 3;
            if (state.platform.selected) return 2;
            return 1;
        }

        function checkUrlForProject() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('project');
            if (projectId) {
                return projectId;
            }
            return null;
        }

        // ==========================================
        // 6.4 NAVIGATION
        // ==========================================
        function goToStep(step) {
            // Validate step transition
            if (step < 1 || step > WIZARD_STEPS.length) return;
            if (step > state.maxReachedStep + 1) return;

            // Validate current step is complete before moving forward
            if (step > state.currentStep && !isStepComplete(state.currentStep)) {
                showToast('Please complete the current step first', 'warning');
                return;
            }

            // Cleanup preview engine when leaving Assembly step
            if (state.currentStep === 6 && step !== 6) {
                cleanupPreviewEngine();
            }

            state.currentStep = step;
            if (step > state.maxReachedStep) {
                state.maxReachedStep = step;
            }

            render();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function isStepComplete(step) {
            switch (step) {
                case 1:
                    return state.platform.selected && state.platform.aspectRatio;
                case 2:
                    return state.content.niche && state.content.style;
                case 3:
                    return state.script.scenes.length > 0;
                case 4:
                    return state.storyboard.scenes.length > 0;
                case 5:
                    return state.animation.scenes.length > 0;
                case 6:
                    return state.assembly.status === 'ready';
                default:
                    return true;
            }
        }

        // ==========================================
        // 6.4 PLATFORM SELECTION
        // ==========================================
        function selectPlatform(platformId) {
            const preset = PLATFORM_PRESETS[platformId];
            if (!preset) return;

            state.platform.selected = platformId;
            state.platform.preset = preset;
            state.platform.aspectRatio = preset.defaultFormat;
            state.platform.targetDuration = Math.min(
                preset.maxDuration,
                Math.max(preset.minDuration, state.platform.targetDuration)
            );

            render();
            scheduleAutoSave();
        }

        function selectFormat(format) {
            if (!state.platform.preset) return;
            if (!state.platform.preset.formats.includes(format)) return;

            state.platform.aspectRatio = format;

            // Update resolution based on format
            const resolutions = {
                '16:9': { width: 1920, height: 1080 },
                '9:16': { width: 1080, height: 1920 },
                '1:1': { width: 1080, height: 1080 },
                '4:5': { width: 1080, height: 1350 }
            };
            state.platform.preset.resolution = resolutions[format];

            render();
            scheduleAutoSave();
        }

        function setDuration(duration) {
            if (!state.platform.preset) return;
            const preset = state.platform.preset;
            state.platform.targetDuration = Math.min(
                preset.maxDuration,
                Math.max(preset.minDuration, parseInt(duration))
            );
            render();
            scheduleAutoSave();
        }

        // ==========================================
        // 6.6 NICHE & STYLE SELECTION
        // ==========================================
        function selectNiche(nicheId) {
            state.content.niche = nicheId;
            state.content.subniche = null; // Reset subniche
            render();
            scheduleAutoSave();
        }

        function selectSubniche(subnicheId) {
            state.content.subniche = subnicheId;
            render();
            scheduleAutoSave();
        }

        function selectStyle(styleId) {
            state.content.style = styleId;
            render();
            scheduleAutoSave();
        }

        function setTopic(topic) {
            state.content.topic = topic;
            scheduleAutoSave();
        }

        function setPacing(pacing) {
            state.content.pacing = pacing;
            render();
            scheduleAutoSave();
        }

        function applyTopicSuggestion(topic) {
            state.content.topic = topic;
            render();
            scheduleAutoSave();
        }

        // ==========================================
        // 6.7 SCRIPT GENERATION & EDITING
        // ==========================================
        function setScriptTone(tone) {
            state.content.tone = tone;
            render();
        }

        function setContentDepth(depth) {
            state.content.contentDepth = depth;
            render();
        }

        async function generateScript() {
            // Get topic from input
            const topicInput = document.getElementById('script-topic');
            const instructionsInput = document.getElementById('script-instructions');

            const topic = topicInput?.value?.trim() || state.content.topic;
            const additionalInstructions = instructionsInput?.value?.trim() || '';

            if (!topic || topic.length < 3) {
                showToast('Please enter a topic for your video', 'warning');
                return;
            }

            // Update state
            state.content.topic = topic;
            state.script.status = 'generating';
            render();

            try {
                const generateScriptFn = functions.httpsCallable('creationWizardGenerateScript');

                const config = {
                    platform: state.platform.selected,
                    aspectRatio: state.platform.aspectRatio,
                    targetDuration: state.platform.targetDuration,
                    niche: state.content.niche,
                    subniche: state.content.subniche,
                    style: state.content.style,
                    topic: topic,
                    tone: state.content.tone || 'engaging',
                    pacing: state.content.pacing || 'medium',
                    contentDepth: state.content.contentDepth || 'detailed',
                    additionalInstructions
                };

                const result = await generateScriptFn({
                    projectId: state.project.id || null,
                    config
                });

                if (result.data.success) {
                    const script = result.data.script;

                    // Update state with generated script
                    state.script = {
                        ...state.script,
                        ...script,
                        status: 'generated',
                        expandedScene: null
                    };

                    // Update project ID if new project was created
                    if (result.data.projectId && !state.project.id) {
                        state.project.id = result.data.projectId;
                    }

                    showToast('Script generated successfully!', 'success');
                    scheduleAutoSave();
                } else {
                    throw new Error('Script generation failed');
                }
            } catch (error) {
                console.error('Script generation error:', error);
                state.script.status = 'idle';
                showToast('Failed to generate script. Please try again.', 'error');
            }

            render();
        }

        async function regenerateFullScript() {
            if (!confirm('This will replace your current script. Continue?')) return;

            state.script.status = 'idle';
            state.script.scenes = [];
            state.script.title = '';
            state.script.hook = '';
            state.script.cta = '';
            render();
        }

        function updateScriptTitle(title) {
            state.script.title = title;
            scheduleAutoSave();
        }

        function updateScriptHook(hook) {
            state.script.hook = hook;
            scheduleAutoSave();
        }

        function updateScriptCTA(cta) {
            state.script.cta = cta;
            scheduleAutoSave();
        }

        function toggleSceneExpand(sceneId) {
            if (state.script.expandedScene === sceneId) {
                state.script.expandedScene = null;
            } else {
                state.script.expandedScene = sceneId;
            }
            render();
        }

        function updateSceneNarration(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.narration = value;
                scheduleAutoSave();
            }
        }

        function updateSceneVisual(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.visual = value;
                scheduleAutoSave();
            }
        }

        function updateSceneDuration(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.duration = parseInt(value) || 8;
                // Recalculate total duration
                state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + s.duration, 0);
                scheduleAutoSave();
                render();
            }
        }

        function updateSceneTransition(sceneId, value) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.transition = value;
                scheduleAutoSave();
            }
        }

        async function regenerateScene(sceneId) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const instructions = prompt('Any specific instructions for regenerating this scene? (or leave empty)');

            try {
                showToast('Regenerating scene...', 'info');

                const regenerateSceneFn = functions.httpsCallable('creationWizardRegenerateScene');
                const result = await regenerateSceneFn({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    currentScript: state.script,
                    instructions: instructions || ''
                });

                if (result.data.success) {
                    // Update the scene in state
                    const index = state.script.scenes.findIndex(s => s.id === sceneId);
                    if (index !== -1) {
                        state.script.scenes[index] = {
                            ...state.script.scenes[index],
                            ...result.data.scene
                        };
                    }

                    showToast('Scene regenerated!', 'success');
                    scheduleAutoSave();
                    render();
                }
            } catch (error) {
                console.error('Regenerate scene error:', error);
                showToast('Failed to regenerate scene', 'error');
            }
        }

        function moveSceneUp(sceneId) {
            const index = state.script.scenes.findIndex(s => s.id === sceneId);
            if (index > 0) {
                const temp = state.script.scenes[index];
                state.script.scenes[index] = state.script.scenes[index - 1];
                state.script.scenes[index - 1] = temp;
                scheduleAutoSave();
                render();
            }
        }

        function moveSceneDown(sceneId) {
            const index = state.script.scenes.findIndex(s => s.id === sceneId);
            if (index < state.script.scenes.length - 1) {
                const temp = state.script.scenes[index];
                state.script.scenes[index] = state.script.scenes[index + 1];
                state.script.scenes[index + 1] = temp;
                scheduleAutoSave();
                render();
            }
        }

        function deleteScene(sceneId) {
            if (state.script.scenes.length <= 1) {
                showToast('You need at least one scene', 'warning');
                return;
            }

            if (!confirm('Delete this scene?')) return;

            state.script.scenes = state.script.scenes.filter(s => s.id !== sceneId);
            state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + s.duration, 0);
            scheduleAutoSave();
            render();
        }

        function addNewScene() {
            const maxId = Math.max(...state.script.scenes.map(s => s.id), 0);
            const newScene = {
                id: maxId + 1,
                narration: '',
                visual: '',
                duration: 10,
                transition: 'cut',
                status: 'pending'
            };

            state.script.scenes.push(newScene);
            state.script.expandedScene = newScene.id;
            state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + s.duration, 0);
            scheduleAutoSave();
            render();

            // Scroll to new scene
            setTimeout(() => {
                const sceneCards = document.querySelectorAll('.scene-card');
                if (sceneCards.length > 0) {
                    sceneCards[sceneCards.length - 1].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        // ==========================================
        // 6.8 STORYBOARD GENERATION
        // ==========================================
        let imagePollingIntervals = {};

        async function generateInitialStoryboard() {
            const scenes = state.script.scenes || [];
            if (scenes.length === 0) return;

            // Only generate FIRST scene automatically - others on demand
            const firstScene = scenes[0];

            state.storyboard.status = 'generating';

            // Initialize all storyboard scenes - first is generating, others pending
            state.storyboard.scenes = scenes.map((scene, index) => ({
                sceneId: scene.id,
                status: index === 0 ? 'generating' : 'pending',
                imageUrl: null,
                prompt: scene.visual || '',
                jobId: null,
                source: 'ai' // 'ai' | 'stock' | 'upload'
            }));

            render();

            // Generate only first scene
            try {
                await generateSingleSceneImage(firstScene.id);
                state.storyboard.status = 'partial';
                render();
            } catch (error) {
                console.error('Initial storyboard generation error:', error);
                showToast('Failed to generate first image. Click to retry.', 'error');
                state.storyboard.status = 'error';
                render();
            }
        }

        // Model configuration with token costs
        const IMAGE_MODELS = {
            'hidream': {
                name: 'HiDream',
                description: 'Artistic & cinematic style',
                tokenCost: 2,
                cloudFunction: 'creationWizardGenerateSceneImage'
            },
            'nanobanana-pro': {
                name: 'NanoBanana Pro',
                description: 'High quality, fast generation',
                tokenCost: 3,
                cloudFunction: 'generateCreativeImage'
            },
            'nanobanana': {
                name: 'NanoBanana',
                description: 'Quick drafts, lower cost',
                tokenCost: 1,
                cloudFunction: 'generateCreativeImage'
            }
        };

        // Get current model configuration
        function getCurrentModelConfig() {
            return IMAGE_MODELS[state.storyboard.imageModel] || IMAGE_MODELS['hidream'];
        }

        // Set image generation model
        function setImageModel(modelId) {
            if (IMAGE_MODELS[modelId]) {
                state.storyboard.imageModel = modelId;
                render();
            }
        }

        async function generateSingleSceneImage(sceneId, customModel = null) {
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const modelId = customModel || state.storyboard.imageModel || 'hidream';
            const modelConfig = IMAGE_MODELS[modelId] || IMAGE_MODELS['hidream'];

            // Find or create storyboard entry
            let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene) {
                storyboardScene = {
                    sceneId: sceneId,
                    status: 'pending',
                    imageUrl: null,
                    prompt: scene.visual || '',
                    jobId: null,
                    source: 'ai',
                    model: modelId
                };
                state.storyboard.scenes.push(storyboardScene);
            }

            storyboardScene.status = 'generating';
            storyboardScene.model = modelId;
            storyboardScene.error = null;
            render();

            const prompt = scene.visual || scene.narration || 'A cinematic scene';

            try {
                // Check if using HiDream (RunPod) or NanoBanana (Gemini)
                if (modelId === 'hidream') {
                    // Use RunPod HiDream endpoint
                    const generateFn = functions.httpsCallable('creationWizardGenerateSceneImage');
                    const result = await generateFn({
                        projectId: state.project.id,
                        sceneId: sceneId,
                        prompt: prompt,
                        style: state.content.style,
                        aspectRatio: state.platform.aspectRatio
                    });

                    if (result.data.success) {
                        storyboardScene.jobId = result.data.jobId;
                        storyboardScene.imageUrl = result.data.imageUrl;
                        storyboardScene.prompt = result.data.prompt;
                        storyboardScene.source = 'ai';

                        // Start polling for completion
                        startImagePolling(sceneId, result.data.jobId);
                    } else {
                        throw new Error(result.data.message || 'Generation failed');
                    }
                } else {
                    // Use NanoBanana (Gemini) - synchronous result
                    const generateFn = functions.httpsCallable('generateCreativeImage');

                    // Map aspect ratio
                    const aspectRatioMap = {
                        '16:9': '16:9',
                        '9:16': '9:16',
                        '1:1': '1:1',
                        '4:3': '4:3'
                    };

                    const result = await generateFn({
                        prompt: prompt,
                        model: modelId,
                        quantity: 1,
                        aspectRatio: aspectRatioMap[state.platform.aspectRatio] || '16:9',
                        quality: modelId === 'nanobanana-pro' ? 'hd' : 'basic'
                    });

                    if (result.data.success && result.data.images && result.data.images.length > 0) {
                        storyboardScene.status = 'ready';
                        storyboardScene.imageUrl = result.data.images[0].url;
                        storyboardScene.prompt = prompt;
                        storyboardScene.source = 'ai';
                        showToast(`Image generated! (${modelConfig.name})`, 'success');
                        scheduleAutoSave();
                    } else {
                        throw new Error(result.data.message || 'No images returned');
                    }
                }

                render();

            } catch (error) {
                console.error('Scene generation error:', error);
                storyboardScene.status = 'error';
                storyboardScene.error = error.message || 'Failed to generate image';

                // Show detailed error message
                const errorMsg = error.message || 'Unknown error';
                if (errorMsg.includes('token') || errorMsg.includes('balance')) {
                    showToast('Insufficient tokens. Visit Creative Studio to get more.', 'error');
                } else if (errorMsg.includes('API key') || errorMsg.includes('configured')) {
                    showToast('Service not configured. Contact support.', 'error');
                } else {
                    showToast(`Failed: ${errorMsg.substring(0, 50)}`, 'error');
                }
                render();
            }
        }

        async function regenerateSingleSceneImage(sceneId) {
            await generateSingleSceneImage(sceneId);
        }

        function startImagePolling(sceneId, jobId) {
            // Clear any existing polling for this scene
            if (imagePollingIntervals[sceneId]) {
                clearInterval(imagePollingIntervals[sceneId]);
            }

            let pollCount = 0;
            const maxPolls = 90; // 3 minutes max (2s intervals) - handles cold starts

            imagePollingIntervals[sceneId] = setInterval(async () => {
                pollCount++;

                if (pollCount > maxPolls) {
                    clearInterval(imagePollingIntervals[sceneId]);
                    const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                    if (storyboardScene && storyboardScene.status === 'generating') {
                        storyboardScene.status = 'error';
                        storyboardScene.error = 'Generation timed out. Try again.';
                        render();
                    }
                    return;
                }

                try {
                    const checkStatusFn = functions.httpsCallable('creationWizardCheckImageStatus');
                    const result = await checkStatusFn({ jobId });

                    if (result.data.status === 'COMPLETED') {
                        clearInterval(imagePollingIntervals[sceneId]);

                        const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                        if (storyboardScene) {
                            // Add cache-busting parameter to force browser to fetch fresh
                            if (storyboardScene.imageUrl) {
                                const separator = storyboardScene.imageUrl.includes('?') ? '&' : '?';
                                storyboardScene.imageUrl = `${storyboardScene.imageUrl}${separator}t=${Date.now()}`;
                            }

                            // Wait a moment for Firebase Storage to fully propagate the upload
                            await new Promise(resolve => setTimeout(resolve, 1000));

                            storyboardScene.status = 'ready';
                        }

                        // Check if all generating scenes are done
                        const allDone = state.storyboard.scenes.every(s =>
                            s.status === 'ready' || s.status === 'pending' || s.status === 'error'
                        );
                        if (allDone) {
                            state.storyboard.status = 'ready';
                        }

                        render();
                        scheduleAutoSave();

                    } else if (result.data.status === 'FAILED') {
                        clearInterval(imagePollingIntervals[sceneId]);

                        const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                        if (storyboardScene) {
                            storyboardScene.status = 'error';
                            storyboardScene.error = result.data.error || 'Generation failed';
                        }
                        render();
                    }
                    // If IN_PROGRESS or IN_QUEUE, keep polling

                } catch (error) {
                    console.error('Polling error:', error);
                }
            }, 2000); // Poll every 2 seconds
        }

        // Modify Modal Functions
        function openModifyModal(sceneId) {
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            const scene = state.script.scenes.find(s => s.id === sceneId);

            state.storyboard.modifyingScene = sceneId;
            state.storyboard.modifyPrompt = storyboardScene?.prompt || scene?.visual || '';
            state.storyboard.modifyStyle = state.content.style || 'cinematic';

            render();
        }

        function closeModifyModal() {
            state.storyboard.modifyingScene = null;
            state.storyboard.modifyPrompt = null;
            state.storyboard.modifyStyle = null;
            render();
        }

        function setModifyStyle(style) {
            state.storyboard.modifyStyle = style;
            render();
        }

        function appendToModifyPrompt(text) {
            const input = document.getElementById('modify-prompt-input');
            if (input) {
                const currentPrompt = input.value.trim();
                input.value = currentPrompt ? `${currentPrompt}, ${text}` : text;
                state.storyboard.modifyPrompt = input.value;
            }
        }

        async function applyModifyAndGenerate() {
            const sceneId = state.storyboard.modifyingScene;
            if (!sceneId) return;

            const input = document.getElementById('modify-prompt-input');
            const newPrompt = input?.value?.trim();

            if (!newPrompt || newPrompt.length < 10) {
                showToast('Please enter a more detailed prompt', 'warning');
                return;
            }

            // Update the scene's visual description
            const scene = state.script.scenes.find(s => s.id === sceneId);
            if (scene) {
                scene.visual = newPrompt;
            }

            // Update storyboard scene
            let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (storyboardScene) {
                storyboardScene.prompt = newPrompt;
            }

            closeModifyModal();

            // Generate with new prompt
            await generateSingleSceneImage(sceneId);
        }

        // ==========================================
        // 6.8.5 STOCK MEDIA BROWSER (Enhanced with VIDEO + Trim)
        // ==========================================
        let stockBrowserState = {
            isOpen: false,
            targetSceneId: null,
            mediaType: 'image', // 'image' | 'video'
            activeTab: 'images', // 'images' | 'videos'
            query: '',
            suggestedQuery: '', // Primary AI suggestion
            alternativeQueries: [], // Additional AI suggestions
            suggestedCategory: '', // AI-suggested category
            loadingAiSuggestions: false, // Loading state for AI suggestions
            results: [],
            videoResults: [], // Separate storage for video results
            loading: false,
            page: 1,
            total: 0,
            // Video trim state
            selectedVideo: null,  // Selected video for preview/trim
            trimStart: 0,         // Trim start time in seconds
            trimEnd: null,        // Trim end time (null = full duration)
            videoDuration: 0,     // Total video duration
            isPreviewPlaying: false
        };

        async function openStockBrowser(sceneId, mediaType = 'image') {
            stockBrowserState.isOpen = true;
            stockBrowserState.targetSceneId = sceneId;
            stockBrowserState.mediaType = mediaType;
            stockBrowserState.activeTab = mediaType === 'video' ? 'videos' : 'images';
            stockBrowserState.results = [];
            stockBrowserState.videoResults = [];
            stockBrowserState.query = '';
            stockBrowserState.page = 1;
            stockBrowserState.selectedVideo = null;
            stockBrowserState.trimStart = 0;
            stockBrowserState.trimEnd = null;
            stockBrowserState.alternativeQueries = [];
            stockBrowserState.suggestedCategory = '';
            stockBrowserState.loadingAiSuggestions = true;

            // Get scene for smart suggestions
            const scene = state.script.scenes.find(s => s.id === sceneId);

            // Use basic extraction as initial placeholder
            if (scene) {
                const basicQuery = extractSmartKeywords(scene);
                stockBrowserState.query = basicQuery;
                stockBrowserState.suggestedQuery = basicQuery;
            } else {
                stockBrowserState.query = 'cinematic background';
                stockBrowserState.suggestedQuery = '';
            }

            renderStockBrowserModal();

            // Start initial search with basic query
            if (stockBrowserState.query) {
                searchStockMedia(stockBrowserState.query);
            }

            // Simultaneously fetch AI-powered smart suggestions
            if (scene) {
                try {
                    const generateQueriesFn = functions.httpsCallable('generateSmartStockQueries');
                    const result = await generateQueriesFn({
                        sceneDescription: scene.visual || '',
                        narration: scene.narration || '',
                        mediaType: stockBrowserState.activeTab === 'videos' ? 'video' : 'image'
                    });

                    if (result.data.success) {
                        stockBrowserState.suggestedQuery = result.data.primaryQuery;
                        stockBrowserState.alternativeQueries = result.data.queries.slice(1) || [];
                        stockBrowserState.suggestedCategory = result.data.category || '';
                        stockBrowserState.loadingAiSuggestions = false;

                        // Update the search input with AI suggestion
                        const searchInput = document.getElementById('stock-search-input');
                        if (searchInput && stockBrowserState.query !== result.data.primaryQuery) {
                            searchInput.value = result.data.primaryQuery;
                            stockBrowserState.query = result.data.primaryQuery;
                        }

                        // Re-render to show AI suggestions
                        updateStockSuggestionsUI();

                        // Re-search with AI query if different from basic
                        if (result.data.primaryQuery && result.data.primaryQuery !== extractSmartKeywords(scene)) {
                            searchStockMedia(result.data.primaryQuery);
                        }
                    }
                } catch (error) {
                    console.error('AI suggestions error:', error);
                    stockBrowserState.loadingAiSuggestions = false;
                    updateStockSuggestionsUI();
                }
            } else {
                stockBrowserState.loadingAiSuggestions = false;
            }
        }

        // Update just the suggestions UI without re-rendering entire modal
        function updateStockSuggestionsUI() {
            const suggestionsArea = document.getElementById('stock-ai-suggestions');
            if (!suggestionsArea) return;

            let suggestionsHtml = '';

            if (stockBrowserState.loadingAiSuggestions) {
                suggestionsHtml = `
                    <div style="padding: 0.5rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 0.5rem;">
                        <span class="animate-spin" style="width: 14px; height: 14px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #a78bfa; border-radius: 50%;"></span>
                        <span style="color: #a78bfa; font-size: 0.75rem;">AI analyzing your scene...</span>
                    </div>
                `;
            } else if (stockBrowserState.suggestedQuery) {
                suggestionsHtml = `
                    <div style="padding: 0.6rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                            <span style="color: #a78bfa; font-size: 0.7rem;"> AI Smart Suggestions:</span>
                            ${stockBrowserState.suggestedCategory ? `<span style="background: rgba(139,92,246,0.3); color: #c4b5fd; padding: 0.1rem 0.4rem; border-radius: 1rem; font-size: 0.6rem;">${stockBrowserState.suggestedCategory}</span>` : ''}
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.4rem;">
                            <button onclick="applyStockSuggestion('${stockBrowserState.suggestedQuery.replace(/'/g, "\\'")}')"
                                    style="padding: 0.3rem 0.6rem; background: linear-gradient(135deg, rgba(139,92,246,0.4), rgba(236,72,153,0.3)); border: 1px solid rgba(139,92,246,0.5); border-radius: 1rem; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500;">
                                 ${stockBrowserState.suggestedQuery}
                            </button>
                            ${stockBrowserState.alternativeQueries.map(q => `
                                <button onclick="applyStockSuggestion('${q.replace(/'/g, "\\'")}')"
                                        style="padding: 0.3rem 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 1rem; color: rgba(255,255,255,0.8); cursor: pointer; font-size: 0.7rem;">
                                    ${q}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            suggestionsArea.innerHTML = suggestionsHtml;
        }

        // Apply a suggestion to search
        function applyStockSuggestion(query) {
            stockBrowserState.query = query;
            const searchInput = document.getElementById('stock-search-input');
            if (searchInput) searchInput.value = query;
            searchStockMedia(query);
        }

        // Extract smart keywords from scene description for stock search
        function extractSmartKeywords(scene) {
            const visual = scene.visual || '';
            const narration = scene.narration || '';
            const combined = `${visual} ${narration}`.toLowerCase();

            // Remove common words and extract key nouns/adjectives
            const stopWords = ['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                              'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
                              'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'dare',
                              'ought', 'used', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by',
                              'from', 'up', 'about', 'into', 'over', 'after', 'beneath', 'under',
                              'above', 'show', 'showing', 'shows', 'scene', 'image', 'video', 'clip'];

            // Extract words
            const words = combined
                .replace(/[^a-z\s]/g, '') // Remove non-letters
                .split(/\s+/)
                .filter(word => word.length > 2 && !stopWords.includes(word));

            // Prioritize descriptive words (colors, emotions, objects)
            const priorityWords = [];
            const visualKeywords = ['sunset', 'sunrise', 'ocean', 'mountain', 'forest', 'city',
                                   'beach', 'sky', 'cloud', 'rain', 'snow', 'fire', 'water',
                                   'office', 'business', 'technology', 'nature', 'people', 'team',
                                   'happy', 'sad', 'excited', 'calm', 'peaceful', 'dramatic',
                                   'bright', 'dark', 'colorful', 'minimal', 'modern', 'vintage',
                                   'aerial', 'closeup', 'portrait', 'landscape', 'abstract'];

            words.forEach(word => {
                if (visualKeywords.includes(word)) {
                    priorityWords.unshift(word);
                } else if (priorityWords.length < 3) {
                    priorityWords.push(word);
                }
            });

            // Return top 2-3 keywords
            const result = [...new Set(priorityWords)].slice(0, 3).join(' ');
            return result || 'cinematic background';
        }

        function closeStockBrowser() {
            stockBrowserState.isOpen = false;
            stockBrowserState.targetSceneId = null;
            const modal = document.getElementById('stock-browser-modal');
            if (modal) modal.remove();
        }

        async function searchStockMedia(query = stockBrowserState.query, page = 1) {
            if (!query || query.length < 2) {
                showToast('Please enter a search term', 'warning');
                return;
            }

            stockBrowserState.loading = true;
            stockBrowserState.query = query;
            stockBrowserState.page = page;
            renderStockBrowserModal();

            try {
                const searchFn = firebase.functions().httpsCallable('searchStockMedia');
                const result = await searchFn({
                    query: query,
                    type: stockBrowserState.mediaType,
                    source: 'all',
                    filters: {
                        orientation: state.platform.aspectRatio === '9:16' ? 'portrait' : 'landscape',
                        page: page,
                        perPage: 20
                    }
                });

                stockBrowserState.results = result.data.results || [];
                stockBrowserState.total = result.data.total || 0;
                stockBrowserState.loading = false;

            } catch (error) {
                console.error('Stock search error:', error);
                showToast('Failed to search stock media', 'error');
                stockBrowserState.loading = false;
            }

            renderStockBrowserModal();
        }

        async function selectStockMedia(media) {
            if (!stockBrowserState.targetSceneId) return;

            const sceneId = stockBrowserState.targetSceneId;
            showToast('Importing media...', 'info');

            try {
                // Import to Firebase Storage
                const importFn = firebase.functions().httpsCallable('importStockMedia');
                const result = await importFn({
                    mediaId: media.id,
                    url: media.url,
                    type: media.type,
                    projectId: state.project.id
                });

                if (result.data.success) {
                    // Update storyboard scene
                    let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                    if (!storyboardScene) {
                        storyboardScene = {
                            sceneId: sceneId,
                            status: 'pending',
                            imageUrl: null,
                            prompt: '',
                            jobId: null,
                            source: 'stock'
                        };
                        state.storyboard.scenes.push(storyboardScene);
                    }

                    storyboardScene.imageUrl = result.data.url;
                    storyboardScene.status = 'ready';
                    storyboardScene.source = 'stock';
                    storyboardScene.stockInfo = {
                        id: media.id,
                        source: media.source,
                        author: media.author,
                        license: media.license
                    };

                    closeStockBrowser();
                    showToast('Stock image added!', 'success');
                    scheduleAutoSave();
                    render();
                }
            } catch (error) {
                console.error('Import error:', error);
                showToast('Failed to import media', 'error');
            }
        }

        // Switch between Images and Videos tabs
        async function switchStockTab(tab) {
            stockBrowserState.activeTab = tab;
            stockBrowserState.selectedVideo = null;
            stockBrowserState.trimStart = 0;
            stockBrowserState.trimEnd = null;

            // Search with current query for new media type
            const mediaType = tab === 'videos' ? 'video' : 'image';
            const needsNewSuggestions = stockBrowserState.mediaType !== mediaType;
            stockBrowserState.mediaType = mediaType;

            if (stockBrowserState.query) {
                searchStockMedia(stockBrowserState.query);
            } else {
                renderStockBrowserModal();
            }

            // Regenerate AI suggestions for new media type
            if (needsNewSuggestions && stockBrowserState.targetSceneId) {
                const scene = state.script.scenes.find(s => s.id === stockBrowserState.targetSceneId);
                if (scene) {
                    stockBrowserState.loadingAiSuggestions = true;
                    updateStockSuggestionsUI();

                    try {
                        const generateQueriesFn = functions.httpsCallable('generateSmartStockQueries');
                        const result = await generateQueriesFn({
                            sceneDescription: scene.visual || '',
                            narration: scene.narration || '',
                            mediaType: mediaType
                        });

                        if (result.data.success) {
                            stockBrowserState.suggestedQuery = result.data.primaryQuery;
                            stockBrowserState.alternativeQueries = result.data.queries.slice(1) || [];
                            stockBrowserState.suggestedCategory = result.data.category || '';
                        }
                    } catch (error) {
                        console.error('AI suggestions error on tab switch:', error);
                    }
                    stockBrowserState.loadingAiSuggestions = false;
                    updateStockSuggestionsUI();
                }
            }
        }

        // Preview a stock video for trimming
        function previewStockVideo(media) {
            stockBrowserState.selectedVideo = media;
            stockBrowserState.trimStart = 0;
            stockBrowserState.trimEnd = null;
            stockBrowserState.videoDuration = media.duration || 30;
            renderStockBrowserModal();
        }

        // Update trim values from timeline
        function updateStockVideoTrim(handle, percent) {
            const duration = stockBrowserState.videoDuration || 30;
            const time = (percent / 100) * duration;

            if (handle === 'start') {
                stockBrowserState.trimStart = Math.max(0, Math.min(time, (stockBrowserState.trimEnd || duration) - 3));
            } else {
                stockBrowserState.trimEnd = Math.min(duration, Math.max(time, stockBrowserState.trimStart + 3));
            }
            renderStockBrowserModal();
        }

        // Format duration for display
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Select stock video with trim settings
        async function selectStockVideoWithTrim() {
            if (!stockBrowserState.selectedVideo || !stockBrowserState.targetSceneId) return;

            const media = stockBrowserState.selectedVideo;
            const sceneId = stockBrowserState.targetSceneId;
            const trimStart = stockBrowserState.trimStart || 0;
            const trimEnd = stockBrowserState.trimEnd || stockBrowserState.videoDuration;

            // Store thumbnail from search results (Pexels/Pixabay allow hotlinking thumbnails)
            const thumbnailUrl = media.thumbnail || media.preview || media.image;

            showToast('Importing video...', 'info');

            try {
                const importFn = firebase.functions().httpsCallable('importStockMedia');
                const result = await importFn({
                    mediaId: media.id,
                    url: media.videoUrl || media.url,
                    type: 'video',
                    projectId: state.project.id,
                    thumbnailUrl: thumbnailUrl, // Pass thumbnail for reference
                    trimStart: trimStart,
                    trimEnd: trimEnd,
                    originalDuration: media.duration || stockBrowserState.videoDuration
                });

                if (result.data.success) {
                    let storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                    if (!storyboardScene) {
                        storyboardScene = {
                            sceneId: sceneId,
                            status: 'pending',
                            imageUrl: null,
                            prompt: '',
                            jobId: null,
                            source: 'stock'
                        };
                        state.storyboard.scenes.push(storyboardScene);
                    }

                    // Use thumbnail from search results for preview (not the video URL)
                    storyboardScene.imageUrl = thumbnailUrl;
                    storyboardScene.videoUrl = result.data.url;
                    storyboardScene.status = 'ready';
                    storyboardScene.source = 'stock-video';
                    storyboardScene.stockInfo = {
                        id: media.id,
                        source: media.source,
                        author: media.author,
                        license: media.license,
                        thumbnailUrl: thumbnailUrl,
                        thumbnailFallback: media.thumbnailFallback || media.preview || null,
                        trimStart: trimStart,
                        trimEnd: trimEnd,
                        originalDuration: media.duration || stockBrowserState.videoDuration,
                        clipDuration: trimEnd - trimStart
                    };

                    closeStockBrowser();
                    showToast(`Video clip added! (${formatDuration(trimEnd - trimStart)})`, 'success');
                    scheduleAutoSave();
                    render();
                }
            } catch (error) {
                console.error('Video import error:', error);
                showToast('Failed to import video', 'error');
            }
        }

        function renderStockBrowserModal() {
            // Remove existing modal
            const existing = document.getElementById('stock-browser-modal');
            if (existing) existing.remove();

            if (!stockBrowserState.isOpen) return;

            const isVideoTab = stockBrowserState.activeTab === 'videos';
            const hasVideoSelected = stockBrowserState.selectedVideo !== null;
            const trimStart = stockBrowserState.trimStart || 0;
            const trimEnd = stockBrowserState.trimEnd || stockBrowserState.videoDuration || 30;
            const duration = stockBrowserState.videoDuration || 30;
            const startPercent = (trimStart / duration) * 100;
            const endPercent = (trimEnd / duration) * 100;

            const modal = document.createElement('div');
            modal.id = 'stock-browser-modal';
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1001; padding: 1rem;" onclick="if(event.target === this) closeStockBrowser()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 950px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; color: white; font-size: 1.1rem; font-weight: 600;"> Stock Media Browser</h3>
                                <p style="margin: 0.25rem 0 0 0; color: rgba(255,255,255,0.6); font-size: 0.8rem;">Free royalty-free media from Pexels & Pixabay</p>
                            </div>
                            <button onclick="closeStockBrowser()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Tab Switcher -->
                        <div style="display: flex; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button onclick="switchStockTab('images')"
                                    style="flex: 1; padding: 0.75rem; background: ${!isVideoTab ? 'rgba(139, 92, 246, 0.2)' : 'transparent'}; border: none; border-bottom: ${!isVideoTab ? '2px solid #8b5cf6' : '2px solid transparent'}; color: ${!isVideoTab ? 'white' : 'rgba(255,255,255,0.6)'}; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                                 Images
                            </button>
                            <button onclick="switchStockTab('videos')"
                                    style="flex: 1; padding: 0.75rem; background: ${isVideoTab ? 'rgba(16, 185, 129, 0.2)' : 'transparent'}; border: none; border-bottom: ${isVideoTab ? '2px solid #10b981' : '2px solid transparent'}; color: ${isVideoTab ? 'white' : 'rgba(255,255,255,0.6)'}; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                                 Videos
                            </button>
                        </div>

                        <!-- AI Smart Suggestions Container -->
                        <div id="stock-ai-suggestions">
                            ${stockBrowserState.loadingAiSuggestions ? `
                                <div style="padding: 0.5rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 0.5rem;">
                                    <span class="animate-spin" style="width: 14px; height: 14px; border: 2px solid rgba(139,92,246,0.3); border-top-color: #a78bfa; border-radius: 50%;"></span>
                                    <span style="color: #a78bfa; font-size: 0.75rem;">AI analyzing your scene...</span>
                                </div>
                            ` : stockBrowserState.suggestedQuery ? `
                                <div style="padding: 0.6rem 1.25rem; background: rgba(139, 92, 246, 0.1); border-bottom: 1px solid rgba(255,255,255,0.1);">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <span style="color: #a78bfa; font-size: 0.7rem;"> AI Smart Suggestions:</span>
                                        ${stockBrowserState.suggestedCategory ? `<span style="background: rgba(139,92,246,0.3); color: #c4b5fd; padding: 0.1rem 0.4rem; border-radius: 1rem; font-size: 0.6rem;">${stockBrowserState.suggestedCategory}</span>` : ''}
                                    </div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.4rem;">
                                        <button onclick="applyStockSuggestion('${stockBrowserState.suggestedQuery.replace(/'/g, "\\'")}')"
                                                style="padding: 0.3rem 0.6rem; background: linear-gradient(135deg, rgba(139,92,246,0.4), rgba(236,72,153,0.3)); border: 1px solid rgba(139,92,246,0.5); border-radius: 1rem; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500;">
                                             ${stockBrowserState.suggestedQuery}
                                        </button>
                                        ${(stockBrowserState.alternativeQueries || []).map(q => `
                                            <button onclick="applyStockSuggestion('${q.replace(/'/g, "\\'")}')"
                                                    style="padding: 0.3rem 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 1rem; color: rgba(255,255,255,0.8); cursor: pointer; font-size: 0.7rem;">
                                                ${q}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Search Bar -->
                        <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; gap: 0.5rem;">
                                <input type="text"
                                       id="stock-search-input"
                                       value="${stockBrowserState.query}"
                                       placeholder="Search for ${isVideoTab ? 'videos' : 'images'}..."
                                       style="flex: 1; padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem;"
                                       onkeydown="if(event.key === 'Enter') searchStockMedia(this.value)">
                                <button onclick="searchStockMedia(document.getElementById('stock-search-input').value)"
                                        style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, ${isVideoTab ? '#10b981, #059669' : '#8b5cf6, #06b6d4'}); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer;">
                                     Search
                                </button>
                            </div>
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem; flex-wrap: wrap;">
                                ${['nature', 'business', 'technology', 'people', 'city', 'abstract', 'motion', 'aerial'].map(tag => `
                                    <button onclick="searchStockMedia('${tag}')"
                                            style="padding: 0.4rem 0.75rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 1rem; color: rgba(255,255,255,0.8); font-size: 0.75rem; cursor: pointer; transition: all 0.2s;"
                                            onmouseover="this.style.background='rgba(139,92,246,0.3)'"
                                            onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                                        ${tag}
                                    </button>
                                `).join('')}
                            </div>
                        </div>

                        ${isVideoTab && hasVideoSelected ? `
                            <!-- Video Preview & Trim Panel -->
                            <div style="padding: 1rem; background: rgba(0,0,0,0.3);">
                                <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                                    <!-- Video Preview -->
                                    <div style="flex: 1; min-width: 300px;">
                                        <video id="stock-video-preview"
                                               src="${stockBrowserState.selectedVideo.videoUrl || stockBrowserState.selectedVideo.url}"
                                               style="width: 100%; max-height: 200px; border-radius: 0.5rem; background: black;"
                                               controls
                                               muted></video>
                                    </div>

                                    <!-- Trim Controls -->
                                    <div style="flex: 1; min-width: 250px;">
                                        <div style="color: white; font-size: 0.85rem; font-weight: 600; margin-bottom: 0.75rem;"> Trim Video Clip</div>

                                        <!-- Timeline -->
                                        <div style="position: relative; height: 40px; background: rgba(255,255,255,0.1); border-radius: 0.5rem; margin-bottom: 0.75rem; cursor: pointer;"
                                             id="video-trim-timeline">
                                            <!-- Selected region -->
                                            <div style="position: absolute; top: 0; bottom: 0; left: ${startPercent}%; width: ${endPercent - startPercent}%; background: linear-gradient(135deg, rgba(16, 185, 129, 0.4), rgba(6, 182, 212, 0.4)); border-radius: 0.25rem;"></div>

                                            <!-- Start handle -->
                                            <div style="position: absolute; top: 0; bottom: 0; left: ${startPercent}%; width: 12px; background: #10b981; border-radius: 0.25rem; cursor: ew-resize; transform: translateX(-50%); display: flex; align-items: center; justify-content: center;"
                                                 class="trim-handle" data-handle="start">
                                                <div style="width: 2px; height: 60%; background: white; border-radius: 1px;"></div>
                                            </div>

                                            <!-- End handle -->
                                            <div style="position: absolute; top: 0; bottom: 0; left: ${endPercent}%; width: 12px; background: #10b981; border-radius: 0.25rem; cursor: ew-resize; transform: translateX(-50%); display: flex; align-items: center; justify-content: center;"
                                                 class="trim-handle" data-handle="end">
                                                <div style="width: 2px; height: 60%; background: white; border-radius: 1px;"></div>
                                            </div>
                                        </div>

                                        <!-- Time Display -->
                                        <div style="display: flex; justify-content: space-between; color: rgba(255,255,255,0.7); font-size: 0.75rem; margin-bottom: 0.75rem;">
                                            <span>Start: ${formatDuration(trimStart)}</span>
                                            <span style="color: #10b981; font-weight: 600;">Duration: ${formatDuration(trimEnd - trimStart)}</span>
                                            <span>End: ${formatDuration(trimEnd)}</span>
                                        </div>

                                        <!-- Action Buttons -->
                                        <div style="display: flex; gap: 0.5rem;">
                                            <button onclick="stockBrowserState.selectedVideo = null; renderStockBrowserModal();"
                                                    style="flex: 1; padding: 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                                 Back
                                            </button>
                                            <button onclick="selectStockVideoWithTrim()"
                                                    style="flex: 2; padding: 0.6rem; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 0.5rem; color: white; font-weight: 600; cursor: pointer;">
                                                 Use This Clip
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : `
                            <!-- Results Grid -->
                            <div style="flex: 1; overflow-y: auto; padding: 1rem;">
                                ${stockBrowserState.loading ? `
                                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem;">
                                        <div style="width: 40px; height: 40px; border: 3px solid rgba(139, 92, 246, 0.2); border-top-color: #8b5cf6; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                        <p style="color: rgba(255,255,255,0.6); margin-top: 1rem;">Searching ${isVideoTab ? 'videos' : 'images'}...</p>
                                    </div>
                                ` : stockBrowserState.results.length === 0 ? `
                                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem; text-align: center;">
                                        <div style="font-size: 3rem; margin-bottom: 1rem;">${isVideoTab ? '' : ''}</div>
                                        <p style="color: rgba(255,255,255,0.6);">Search for stock ${isVideoTab ? 'videos' : 'images'} above</p>
                                        <p style="color: rgba(255,255,255,0.4); font-size: 0.85rem;">Try keywords like "nature", "business", or "technology"</p>
                                    </div>
                                ` : `
                                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(${isVideoTab ? '200px' : '180px'}, 1fr)); gap: 0.75rem;">
                                        ${stockBrowserState.results.map(media => isVideoTab ? `
                                            <!-- Video Card -->
                                            <div onclick="previewStockVideo(${JSON.stringify(media).replace(/"/g, '&quot;')})"
                                                 style="position: relative; aspect-ratio: 16/9; border-radius: 0.5rem; overflow: hidden; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;"
                                                 onmouseover="this.style.borderColor='#10b981'; this.style.transform='scale(1.02)'"
                                                 onmouseout="this.style.borderColor='transparent'; this.style.transform='scale(1)'">
                                                <img src="${media.thumbnail || media.preview}"
                                                     alt=""
                                                     style="width: 100%; height: 100%; object-fit: cover;">
                                                <!-- Play icon overlay -->
                                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; background: rgba(0,0,0,0.7); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                                    <div style="width: 0; height: 0; border-left: 12px solid white; border-top: 8px solid transparent; border-bottom: 8px solid transparent; margin-left: 3px;"></div>
                                                </div>
                                                <!-- Duration badge -->
                                                <div style="position: absolute; bottom: 0.5rem; right: 0.5rem; background: rgba(0,0,0,0.8); color: white; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-size: 0.7rem;">
                                                    ${formatDuration(media.duration || 30)}
                                                </div>
                                                <!-- Source badge -->
                                                <div style="position: absolute; bottom: 0.5rem; left: 0.5rem; background: rgba(0,0,0,0.8); color: rgba(255,255,255,0.8); padding: 0.15rem 0.35rem; border-radius: 0.25rem; font-size: 0.6rem;">
                                                    ${media.source === 'pexels' ? ' Pexels' : ' Pixabay'}
                                                </div>
                                            </div>
                                        ` : `
                                            <!-- Image Card -->
                                            <div onclick="selectStockMedia(${JSON.stringify(media).replace(/"/g, '&quot;')})"
                                                 style="position: relative; aspect-ratio: ${state.platform.aspectRatio === '9:16' ? '9/16' : '16/9'}; border-radius: 0.5rem; overflow: hidden; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;"
                                                 onmouseover="this.style.borderColor='#8b5cf6'; this.style.transform='scale(1.02)'"
                                                 onmouseout="this.style.borderColor='transparent'; this.style.transform='scale(1)'">
                                                <img src="${media.thumbnail || media.preview}"
                                                     alt=""
                                                     style="width: 100%; height: 100%; object-fit: cover;">
                                                <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 0.5rem; background: linear-gradient(transparent, rgba(0,0,0,0.8));">
                                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.8);">
                                                        ${media.source === 'pexels' ? ' Pexels' : ' Pixabay'}
                                                    </div>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    ${stockBrowserState.total > 20 ? `
                                        <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem;">
                                            ${stockBrowserState.page > 1 ? `
                                                <button onclick="searchStockMedia(stockBrowserState.query, ${stockBrowserState.page - 1})"
                                                        style="padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                                     Previous
                                                </button>
                                            ` : ''}
                                            <span style="padding: 0.5rem 1rem; color: rgba(255,255,255,0.6);">
                                                Page ${stockBrowserState.page}
                                            </span>
                                            <button onclick="searchStockMedia(stockBrowserState.query, ${stockBrowserState.page + 1})"
                                                    style="padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; cursor: pointer;">
                                                Next 
                                            </button>
                                        </div>
                                    ` : ''}
                                `}
                            </div>
                        `}

                        <!-- Footer -->
                        <div style="padding: 0.75rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.75rem;">
                                ${stockBrowserState.total > 0 ? `${stockBrowserState.total.toLocaleString()} ${isVideoTab ? 'videos' : 'images'} found` : ''}
                            </div>
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">
                                 Stock media is free and doesn't use tokens
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Setup trim handle dragging for videos
            if (isVideoTab && hasVideoSelected) {
                setupTrimHandles();
            }

            // Focus search input
            setTimeout(() => {
                const input = document.getElementById('stock-search-input');
                if (input && !hasVideoSelected) input.focus();
            }, 100);
        }

        // Setup drag handlers for video trim timeline
        function setupTrimHandles() {
            const timeline = document.getElementById('video-trim-timeline');
            if (!timeline) return;

            let isDragging = null;

            timeline.addEventListener('mousedown', (e) => {
                const handle = e.target.closest('.trim-handle');
                if (handle) {
                    isDragging = handle.dataset.handle;
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const timeline = document.getElementById('video-trim-timeline');
                if (!timeline) return;

                const rect = timeline.getBoundingClientRect();
                const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));

                updateStockVideoTrim(isDragging, percent);
            });

            document.addEventListener('mouseup', () => {
                isDragging = null;
            });
        }

        // ==========================================
        // 6.8.6 EDIT WITH AI MODAL
        // ==========================================

        // Open the AI edit modal for a scene image
        function openEditModal(sceneId) {
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene || !storyboardScene.imageUrl) {
                showToast('No image to edit', 'warning');
                return;
            }

            state.storyboard.editingScene = sceneId;
            state.storyboard.editPrompt = '';
            state.storyboard.editLoading = false;
            state.storyboard.editHistory = [];
            state.storyboard.editMaskCanvas = null;
            state.storyboard.editMaskCtx = null;

            renderEditModal();
        }

        // Close the edit modal
        function closeEditModal() {
            state.storyboard.editingScene = null;
            state.storyboard.editPrompt = '';
            state.storyboard.editLoading = false;
            const modal = document.getElementById('edit-ai-modal');
            if (modal) modal.remove();
        }

        // Initialize the canvas for mask painting
        function initEditCanvas() {
            const sceneId = state.storyboard.editingScene;
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene || !storyboardScene.imageUrl) return;

            const canvas = document.getElementById('edit-canvas');
            if (!canvas) {
                setTimeout(initEditCanvas, 100);
                return;
            }

            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = function() {
                // Set canvas size - maintain aspect ratio, max width 600px
                const maxWidth = 600;
                const scale = Math.min(1, maxWidth / img.width);
                canvas.width = Math.floor(img.width * scale);
                canvas.height = Math.floor(img.height * scale);

                // Store original dimensions
                canvas.dataset.originalWidth = img.width;
                canvas.dataset.originalHeight = img.height;

                // Draw the image
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // Store original image data
                state.storyboard.editOriginalData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Create mask canvas
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = canvas.width;
                maskCanvas.height = canvas.height;
                state.storyboard.editMaskCanvas = maskCanvas;
                state.storyboard.editMaskCtx = maskCanvas.getContext('2d');

                // Fill with black (unmasked)
                state.storyboard.editMaskCtx.fillStyle = 'black';
                state.storyboard.editMaskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

                canvas.style.cursor = 'crosshair';
                setupEditCanvasEvents(canvas);
            };

            img.onerror = function() {
                console.error('Failed to load image for editing');
                showToast('Failed to load image', 'error');
            };

            img.src = storyboardScene.imageUrl;
        }

        // Setup mouse/touch events for canvas painting
        function setupEditCanvasEvents(canvas) {
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            const getCoords = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            const startDraw = (e) => {
                isDrawing = true;
                const coords = getCoords(e);
                lastX = coords.x;
                lastY = coords.y;
                paintEditMask(lastX, lastY);
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const coords = getCoords(e);
                paintEditMaskLine(lastX, lastY, coords.x, coords.y);
                lastX = coords.x;
                lastY = coords.y;
            };

            const endDraw = () => {
                isDrawing = false;
            };

            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('mouseleave', endDraw);

            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e); });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); });
            canvas.addEventListener('touchend', endDraw);
        }

        // Paint a single point on the mask
        function paintEditMask(x, y) {
            if (!state.storyboard.editMaskCtx) return;

            const brushSize = state.storyboard.editBrushSize || 30;
            state.storyboard.editMaskCtx.fillStyle = 'white';
            state.storyboard.editMaskCtx.beginPath();
            state.storyboard.editMaskCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
            state.storyboard.editMaskCtx.fill();

            redrawEditCanvas();
        }

        // Paint a line on the mask
        function paintEditMaskLine(x1, y1, x2, y2) {
            if (!state.storyboard.editMaskCtx) return;

            const brushSize = state.storyboard.editBrushSize || 30;
            state.storyboard.editMaskCtx.strokeStyle = 'white';
            state.storyboard.editMaskCtx.lineWidth = brushSize;
            state.storyboard.editMaskCtx.lineCap = 'round';
            state.storyboard.editMaskCtx.lineJoin = 'round';
            state.storyboard.editMaskCtx.beginPath();
            state.storyboard.editMaskCtx.moveTo(x1, y1);
            state.storyboard.editMaskCtx.lineTo(x2, y2);
            state.storyboard.editMaskCtx.stroke();

            redrawEditCanvas();
        }

        // Redraw the canvas with mask overlay
        function redrawEditCanvas() {
            const canvas = document.getElementById('edit-canvas');
            if (!canvas || !state.storyboard.editOriginalData) return;

            const ctx = canvas.getContext('2d');

            // Draw original image
            const imgCanvas = document.createElement('canvas');
            imgCanvas.width = canvas.width;
            imgCanvas.height = canvas.height;
            imgCanvas.getContext('2d').putImageData(state.storyboard.editOriginalData, 0, 0);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(imgCanvas, 0, 0);

            // Draw pink overlay where mask is white
            if (state.storyboard.editMaskCanvas) {
                const maskCtx = state.storyboard.editMaskCtx;
                const maskData = maskCtx.getImageData(0, 0, state.storyboard.editMaskCanvas.width, state.storyboard.editMaskCanvas.height);

                const overlayCanvas = document.createElement('canvas');
                overlayCanvas.width = canvas.width;
                overlayCanvas.height = canvas.height;
                const overlayCtx = overlayCanvas.getContext('2d');
                overlayCtx.drawImage(state.storyboard.editMaskCanvas, 0, 0);

                const overlayData = overlayCtx.getImageData(0, 0, overlayCanvas.width, overlayCanvas.height);
                for (let i = 0; i < overlayData.data.length; i += 4) {
                    if (overlayData.data[i] > 128) {
                        overlayData.data[i] = 236;     // R - pink
                        overlayData.data[i + 1] = 72;  // G
                        overlayData.data[i + 2] = 153; // B
                        overlayData.data[i + 3] = 150; // A - semi-transparent
                    } else {
                        overlayData.data[i + 3] = 0;   // Transparent
                    }
                }
                overlayCtx.putImageData(overlayData, 0, 0);
                ctx.drawImage(overlayCanvas, 0, 0);
            }
        }

        // Get mask as base64 PNG
        function getEditMaskBase64() {
            if (!state.storyboard.editMaskCanvas) return null;

            const canvas = document.getElementById('edit-canvas');
            const originalWidth = parseInt(canvas.dataset.originalWidth) || 1280;
            const originalHeight = parseInt(canvas.dataset.originalHeight) || 720;

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = originalWidth;
            exportCanvas.height = originalHeight;
            const ctx = exportCanvas.getContext('2d');

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            ctx.drawImage(state.storyboard.editMaskCanvas, 0, 0, exportCanvas.width, exportCanvas.height);

            // Check if mask has any white pixels
            const imageData = ctx.getImageData(0, 0, exportCanvas.width, exportCanvas.height);
            let hasWhite = false;
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i] > 200) {
                    hasWhite = true;
                    break;
                }
            }

            if (!hasWhite) return null;
            return exportCanvas.toDataURL('image/png').split(',')[1];
        }

        // Set brush size
        function setEditBrushSize(size) {
            state.storyboard.editBrushSize = parseInt(size) || 30;
        }

        // Clear the mask
        function clearEditMask() {
            if (!state.storyboard.editMaskCtx) return;

            state.storyboard.editMaskCtx.fillStyle = 'black';
            state.storyboard.editMaskCtx.fillRect(0, 0, state.storyboard.editMaskCanvas.width, state.storyboard.editMaskCanvas.height);
            redrawEditCanvas();
        }

        // Set edit prompt
        function setEditPrompt(value) {
            state.storyboard.editPrompt = value;
        }

        // Apply the AI edit
        async function applyAIEdit() {
            const sceneId = state.storyboard.editingScene;
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            if (!storyboardScene || !storyboardScene.imageUrl) return;

            const maskBase64 = getEditMaskBase64();
            let editPrompt = state.storyboard.editPrompt.trim();

            if (!editPrompt && !maskBase64) {
                showToast('Please enter what you want to change, or paint an area', 'warning');
                return;
            }

            if (!editPrompt && maskBase64) {
                editPrompt = 'Remove the marked area seamlessly';
            }

            state.storyboard.editLoading = true;
            renderEditModal();

            try {
                const editFn = firebase.functions().httpsCallable('editThumbnailWithAI');
                const requestData = {
                    imageUrl: storyboardScene.imageUrl,
                    editPrompt: editPrompt
                };

                if (maskBase64) {
                    requestData.maskBase64 = maskBase64;
                }

                const result = await editFn(requestData);

                if (result.data.success && result.data.editedUrl) {
                    // Update scene with edited image
                    storyboardScene.imageUrl = result.data.editedUrl;
                    storyboardScene.editHistory = storyboardScene.editHistory || [];
                    storyboardScene.editHistory.push({
                        prompt: editPrompt,
                        timestamp: Date.now()
                    });

                    closeEditModal();
                    showToast('Image edited successfully!', 'success');
                    scheduleAutoSave();
                    render();
                } else {
                    throw new Error(result.data.message || 'Edit failed');
                }
            } catch (error) {
                console.error('AI edit error:', error);
                state.storyboard.editLoading = false;
                showToast(`Edit failed: ${error.message}`, 'error');
                renderEditModal();
            }
        }

        // Render the Edit with AI modal
        function renderEditModal() {
            const existing = document.getElementById('edit-ai-modal');
            if (existing) existing.remove();

            if (!state.storyboard.editingScene) return;

            const sceneId = state.storyboard.editingScene;
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
            const scene = state.script.scenes.find(s => s.id === sceneId);
            const sceneIndex = state.script.scenes.findIndex(s => s.id === sceneId);

            if (!storyboardScene || !storyboardScene.imageUrl) return;

            const modal = document.createElement('div');
            modal.id = 'edit-ai-modal';
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1002; padding: 1rem;" onclick="if(event.target === this) closeEditModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 700px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div style="padding: 1rem 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; color: white; font-size: 1.1rem; font-weight: 600;"> Edit Scene ${sceneIndex + 1} with AI</h3>
                                <p style="margin: 0.25rem 0 0 0; color: rgba(255,255,255,0.6); font-size: 0.8rem;">Paint to select areas, describe your edit</p>
                            </div>
                            <button onclick="closeEditModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Canvas Area -->
                        <div style="flex: 1; overflow-y: auto; padding: 1rem;">
                            ${state.storyboard.editLoading ? `
                                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem;">
                                    <div style="width: 50px; height: 50px; border: 3px solid rgba(236, 72, 153, 0.2); border-top-color: #ec4899; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                    <p style="color: rgba(255,255,255,0.8); margin-top: 1rem; font-weight: 500;">AI is editing your image...</p>
                                    <p style="color: rgba(255,255,255,0.5); font-size: 0.8rem; margin-top: 0.5rem;">This may take 10-30 seconds</p>
                                </div>
                            ` : `
                                <!-- Canvas -->
                                <div style="display: flex; justify-content: center; margin-bottom: 1rem;">
                                    <canvas id="edit-canvas" style="max-width: 100%; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></canvas>
                                </div>

                                <!-- Brush Controls -->
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="color: rgba(255,255,255,0.7); font-size: 0.8rem;"> Brush:</span>
                                        <input type="range" min="10" max="100" value="${state.storyboard.editBrushSize || 30}"
                                               oninput="setEditBrushSize(this.value); document.getElementById('brush-size-display').textContent = this.value + 'px'"
                                               style="width: 100px; accent-color: #ec4899;">
                                        <span id="brush-size-display" style="color: white; font-size: 0.75rem; width: 40px;">${state.storyboard.editBrushSize || 30}px</span>
                                    </div>
                                    <button onclick="clearEditMask()" style="padding: 0.4rem 0.75rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                         Clear
                                    </button>
                                </div>

                                <p style="color: rgba(255,255,255,0.5); font-size: 0.75rem; text-align: center; margin-bottom: 1rem;">
                                     <strong>Optional:</strong> Paint to select specific areas, or skip to edit the entire image
                                </p>

                                <!-- Prompt Input -->
                                <div style="margin-bottom: 1rem;">
                                    <label style="color: rgba(255,255,255,0.7); font-size: 0.85rem; display: block; margin-bottom: 0.5rem;">What do you want to change?</label>
                                    <input type="text" id="edit-prompt-input" value="${state.storyboard.editPrompt || ''}"
                                           placeholder="e.g., Make the sky more dramatic, remove the person, add lens flare..."
                                           oninput="setEditPrompt(this.value)"
                                           style="width: 100%; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem;">
                                </div>

                                <!-- Quick Suggestions -->
                                <div style="display: flex; flex-wrap: wrap; gap: 0.4rem; margin-bottom: 1rem;">
                                    ${['Remove marked area', 'Make it brighter', 'Add dramatic lighting', 'Make colors more vibrant', 'Add film grain effect'].map(suggestion => `
                                        <button onclick="setEditPrompt('${suggestion}'); document.getElementById('edit-prompt-input').value = '${suggestion}';"
                                                style="padding: 0.35rem 0.6rem; background: rgba(236, 72, 153, 0.1); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 1rem; color: #f9a8d4; font-size: 0.7rem; cursor: pointer; transition: all 0.2s;"
                                                onmouseover="this.style.background='rgba(236, 72, 153, 0.2)'"
                                                onmouseout="this.style.background='rgba(236, 72, 153, 0.1)'">
                                            ${suggestion}
                                        </button>
                                    `).join('')}
                                </div>
                            `}
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1rem 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <button onclick="closeEditModal()"
                                    style="padding: 0.6rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; color: white; font-size: 0.85rem; cursor: pointer;">
                                Cancel
                            </button>
                            <button onclick="applyAIEdit()" ${state.storyboard.editLoading ? 'disabled' : ''}
                                    style="padding: 0.6rem 1.5rem; background: linear-gradient(135deg, #ec4899, #8b5cf6); border: none; border-radius: 0.5rem; color: white; font-weight: 600; font-size: 0.85rem; cursor: pointer; opacity: ${state.storyboard.editLoading ? '0.5' : '1'};">
                                ${state.storyboard.editLoading ? 'Editing...' : ' Apply Edit (2 tokens)'}
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Initialize canvas after render
            if (!state.storyboard.editLoading) {
                setTimeout(initEditCanvas, 100);
            }
        }

        // ==========================================
        // 6.9 COST ESTIMATION
        // ==========================================
        function estimateCost() {
            const duration = state.platform.targetDuration || 60;
            const sceneDuration = 10; // Average scene duration
            const sceneCount = Math.ceil(duration / sceneDuration);

            // Base costs (in tokens)
            const costs = {
                scriptGeneration: 5,
                imagesPerScene: 2, // HD quality
                voiceoverPer30s: 1,
                animationPerScene: 3, // Runpod Multi-talk
                export: 3
            };

            const totalImages = sceneCount * costs.imagesPerScene;
            const voiceoverUnits = Math.ceil(duration / 30);
            const animationCost = sceneCount * costs.animationPerScene;

            const total = costs.scriptGeneration +
                         totalImages +
                         (voiceoverUnits * costs.voiceoverPer30s) +
                         animationCost +
                         costs.export;

            return {
                total,
                breakdown: {
                    script: costs.scriptGeneration,
                    images: totalImages,
                    voiceover: voiceoverUnits * costs.voiceoverPer30s,
                    animation: animationCost,
                    export: costs.export
                },
                sceneCount
            };
        }

        // ==========================================
        // 6.7 UTILITY FUNCTIONS
        // ==========================================
        function formatDuration(seconds) {
            // Round to avoid floating point precision issues
            const roundedSeconds = Math.round(seconds);
            if (roundedSeconds < 60) {
                return `${roundedSeconds}s`;
            }
            const minutes = Math.floor(roundedSeconds / 60);
            const secs = roundedSeconds % 60;
            return secs > 0 ? `${minutes}m ${secs}s` : `${minutes}m`;
        }

        function showToast(message, type = 'info') {
            // Simple toast implementation
            const toast = document.createElement('div');
            toast.className = `fixed bottom-4 right-4 px-4 py-3 rounded-lg text-white text-sm font-medium z-50 fade-in`;
            toast.style.background = type === 'warning' ? '#f59e0b' :
                                    type === 'error' ? '#ef4444' :
                                    type === 'success' ? '#10b981' : '#8b5cf6';
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ==========================================
        // 6.8 PROJECTS MODAL
        // ==========================================
        let projectsModalOpen = false;

        async function openProjectsModal() {
            projectsModalOpen = true;
            renderProjectsModal();

            // Load projects list
            const projects = await loadProjectsList();
            renderProjectsModal(projects);
        }

        function closeProjectsModal() {
            projectsModalOpen = false;
            const modal = document.getElementById('projects-modal');
            if (modal) modal.remove();
        }

        function renderProjectsModal(projects = null) {
            // Remove existing modal if any
            const existing = document.getElementById('projects-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.id = 'projects-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                padding: 1rem;
            `;

            let content = `
                <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 600px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
                    <div style="padding: 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="color: white; font-size: 1.25rem; font-weight: 700;">My Video Projects</h2>
                        <button onclick="closeProjectsModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                    </div>
                    <div style="padding: 1rem; overflow-y: auto; flex: 1;">
            `;

            if (projects === null) {
                // Loading state
                content += `
                    <div style="text-align: center; padding: 3rem; color: rgba(255,255,255,0.6);">
                        <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%; margin: 0 auto 1rem;"></div>
                        Loading projects...
                    </div>
                `;
            } else if (projects.length === 0) {
                // Empty state
                content += `
                    <div style="text-align: center; padding: 3rem; color: rgba(255,255,255,0.6);">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <p>No projects yet</p>
                        <p style="font-size: 0.85rem; margin-top: 0.5rem;">Create your first video to see it here!</p>
                    </div>
                `;
            } else {
                // Projects list
                projects.forEach(project => {
                    const isCurrent = state.project.id === project.id;
                    const nicheIcon = project.niche ? VIDEO_NICHES[project.niche]?.icon || '' : '';
                    const updatedDate = project.updatedAt ? new Date(project.updatedAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : 'Unknown';

                    content += `
                        <div style="background: ${isCurrent ? 'rgba(139,92,246,0.2)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${isCurrent ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.75rem; padding: 1rem; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 1rem;">
                            <div style="font-size: 1.5rem;">${nicheIcon}</div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${project.name || 'Untitled'}</div>
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.8rem;">${project.platform || 'No platform'}  ${project.sceneCount} scenes  ${updatedDate}</div>
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                ${isCurrent ? '<span style="color: #8b5cf6; font-size: 0.75rem; font-weight: 600;">CURRENT</span>' : `
                                    <button onclick="loadProjectFromModal('${project.id}')" style="background: rgba(139,92,246,0.2); border: 1px solid rgba(139,92,246,0.4); border-radius: 0.5rem; padding: 0.4rem 0.75rem; color: white; cursor: pointer; font-size: 0.75rem;">Open</button>
                                `}
                                <button onclick="deleteProjectFromModal('${project.id}')" style="background: rgba(239,68,68,0.2); border: 1px solid rgba(239,68,68,0.4); border-radius: 0.5rem; padding: 0.4rem 0.5rem; color: #ef4444; cursor: pointer; font-size: 0.75rem;"></button>
                            </div>
                        </div>
                    `;
                });
            }

            content += `
                    </div>
                    <div style="padding: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <button onclick="startNewProject()" style="width: 100%; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; border-radius: 0.5rem; padding: 0.75rem; color: white; font-weight: 600; cursor: pointer;">
                            + New Project
                        </button>
                    </div>
                </div>
            `;

            modal.innerHTML = content;
            modal.onclick = (e) => {
                if (e.target === modal) closeProjectsModal();
            };

            document.body.appendChild(modal);
        }

        function loadProjectFromModal(projectId) {
            closeProjectsModal();
            window.location.href = `/video-creation-wizard?project=${projectId}`;
        }

        async function deleteProjectFromModal(projectId) {
            if (!confirm('Are you sure you want to delete this project?')) return;

            try {
                const deleteProjectFn = functions.httpsCallable('creationWizardDeleteProject');
                await deleteProjectFn({ projectId });

                // Reload projects list
                const projects = await loadProjectsList();
                renderProjectsModal(projects);

                // If we deleted the current project, reset state
                if (state.project.id === projectId) {
                    state.project.id = null;
                    state.project.name = null;
                    render();
                }

                showToast('Project deleted', 'success');
            } catch (error) {
                console.error('Delete error:', error);
                showToast('Failed to delete project', 'error');
            }
        }

        function startNewProject() {
            closeProjectsModal();
            window.location.href = '/video-creation-wizard';
        }
    </script>

    <!-- ============================================
         SECTION 7: RENDER FUNCTIONS
         ============================================ -->
    <script>
        // ==========================================
        // 7.1 MAIN RENDER FUNCTION
        // ==========================================
        function render() {
            const app = document.getElementById('app-root');

            let html = '';

            // Step 7 (Export) uses a full-screen fixed editor layout
            if (state.currentStep === 7) {
                html = renderFullScreenEditor();
                app.innerHTML = html;
                attachEventListeners();

                // Reattach preview engine to canvas if needed
                if (previewEngine && state.preview.isReady) {
                    const newCanvas = document.getElementById('timeline-preview-canvas');
                    if (newCanvas && previewEngine.canvas !== newCanvas) {
                        if (!state.preview.isPlaying) {
                            previewEngine.attachToCanvas(newCanvas);
                        } else {
                            // If playing, update canvas reference AND set dimensions
                            // CRITICAL: Must set canvas.width/height to match engine dimensions
                            previewEngine.canvas = newCanvas;
                            previewEngine.ctx = newCanvas.getContext('2d');
                            newCanvas.width = previewEngine.width;
                            newCanvas.height = previewEngine.height;
                        }
                    }
                }
                return;
            }

            // Normal wizard layout for steps 1-6
            // Header bar
            html += renderHeaderBar();

            // Main container
            html += '<div class="wizard-container">';

            // Wizard header
            html += renderWizardHeader();

            // Stepper
            html += renderStepper();

            // Step content
            switch (state.currentStep) {
                case 1:
                    html += renderStep1Platform();
                    break;
                case 2:
                    html += renderStep2NicheStyle();
                    break;
                case 3:
                    html += renderStep3Script();
                    break;
                case 4:
                    html += renderStep4Storyboard();
                    break;
                case 5:
                    html += renderStep5Animation();
                    break;
                case 6:
                    html += renderStep6Assembly();
                    break;
            }

            html += '</div>'; // End wizard-container

            app.innerHTML = html;
            attachEventListeners();

            // CRITICAL: Reattach preview engine to new canvas after DOM re-render
            // But ONLY if not currently playing to prevent flickering
            if (previewEngine && state.preview.isReady) {
                const canvasId = 'preview-canvas';
                const newCanvas = document.getElementById(canvasId);
                if (newCanvas && previewEngine.canvas !== newCanvas) {
                    // Only reattach if canvas element actually changed AND not playing
                    if (!state.preview.isPlaying) {
                        previewEngine.attachToCanvas(newCanvas);
                    } else {
                        // If playing, update canvas reference AND set dimensions
                        // CRITICAL: Must set canvas.width/height to match engine dimensions
                        // otherwise canvas defaults to 300x150 and rendering is distorted
                        previewEngine.canvas = newCanvas;
                        previewEngine.ctx = newCanvas.getContext('2d');
                        newCanvas.width = previewEngine.width;
                        newCanvas.height = previewEngine.height;
                    }
                }
            }
        }

        // ==========================================
        // 7.2 HEADER BAR
        // ==========================================
        function renderHeaderBar() {
            const projectName = state.project.name || 'New Project';
            const isSaved = state.project.id !== null;

            return `
                <div class="header-bar">
                    <div class="header-left">
                        <a href="/video-optimizer" class="back-link">
                            <span></span>
                            <span>Dashboard</span>
                        </a>
                        <div class="project-info" style="margin-left: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">${projectName}</span>
                            ${isSaved ? '<span style="color: #10b981; font-size: 0.7rem;">Saved</span>' : '<span style="color: #f59e0b; font-size: 0.7rem;">Unsaved</span>'}
                        </div>
                    </div>
                    <div class="header-right" style="display: flex; align-items: center; gap: 1rem;">
                        <button onclick="openProjectsModal()" class="header-btn" style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; padding: 0.4rem 0.75rem; color: white; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 0.3rem;">
                            <span></span>
                            <span>Projects</span>
                        </button>
                        <button onclick="saveProject(false)" class="header-btn" style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; padding: 0.4rem 0.75rem; color: white; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 0.3rem;">
                            <span></span>
                            <span>Save</span>
                        </button>
                        <div class="token-display">
                            <span class="token-icon"></span>
                            <span class="token-count">${state.tokens.balance}</span>
                            <span style="color: rgba(255,255,255,0.5)">tokens</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // ==========================================
        // 7.3 WIZARD HEADER
        // ==========================================
        function renderWizardHeader() {
            return `
                <div class="wizard-header">
                    <h1 class="wizard-title">Video Creation Wizard</h1>
                    <p class="wizard-subtitle">Create professional AI-generated videos from scratch</p>
                </div>
            `;
        }

        // ==========================================
        // 7.4 STEPPER
        // ==========================================
        function renderStepper() {
            let html = '<div class="wizard-stepper">';

            WIZARD_STEPS.forEach((step, index) => {
                const isActive = state.currentStep === step.num;
                const isCompleted = state.currentStep > step.num;
                const isReachable = step.num <= state.maxReachedStep + 1;

                html += `
                    <div class="wizard-step ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}"
                         onclick="${isReachable ? `goToStep(${step.num})` : ''}"
                         style="${!isReachable ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                        <div class="step-number">
                            ${isCompleted ? '' : step.num}
                        </div>
                        <span class="step-label">${step.label}</span>
                    </div>
                `;

                // Add connector between steps
                if (index < WIZARD_STEPS.length - 1) {
                    html += `<div class="step-connector ${isCompleted ? 'completed' : ''}"></div>`;
                }
            });

            html += '</div>';
            return html;
        }

        // ==========================================
        // 7.5 STEP 1: PLATFORM & FORMAT
        // ==========================================
        function renderStep1Platform() {
            const selectedPlatform = state.platform.selected;
            const preset = state.platform.preset;

            let html = '<div class="fade-in">';

            // Platform Selection Card
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Choose Platform</div>
                            <div class="content-card-subtitle">Where will your video be published?</div>
                        </div>
                    </div>

                    <div class="platform-grid">
            `;

            Object.values(PLATFORM_PRESETS).forEach(platform => {
                const isSelected = selectedPlatform === platform.id;
                html += `
                    <div class="platform-card ${isSelected ? 'selected' : ''}"
                         onclick="selectPlatform('${platform.id}')">
                        <div class="platform-card-icon">${platform.icon}</div>
                        <div class="platform-card-name">${platform.name}</div>
                        <div class="platform-card-info">${platform.description}</div>
                    </div>
                `;
            });

            html += '</div></div>';

            // Format Selection (only show if platform selected)
            if (preset) {
                html += `
                    <div class="content-card">
                        <div class="content-card-header">
                            <div class="content-card-icon"></div>
                            <div>
                                <div class="content-card-title">Select Format</div>
                                <div class="content-card-subtitle">Choose aspect ratio for your video</div>
                            </div>
                        </div>

                        <div class="format-selector">
                `;

                const allFormats = ['16:9', '9:16', '1:1', '4:5'];
                allFormats.forEach(format => {
                    const isAvailable = preset.formats.includes(format);
                    const isSelected = state.platform.aspectRatio === format;
                    const info = FORMAT_INFO[format];

                    html += `
                        <div class="format-option ${isSelected ? 'selected' : ''} ${!isAvailable ? 'disabled' : ''}"
                             onclick="${isAvailable ? `selectFormat('${format}')` : ''}">
                            <div class="format-preview">
                                <div class="format-preview-box ${info.className}"></div>
                            </div>
                            <div class="format-label">${info.ratio}</div>
                            <div class="format-desc">${info.desc}</div>
                        </div>
                    `;
                });

                html += '</div>';

                // Duration Slider
                html += `
                    <div class="duration-container">
                        <div class="duration-header">
                            <span class="duration-label">Video Duration</span>
                            <span class="duration-value">${formatDuration(state.platform.targetDuration)}</span>
                        </div>
                        <input type="range"
                               class="duration-slider"
                               id="duration-slider"
                               min="${preset.minDuration}"
                               max="${preset.maxDuration}"
                               value="${state.platform.targetDuration}"
                               oninput="setDuration(this.value)">
                        <div class="duration-presets">
                            <span class="duration-preset" onclick="setDuration(${preset.minDuration})">${formatDuration(preset.minDuration)}</span>
                            <span class="duration-preset" onclick="setDuration(${Math.floor((preset.minDuration + preset.maxDuration) / 2)})">${formatDuration(Math.floor((preset.minDuration + preset.maxDuration) / 2))}</span>
                            <span class="duration-preset" onclick="setDuration(${preset.maxDuration})">${formatDuration(preset.maxDuration)}</span>
                        </div>
                    </div>
                `;

                // Cost Estimate
                const cost = estimateCost();
                html += `
                    <div class="cost-estimate">
                        <div class="cost-estimate-header">
                            <span class="cost-estimate-title">Estimated Cost</span>
                            <span class="cost-estimate-value">~${cost.total} tokens</span>
                        </div>
                        <div class="cost-estimate-breakdown">
                            ${cost.sceneCount} scenes  Script ${cost.breakdown.script}  Images ${cost.breakdown.images}  Voice ${cost.breakdown.voiceover}  Animation ${cost.breakdown.animation}  Export ${cost.breakdown.export}
                        </div>
                    </div>
                `;

                html += '</div>';
            }

            // Navigation
            html += renderNavButtons(null, isStepComplete(1) ? 2 : null);

            html += '</div>';
            return html;
        }

        // ==========================================
        // 7.6 STEP 2: NICHE & STYLE
        // ==========================================
        function renderStep2NicheStyle() {
            const selectedNiche = state.content.niche;
            const selectedSubniche = state.content.subniche;
            const selectedStyle = state.content.style;

            let html = '<div class="fade-in">';

            // Niche Selection Card
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Select Your Niche</div>
                            <div class="content-card-subtitle">What category best describes your content?</div>
                        </div>
                    </div>

                    <div class="niche-grid">
            `;

            Object.values(VIDEO_NICHES).forEach(niche => {
                const isSelected = selectedNiche === niche.id;
                html += `
                    <div class="niche-card ${isSelected ? 'selected' : ''}"
                         onclick="selectNiche('${niche.id}')">
                        <div class="niche-icon">${niche.icon}</div>
                        <div class="niche-name">${niche.name}</div>
                    </div>
                `;
            });

            html += '</div>';

            // Sub-niche chips (if niche selected)
            if (selectedNiche && VIDEO_NICHES[selectedNiche]) {
                const niche = VIDEO_NICHES[selectedNiche];
                html += `
                    <div class="subniche-container">
                        <div style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-bottom: 0.75rem;">
                            Refine your focus (optional):
                        </div>
                        <div class="subniche-chips">
                `;

                niche.subniches.forEach(sub => {
                    const isSelected = selectedSubniche === sub.id;
                    html += `
                        <div class="subniche-chip ${isSelected ? 'selected' : ''}"
                             onclick="selectSubniche('${sub.id}')">
                            ${sub.name}
                        </div>
                    `;
                });

                html += '</div></div>';
            }

            html += '</div>';

            // Style Selection Card
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Choose Visual Style</div>
                            <div class="content-card-subtitle">How should your video look and feel?</div>
                        </div>
                    </div>

                    <div class="style-grid">
            `;

            Object.values(VIDEO_STYLES).forEach(style => {
                const isSelected = selectedStyle === style.id;
                html += `
                    <div class="style-card ${isSelected ? 'selected' : ''}"
                         onclick="selectStyle('${style.id}')">
                        <div class="style-icon">${style.icon}</div>
                        <div class="style-name">${style.name}</div>
                        <div class="style-desc">${style.description}</div>
                    </div>
                `;
            });

            html += '</div></div>';

            // Pacing Control Card (NEW - Controls video timing)
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Video Pacing</div>
                            <div class="content-card-subtitle">How fast should your video flow?</div>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 0.5rem;">
                        <div onclick="setPacing('fast')"
                             style="padding: 1rem; border-radius: 0.75rem; border: 2px solid ${state.content.pacing === 'fast' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${state.content.pacing === 'fast' ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;"></div>
                            <div style="font-weight: 600; color: white; margin-bottom: 0.25rem;">Fast</div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Quick cuts, dense narration<br>~8s per scene</div>
                        </div>
                        <div onclick="setPacing('medium')"
                             style="padding: 1rem; border-radius: 0.75rem; border: 2px solid ${state.content.pacing === 'medium' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${state.content.pacing === 'medium' ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;"></div>
                            <div style="font-weight: 600; color: white; margin-bottom: 0.25rem;">Balanced</div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Natural flow<br>~12s per scene</div>
                        </div>
                        <div onclick="setPacing('slow')"
                             style="padding: 1rem; border-radius: 0.75rem; border: 2px solid ${state.content.pacing === 'slow' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${state.content.pacing === 'slow' ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; cursor: pointer; text-align: center; transition: all 0.2s;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;"></div>
                            <div style="font-weight: 600; color: white; margin-bottom: 0.25rem;">Contemplative</div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Visual breathing room<br>~18s per scene</div>
                        </div>
                    </div>

                    <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.2);">
                        <div style="font-size: 0.75rem; color: #a78bfa;">
                             For your ${formatDuration(state.platform.targetDuration)} video:
                            <strong>${Math.round(state.platform.targetDuration / (state.content.pacing === 'fast' ? 8 : state.content.pacing === 'slow' ? 18 : 12))} scenes</strong>
                            with <strong>${state.content.pacing === 'fast' ? '85%' : state.content.pacing === 'slow' ? '50%' : '70%'}</strong> narration coverage
                        </div>
                    </div>
                </div>
            `;

            // Topic Input Card
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Video Topic (Optional)</div>
                            <div class="content-card-subtitle">Describe what your video should be about</div>
                        </div>
                    </div>

                    <div class="topic-input-container">
                        <input type="text"
                               class="topic-input"
                               id="topic-input"
                               placeholder="e.g., 5 habits of successful entrepreneurs"
                               value="${state.content.topic}"
                               onchange="setTopic(this.value)">
            `;

            // Topic suggestions based on niche
            if (selectedNiche && TOPIC_SUGGESTIONS[selectedNiche]) {
                html += '<div class="topic-suggestions">';
                TOPIC_SUGGESTIONS[selectedNiche].forEach(suggestion => {
                    html += `
                        <div class="topic-suggestion" onclick="applyTopicSuggestion('${suggestion}')">
                            ${suggestion}
                        </div>
                    `;
                });
                html += '</div>';
            }

            html += '</div></div>';

            // Navigation
            html += renderNavButtons(1, isStepComplete(2) ? 3 : null);

            html += '</div>';
            return html;
        }

        // ==========================================
        // 7.7 STEP 3: SCRIPT GENERATION
        // ==========================================
        function renderStep3Script() {
            const hasScript = state.script.scenes && state.script.scenes.length > 0;
            const isGenerating = state.script.status === 'generating';

            let html = '<div class="fade-in">';

            // If no script yet, show generation form
            if (!hasScript && !isGenerating) {
                html += renderScriptGenerationForm();
            }
            // If generating, show progress
            else if (isGenerating) {
                html += renderScriptGeneratingState();
            }
            // If script exists, show editor
            else {
                html += renderScriptEditor();
            }

            // Navigation
            html += renderNavButtons(2, hasScript ? 4 : null);

            html += '</div>';
            return html;
        }

        function renderScriptGenerationForm() {
            const niche = VIDEO_NICHES[state.content.niche];
            const style = VIDEO_STYLES[state.content.style];

            return `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Generate Your Script</div>
                            <div class="content-card-subtitle">AI will create a professional video script based on your settings</div>
                        </div>
                    </div>

                    <!-- Summary of selections -->
                    <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.75rem; padding: 1rem; margin-bottom: 1.5rem;">
                        <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Your video configuration:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            <span class="config-tag">${state.platform.selected || 'Platform'}</span>
                            <span class="config-tag">${state.platform.aspectRatio || '16:9'}</span>
                            <span class="config-tag">${formatDuration(state.platform.targetDuration)}</span>
                            <span class="config-tag">${niche?.icon || ''} ${niche?.name || 'Niche'}</span>
                            <span class="config-tag">${style?.icon || ''} ${style?.name || 'Style'}</span>
                        </div>
                    </div>

                    <!-- Topic (editable) -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Video Topic
                        </label>
                        <input type="text"
                               id="script-topic"
                               class="topic-input"
                               value="${state.content.topic || ''}"
                               placeholder="e.g., 5 Morning Habits That Changed My Life"
                               style="width: 100%;">
                    </div>

                    <!-- Tone selector -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Script Tone
                        </label>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                            ${['engaging', 'professional', 'casual', 'inspirational'].map(tone => `
                                <button onclick="setScriptTone('${tone}')"
                                        class="tone-btn ${state.content.tone === tone ? 'selected' : ''}"
                                        style="padding: 0.6rem; border-radius: 0.5rem; border: 1px solid ${state.content.tone === tone ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.2)'}; background: ${state.content.tone === tone ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; color: white; cursor: pointer; font-size: 0.8rem; text-transform: capitalize;">
                                    ${tone}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Content depth selector -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Content Depth
                            <span style="color: rgba(255,255,255,0.5); font-weight: 400; font-size: 0.8rem;">  How much detail in the narration</span>
                        </label>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                            ${[
                                { id: 'minimal', label: ' Quick', desc: 'Key points only' },
                                { id: 'standard', label: ' Standard', desc: 'Balanced content' },
                                { id: 'detailed', label: ' Detailed', desc: 'Examples & stats' },
                                { id: 'comprehensive', label: ' Deep Dive', desc: 'Full analysis' }
                            ].map(depth => `
                                <button onclick="setContentDepth('${depth.id}')"
                                        title="${depth.desc}"
                                        style="padding: 0.6rem 0.4rem; border-radius: 0.5rem; border: 1px solid ${state.content.contentDepth === depth.id ? 'rgba(6, 182, 212, 0.6)' : 'rgba(255,255,255,0.2)'}; background: ${state.content.contentDepth === depth.id ? 'rgba(6, 182, 212, 0.2)' : 'rgba(255,255,255,0.05)'}; color: white; cursor: pointer; font-size: 0.75rem; display: flex; flex-direction: column; align-items: center; gap: 0.2rem;">
                                    <span style="font-size: 0.85rem;">${depth.label}</span>
                                    <span style="font-size: 0.65rem; color: rgba(255,255,255,0.5);">${depth.desc}</span>
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Additional instructions -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                            Additional Instructions <span style="color: rgba(255,255,255,0.5); font-weight: 400;">(optional)</span>
                        </label>
                        <textarea id="script-instructions"
                                  placeholder="Any specific requirements? e.g., Include a personal story, mention specific products, focus on beginners..."
                                  style="width: 100%; min-height: 80px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem; resize: vertical;"></textarea>
                    </div>

                    <!-- Generate button -->
                    <button onclick="generateScript()"
                            class="generate-btn"
                            style="width: 100%; padding: 1rem; border-radius: 0.75rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-size: 1rem; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span></span>
                        <span>Generate Script with AI</span>
                    </button>

                    <div style="text-align: center; margin-top: 1rem; color: rgba(255,255,255,0.5); font-size: 0.8rem;">
                        Estimated cost: ~5 tokens  Powered by GPT-4o
                    </div>
                </div>
            `;
        }

        function renderScriptGeneratingState() {
            return `
                <div class="content-card" style="text-align: center; padding: 4rem 2rem;">
                    <div class="animate-float" style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                    <div style="font-size: 1.25rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Generating Your Script...
                    </div>
                    <div style="color: rgba(255,255,255,0.6); margin-bottom: 2rem;">
                        AI is crafting an engaging script for your video
                    </div>
                    <div class="loading-bar" style="width: 200px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin: 0 auto; overflow: hidden;">
                        <div style="width: 30%; height: 100%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); border-radius: 2px; animation: shimmer 1.5s infinite;"></div>
                    </div>
                </div>
            `;
        }

        function renderScriptEditor() {
            const script = state.script;

            // Calculate timing breakdown
            const targetDuration = state.platform.targetDuration || 60;
            const totalVisualDuration = script.scenes.reduce((sum, s) => sum + (s.visualDuration || s.duration || 0), 0);
            const totalNarrationDuration = script.scenes.reduce((sum, s) => sum + (s.narrationDuration || Math.ceil((s.narration || '').split(/\s+/).length / 2.5) || 0), 0);
            const pacing = script.timing?.pacing || state.content.pacing || 'medium';

            let html = `
                <!-- Script Header -->
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div style="flex: 1;">
                            <input type="text"
                                   id="script-title-input"
                                   value="${script.title || ''}"
                                   onchange="updateScriptTitle(this.value)"
                                   style="background: none; border: none; color: white; font-size: 1.1rem; font-weight: 700; width: 100%; outline: none;">
                            <div class="content-card-subtitle">${script.scenes.length} scenes  Target: ${formatDuration(targetDuration)}</div>
                        </div>
                        <button onclick="regenerateFullScript()"
                                style="background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; padding: 0.5rem 1rem; color: white; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 0.3rem;">
                            <span></span> Regenerate
                        </button>
                    </div>

                    <!-- Timing Breakdown Banner -->
                    <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.5rem; padding: 0.75rem 1rem; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                        <div style="display: flex; gap: 1.5rem; flex-wrap: wrap;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); text-transform: uppercase;">Visual Time</div>
                                <div style="font-size: 1rem; font-weight: 700; color: #10b981;">${formatDuration(totalVisualDuration)}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); text-transform: uppercase;">Narration</div>
                                <div style="font-size: 1rem; font-weight: 700; color: #a78bfa;">${formatDuration(totalNarrationDuration)}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); text-transform: uppercase;">Per Scene</div>
                                <div style="font-size: 1rem; font-weight: 700; color: white;">~${Math.round(totalVisualDuration / script.scenes.length)}s</div>
                            </div>
                        </div>
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); display: flex; align-items: center; gap: 0.3rem;">
                            <span></span> ${pacing.charAt(0).toUpperCase() + pacing.slice(1)} pacing
                        </div>
                    </div>

                    <!-- Hook -->
                    <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.75rem; padding: 1rem; margin-bottom: 1rem;">
                        <div style="font-size: 0.75rem; color: #10b981; font-weight: 600; margin-bottom: 0.5rem;"> HOOK</div>
                        <input type="text"
                               value="${script.hook || ''}"
                               onchange="updateScriptHook(this.value)"
                               style="width: 100%; background: none; border: none; color: white; font-size: 0.95rem; outline: none;">
                    </div>

                    <!-- Metadata -->
                    ${script.metadata ? `
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-bottom: 1rem;">
                            <div style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 0.75rem;">
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Target Audience</div>
                                <div style="font-size: 0.85rem; color: white;">${script.metadata.targetAudience || '-'}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 0.75rem;">
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Key Message</div>
                                <div style="font-size: 0.85rem; color: white;">${script.metadata.keyMessage || '-'}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.05); border-radius: 0.5rem; padding: 0.75rem;">
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Suggested Music</div>
                                <div style="font-size: 0.85rem; color: white;">${script.metadata.suggestedMusic || '-'}</div>
                            </div>
                        </div>
                    ` : ''}
                </div>

                <!-- Scenes -->
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div>
                            <div class="content-card-title">Scenes</div>
                            <div class="content-card-subtitle">Edit narration and visuals for each scene</div>
                        </div>
                        <button onclick="addNewScene()"
                                style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; padding: 0.5rem 1rem; color: white; cursor: pointer; font-size: 0.8rem;">
                            + Add Scene
                        </button>
                    </div>

                    <div class="scenes-list" style="display: flex; flex-direction: column; gap: 1rem;">
            `;

            // Render each scene
            script.scenes.forEach((scene, index) => {
                html += renderSceneCard(scene, index);
            });

            html += `
                    </div>
                </div>

                <!-- CTA -->
                <div class="content-card">
                    <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.75rem; padding: 1rem;">
                        <div style="font-size: 0.75rem; color: #ef4444; font-weight: 600; margin-bottom: 0.5rem;"> CALL TO ACTION</div>
                        <input type="text"
                               value="${script.cta || ''}"
                               onchange="updateScriptCTA(this.value)"
                               style="width: 100%; background: none; border: none; color: white; font-size: 0.95rem; outline: none;">
                    </div>
                </div>
            `;

            return html;
        }

        function renderSceneCard(scene, index) {
            const isExpanded = state.script.expandedScene === scene.id;

            return `
                <div class="scene-card" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.75rem; overflow: hidden;">
                    <!-- Scene Header -->
                    <div onclick="toggleSceneExpand(${scene.id})"
                         style="padding: 1rem; cursor: pointer; display: flex; align-items: center; gap: 1rem; border-bottom: ${isExpanded ? '1px solid rgba(255,255,255,0.1)' : 'none'};">
                        <div style="width: 2rem; height: 2rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.85rem;">
                            ${index + 1}
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="color: white; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${scene.narration?.substring(0, 60) || 'No narration'}${scene.narration?.length > 60 ? '...' : ''}
                            </div>
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.75rem;">
                                ${scene.duration}s  ${scene.transition || 'cut'}
                            </div>
                        </div>
                        <div style="color: rgba(255,255,255,0.5); transform: rotate(${isExpanded ? '180deg' : '0deg'}); transition: transform 0.2s;"></div>
                    </div>

                    ${isExpanded ? `
                        <!-- Expanded Content -->
                        <div style="padding: 1rem;">
                            <!-- Narration -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;"> Narration</label>
                                <textarea id="scene-narration-${scene.id}"
                                          onchange="updateSceneNarration(${scene.id}, this.value)"
                                          style="width: 100%; min-height: 60px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem; resize: vertical;">${scene.narration || ''}</textarea>
                            </div>

                            <!-- Visual Description -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;"> Visual Description (for AI image generation)</label>
                                <textarea id="scene-visual-${scene.id}"
                                          onchange="updateSceneVisual(${scene.id}, this.value)"
                                          style="width: 100%; min-height: 80px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem; resize: vertical;">${scene.visual || ''}</textarea>
                            </div>

                            <!-- Duration & Transition -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div>
                                    <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;"> Duration (seconds)</label>
                                    <input type="number"
                                           value="${scene.duration || 8}"
                                           min="3" max="30"
                                           onchange="updateSceneDuration(${scene.id}, this.value)"
                                           style="width: 100%; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white;">
                                </div>
                                <div>
                                    <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;"> Transition</label>
                                    <select onchange="updateSceneTransition(${scene.id}, this.value)"
                                            style="width: 100%; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white;">
                                        ${['cut', 'fade', 'zoom', 'slide'].map(t => `
                                            <option value="${t}" ${scene.transition === t ? 'selected' : ''}>${t.charAt(0).toUpperCase() + t.slice(1)}</option>
                                        `).join('')}
                                    </select>
                                </div>
                            </div>

                            <!-- Scene Actions -->
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                <button onclick="regenerateScene(${scene.id})"
                                        style="flex: 1; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.4); background: rgba(139, 92, 246, 0.1); color: white; cursor: pointer; font-size: 0.8rem;">
                                     Regenerate
                                </button>
                                <button onclick="moveSceneUp(${scene.id})"
                                        ${index === 0 ? 'disabled' : ''}
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; opacity: ${index === 0 ? '0.5' : '1'};">
                                    
                                </button>
                                <button onclick="moveSceneDown(${scene.id})"
                                        ${index === state.script.scenes.length - 1 ? 'disabled' : ''}
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; opacity: ${index === state.script.scenes.length - 1 ? '0.5' : '1'};">
                                    
                                </button>
                                <button onclick="deleteScene(${scene.id})"
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(239, 68, 68, 0.4); background: rgba(239, 68, 68, 0.1); color: #ef4444; cursor: pointer;">
                                    
                                </button>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // ==========================================
        // 7.8 STEP 4: STORYBOARD
        // ==========================================
        function renderStep4Storyboard() {
            const scenes = state.script.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];

            // Check if we need to auto-generate
            if (scenes.length > 0 && storyboardScenes.length === 0 && state.storyboard.status !== 'generating') {
                // Trigger auto-generation on first visit
                setTimeout(() => generateInitialStoryboard(), 100);
            }

            let html = '<div class="fade-in">';

            // Header with Model Selector
            const currentModel = state.storyboard.imageModel || 'hidream';
            const modelConfig = IMAGE_MODELS[currentModel] || IMAGE_MODELS['hidream'];

            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div style="flex: 1;">
                            <div class="content-card-title">Storyboard</div>
                            <div class="content-card-subtitle">Visual preview of each scene  ${storyboardScenes.filter(s => s.imageUrl && s.status === 'ready').length}/${scenes.length} images ready</div>
                        </div>
                    </div>

                    <!-- AI Model Selector -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="color: rgba(255,255,255,0.7); font-size: 0.75rem; margin-bottom: 0.5rem;"> AI Model for Image Generation:</div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${Object.entries(IMAGE_MODELS).map(([id, model]) => `
                                <button onclick="setImageModel('${id}')"
                                        style="padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid ${currentModel === id ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; background: ${currentModel === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; color: ${currentModel === id ? 'white' : 'rgba(255,255,255,0.7)'}; cursor: pointer; font-size: 0.75rem; display: flex; flex-direction: column; align-items: center; gap: 0.15rem; transition: all 0.2s;">
                                    <span style="font-weight: 600;">${model.name}</span>
                                    <span style="font-size: 0.65rem; color: ${currentModel === id ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.5)'};">${model.tokenCost} token${model.tokenCost > 1 ? 's' : ''}</span>
                                </button>
                            `).join('')}
                        </div>
                        <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-top: 0.5rem;">
                            ${modelConfig.description}
                        </div>
                    </div>
                </div>
            `;

            // Storyboard Grid
            html += `<div class="storyboard-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem; margin-top: 1rem;">`;

            scenes.forEach((scene, index) => {
                const storyboardScene = storyboardScenes.find(s => s.sceneId === scene.id) || {};
                html += renderStoryboardCard(scene, storyboardScene, index);
            });

            html += `</div>`;

            // Navigation
            const hasAllImages = storyboardScenes.filter(s => s.status === 'ready').length >= scenes.length;
            html += renderNavButtons(3, hasAllImages ? 5 : null);

            html += '</div>';

            // Modify Modal (rendered outside main flow)
            if (state.storyboard.modifyingScene) {
                html += renderModifyModal();
            }

            return html;
        }

        function renderStoryboardCard(scene, storyboardScene, index) {
            const status = storyboardScene.status || 'pending';
            const imageUrl = storyboardScene.imageUrl;
            const prompt = storyboardScene.prompt || scene.visual || '';

            let cardContent = '';

            if (status === 'pending') {
                // Empty state - needs generation (show both AI and Stock options)
                cardContent = `
                    <div style="height: 160px; background: rgba(255,255,255,0.03); border: 2px dashed rgba(255,255,255,0.2); border-radius: 0.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem;">
                        <div style="color: rgba(255,255,255,0.6); font-size: 0.75rem; margin-bottom: 0.75rem;">Choose image source:</div>
                        <div style="display: flex; gap: 0.5rem; width: 100%;">
                            <button onclick="generateSingleSceneImage(${scene.id})"
                                    style="flex: 1; padding: 0.6rem 0.5rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(6, 182, 212, 0.3)); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.25rem;">
                                <span style="font-size: 1.1rem;"></span>
                                <span>AI Generate</span>
                                <span style="font-size: 0.6rem; color: rgba(255,255,255,0.5);">2 tokens</span>
                            </button>
                            <button onclick="openStockBrowser(${scene.id})"
                                    style="flex: 1; padding: 0.6rem 0.5rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.25rem;">
                                <span style="font-size: 1.1rem;"></span>
                                <span>Stock Media</span>
                                <span style="font-size: 0.6rem; color: rgba(16, 185, 129, 0.8);">FREE</span>
                            </button>
                        </div>
                    </div>
                `;
            } else if (status === 'generating') {
                // Loading state
                cardContent = `
                    <div style="height: 160px; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(139,92,246,0.3); border-top-color: #8b5cf6; border-radius: 50%; margin-bottom: 0.75rem;"></div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 0.8rem;">Generating...</div>
                    </div>
                `;
            } else if (status === 'ready' && imageUrl) {
                // Image ready
                const isVideo = storyboardScene.source === 'stock-video';
                const sourceLabel = storyboardScene.source === 'stock' ? ' Stock' :
                                   isVideo ? ' Video' : ' AI';
                const sourceBgColor = storyboardScene.source === 'stock' ? 'rgba(16, 185, 129, 0.9)' :
                                     isVideo ? 'rgba(6, 182, 212, 0.9)' : 'rgba(139, 92, 246, 0.9)';
                // Get fallback thumbnail URL if available
                const fallbackUrl = storyboardScene.stockInfo?.thumbnailFallback || '';
                // Get clip duration for videos
                const clipDuration = storyboardScene.stockInfo?.clipDuration || storyboardScene.stockInfo?.duration;

                cardContent = `
                    <div style="height: 160px; border-radius: 0.5rem; overflow: hidden; position: relative; background: rgba(0,0,0,0.3);">
                        <img src="${imageUrl}"
                             alt="Scene ${index + 1}"
                             style="width: 100%; height: 100%; object-fit: cover;"
                             data-scene-id="${scene.id}"
                             data-retry-count="0"
                             onload="this.dataset.loaded='true';"
                             onerror="
                                this.onerror=null;
                                ${fallbackUrl ? `this.src='${fallbackUrl}';` : `
                                    // For AI images, retry a few times with cache-busting before showing placeholder
                                    const retryCount = parseInt(this.dataset.retryCount || '0');
                                    if (retryCount < 3) {
                                        this.dataset.retryCount = retryCount + 1;
                                        setTimeout(() => {
                                            const url = this.src.split('&t=')[0].split('?t=')[0];
                                            this.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
                                            this.onerror = function() {
                                                this.style.display='none';
                                                this.parentElement.querySelector('.placeholder-retry').style.display='flex';
                                            };
                                        }, 2000);
                                    } else {
                                        this.style.display='none';
                                        this.parentElement.querySelector('.placeholder-retry').style.display='flex';
                                    }
                                `}">
                        <!-- Placeholder with retry option if image fails after retries -->
                        <div class="placeholder-retry" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); gap: 0.5rem;">
                            <span style="font-size: 1.5rem;">${isVideo ? '' : ''}</span>
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.7);">Image not available</span>
                            <button onclick="regenerateSingleSceneImage(${scene.id})" style="padding: 0.3rem 0.6rem; border-radius: 0.3rem; border: 1px solid rgba(139,92,246,0.5); background: rgba(139,92,246,0.3); color: white; cursor: pointer; font-size: 0.65rem;">
                                 Regenerate
                            </button>
                        </div>
                        ${isVideo ? `
                            <!-- Video play icon overlay -->
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 36px; height: 36px; background: rgba(0,0,0,0.6); border-radius: 50%; display: flex; align-items: center; justify-content: center; pointer-events: none;">
                                <div style="width: 0; height: 0; border-left: 10px solid white; border-top: 6px solid transparent; border-bottom: 6px solid transparent; margin-left: 2px;"></div>
                            </div>
                            ${clipDuration ? `
                                <!-- Duration badge -->
                                <div style="position: absolute; bottom: 2.5rem; right: 0.4rem; background: rgba(0,0,0,0.8); color: white; padding: 0.15rem 0.35rem; border-radius: 0.2rem; font-size: 0.6rem;">
                                    ${formatDuration(clipDuration)}
                                </div>
                            ` : ''}
                        ` : ''}
                        <!-- Source badge -->
                        <div style="position: absolute; top: 0.5rem; right: 0.5rem; background: ${sourceBgColor}; color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.6rem;">
                            ${sourceLabel}
                        </div>
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 0.5rem; display: flex; gap: 0.3rem;">
                            <button onclick="openEditModal(${scene.id})" style="flex: 1; padding: 0.35rem; border-radius: 0.4rem; border: 1px solid rgba(236, 72, 153, 0.5); background: linear-gradient(135deg, rgba(236, 72, 153, 0.3), rgba(139, 92, 246, 0.3)); color: white; cursor: pointer; font-size: 0.65rem;" title="Edit with AI">
                                 Edit
                            </button>
                            <button onclick="openModifyModal(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.3); background: rgba(0,0,0,0.5); color: white; cursor: pointer; font-size: 0.65rem;" title="Modify prompt">
                                
                            </button>
                            <button onclick="openStockBrowser(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(16, 185, 129, 0.5); background: rgba(16, 185, 129, 0.2); color: white; cursor: pointer; font-size: 0.65rem;" title="Browse stock media">
                                
                            </button>
                            <button onclick="regenerateSingleSceneImage(${scene.id})" style="padding: 0.35rem 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.3); background: rgba(0,0,0,0.5); color: white; cursor: pointer; font-size: 0.65rem;" title="Regenerate with AI">
                                
                            </button>
                        </div>
                    </div>
                `;
            } else if (status === 'error') {
                // Error state - show both retry options
                const errorMsg = storyboardScene.error || 'Generation failed';
                cardContent = `
                    <div style="height: 160px; background: rgba(239, 68, 68, 0.05); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.75rem;">
                            <span style="font-size: 1rem;"></span>
                            <span style="color: #ef4444; font-size: 0.75rem;">${errorMsg.substring(0, 40)}${errorMsg.length > 40 ? '...' : ''}</span>
                        </div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 0.7rem; margin-bottom: 0.5rem;">Choose to retry:</div>
                        <div style="display: flex; gap: 0.5rem; width: 100%;">
                            <button onclick="generateSingleSceneImage(${scene.id})"
                                    style="flex: 1; padding: 0.5rem 0.4rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(6, 182, 212, 0.3)); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.2rem;">
                                <span style="font-size: 1rem;"></span>
                                <span>Retry AI</span>
                            </button>
                            <button onclick="openStockBrowser(${scene.id})"
                                    style="flex: 1; padding: 0.5rem 0.4rem; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 0.5rem; color: white; cursor: pointer; font-size: 0.7rem; display: flex; flex-direction: column; align-items: center; gap: 0.2rem;">
                                <span style="font-size: 1rem;"></span>
                                <span>Use Stock</span>
                            </button>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="storyboard-card" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.75rem; overflow: hidden;">
                    <!-- Scene number badge -->
                    <div style="position: relative;">
                        <div style="position: absolute; top: 0.5rem; left: 0.5rem; background: rgba(0,0,0,0.7); color: white; padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem; font-weight: 600; z-index: 1;">
                            Scene ${index + 1}
                        </div>
                        ${cardContent}
                    </div>

                    <!-- Prompt -->
                    <div style="padding: 0.75rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.25rem;">PROMPT</div>
                        <div style="font-size: 0.8rem; color: rgba(255,255,255,0.8); line-height: 1.4; max-height: 3.6em; overflow: hidden; text-overflow: ellipsis;">
                            ${prompt.substring(0, 120)}${prompt.length > 120 ? '...' : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderModifyModal() {
            const sceneId = state.storyboard.modifyingScene;
            const scene = state.script.scenes.find(s => s.id === sceneId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId) || {};

            if (!scene) return '';

            const currentPrompt = state.storyboard.modifyPrompt || storyboardScene.prompt || scene.visual || '';

            return `
                <div id="modify-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 1rem;" onclick="if(event.target.id === 'modify-modal') closeModifyModal()">
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 1rem; width: 100%; max-width: 700px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                        <!-- Header -->
                        <div style="padding: 1.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: white;"> Modify Scene ${scene.id}</div>
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">Customize the image generation</div>
                            </div>
                            <button onclick="closeModifyModal()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem;"></button>
                        </div>

                        <!-- Content -->
                        <div style="padding: 1.25rem; overflow-y: auto; flex: 1;">
                            <!-- Current Image Preview -->
                            ${storyboardScene.imageUrl ? `
                                <div style="margin-bottom: 1.25rem;">
                                    <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Current Image</div>
                                    <img src="${storyboardScene.imageUrl}" alt="Current" style="width: 100%; max-height: 200px; object-fit: cover; border-radius: 0.5rem;">
                                </div>
                            ` : ''}

                            <!-- Prompt Editor -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Image Prompt
                                </label>
                                <textarea id="modify-prompt-input"
                                          style="width: 100%; min-height: 100px; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; font-size: 0.9rem; resize: vertical;"
                                          placeholder="Describe what you want to see...">${currentPrompt}</textarea>
                            </div>

                            <!-- Style Selector -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Style
                                </label>
                                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
                                    ${['cinematic', 'modern', 'retro', 'cartoon', 'dark'].map(styleOpt => `
                                        <button onclick="setModifyStyle('${styleOpt}')"
                                                style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${state.storyboard.modifyStyle === styleOpt ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.2)'}; background: ${state.storyboard.modifyStyle === styleOpt ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)'}; color: white; cursor: pointer; font-size: 0.75rem; text-transform: capitalize;">
                                            ${styleOpt}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Camera/Composition -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Camera Shot
                                </label>
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                                    ${['wide shot', 'medium shot', 'close-up', 'aerial'].map(shot => `
                                        <button onclick="appendToModifyPrompt('${shot}')"
                                                style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; text-transform: capitalize;">
                                            ${shot}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Lighting -->
                            <div style="margin-bottom: 1.25rem;">
                                <label style="display: block; font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.5rem;">
                                    Lighting
                                </label>
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
                                    ${['golden hour', 'dramatic', 'soft light', 'neon'].map(light => `
                                        <button onclick="appendToModifyPrompt('${light} lighting')"
                                                style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; text-transform: capitalize;">
                                            ${light}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                        </div>

                        <!-- Footer -->
                        <div style="padding: 1.25rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 0.75rem;">
                            <button onclick="closeModifyModal()"
                                    style="flex: 1; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-weight: 600;">
                                Cancel
                            </button>
                            <button onclick="applyModifyAndGenerate()"
                                    style="flex: 2; padding: 0.75rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; cursor: pointer; font-weight: 700; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                <span></span>
                                <span>Generate New Image</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // ==========================================
        // 7.9 STEP 5: ANIMATION
        // ==========================================
        function renderStep5Animation() {
            const storyboardScenes = state.storyboard.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const scriptScenes = state.script.scenes || [];

            // Initialize animation scenes if needed
            if (animationScenes.length === 0 && storyboardScenes.length > 0) {
                initializeAnimationScenes();
            }

            // Calculate scene readiness stats
            const voiceoversReady = animationScenes.filter(s => s.voiceoverUrl).length;
            const animatedScenes = animationScenes.filter(s => s.videoUrl).length;
            const stockVideoScenes = storyboardScenes.filter(s => s.source === 'stock-video' && s.videoUrl).length;
            const staticImageScenes = storyboardScenes.filter(s => s.imageUrl && s.source !== 'stock-video').length;

            // A scene is ready if it has voiceover AND (animated OR stock-video OR image)
            const readyScenes = storyboardScenes.filter(sb => {
                const anim = animationScenes.find(a => a.sceneId === sb.sceneId);
                const hasVoiceover = anim?.voiceoverUrl;
                const hasVisual = anim?.videoUrl || (sb.source === 'stock-video' && sb.videoUrl) || sb.imageUrl;
                return hasVoiceover && hasVisual;
            }).length;

            let html = '<div class="fade-in">';

            // Header with global settings
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div style="flex: 1;">
                            <div class="content-card-title">Animation Studio</div>
                            <div class="content-card-subtitle">Generate voiceovers and optionally animate scenes  ${readyScenes}/${storyboardScenes.length} ready</div>
                        </div>
                    </div>

                    <!-- Progress Stats -->
                    <div style="display: flex; gap: 1rem; margin-top: 0.75rem; flex-wrap: wrap;">
                        <div style="background: rgba(139, 92, 246, 0.15); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
                            <span style="color: #a78bfa;"> Voiceovers:</span>
                            <span style="color: ${voiceoversReady >= storyboardScenes.length ? '#10b981' : 'white'}; font-weight: 600;">${voiceoversReady}/${storyboardScenes.length}</span>
                        </div>
                        <div style="background: rgba(6, 182, 212, 0.15); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
                            <span style="color: #06b6d4;"> Animated:</span>
                            <span style="color: white; font-weight: 600;">${animatedScenes}</span>
                            <span style="color: rgba(255,255,255,0.5);">(optional)</span>
                        </div>
                        <div style="background: rgba(16, 185, 129, 0.15); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
                            <span style="color: #10b981;"> Stock Videos:</span>
                            <span style="color: white; font-weight: 600;">${stockVideoScenes}</span>
                        </div>
                        <div style="background: rgba(251, 191, 36, 0.15); padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.75rem;">
                            <span style="color: #fbbf24;"> Static Images:</span>
                            <span style="color: white; font-weight: 600;">${staticImageScenes - animatedScenes}</span>
                        </div>
                    </div>

                    <!-- Info Banner -->
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 0.5rem; padding: 0.75rem; margin-top: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                         <strong>Animation is optional!</strong> Scenes with static images will display for the correct duration. Stock videos play as-is. Only animate if you want Ken Burns zoom/pan effects.
                    </div>

                    <!-- Global Voice Settings -->
                    <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.75rem; padding: 1rem; margin-top: 1rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem;"> Global Voice Settings</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Voice</label>
                                <select id="global-voice-select" onchange="setGlobalVoice(this.value)"
                                        style="width: 100%; padding: 0.6rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white; font-size: 0.85rem;">
                                    ${['alloy', 'nova', 'shimmer', 'echo', 'onyx', 'fable'].map(v => `
                                        <option value="${v}" ${state.animation.voiceover.voice === v ? 'selected' : ''}>${v.charAt(0).toUpperCase() + v.slice(1)}</option>
                                    `).join('')}
                                </select>
                            </div>
                            <div>
                                <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Speed: ${state.animation.voiceover.speed.toFixed(1)}x</label>
                                <input type="range" min="0.5" max="2.0" step="0.1" value="${state.animation.voiceover.speed}"
                                       onchange="setGlobalSpeed(this.value)"
                                       style="width: 100%; height: 6px; cursor: pointer;">
                            </div>
                        </div>
                        <div style="margin-top: 1rem; display: flex; gap: 0.75rem;">
                            <button onclick="generateAllVoiceovers()"
                                    style="flex: 1; padding: 0.75rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #a855f7); color: white; cursor: pointer; font-weight: 600; font-size: 0.85rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                <span></span> Generate All Voiceovers
                            </button>
                            <button onclick="animateAllScenes()"
                                    ${voiceoversReady < storyboardScenes.length ? 'disabled' : ''}
                                    style="flex: 1; padding: 0.75rem; border-radius: 0.5rem; border: none; background: ${voiceoversReady >= storyboardScenes.length ? 'linear-gradient(135deg, #06b6d4, #10b981)' : 'rgba(255,255,255,0.1)'}; color: ${voiceoversReady >= storyboardScenes.length ? 'white' : 'rgba(255,255,255,0.4)'}; cursor: ${voiceoversReady >= storyboardScenes.length ? 'pointer' : 'not-allowed'}; font-weight: 600; font-size: 0.85rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                <span></span> Animate All (Optional)
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // Animation Scene Cards
            html += `<div style="display: grid; gap: 1rem; margin-top: 1rem;">`;

            scriptScenes.forEach((scriptScene, index) => {
                const storyboardScene = storyboardScenes.find(s => s.sceneId === scriptScene.id) || {};
                const animScene = animationScenes.find(s => s.sceneId === scriptScene.id) || {};
                html += renderAnimationSceneCard(scriptScene, storyboardScene, animScene, index);
            });

            html += `</div>`;

            // Navigation - Check if scenes are ready for assembly
            // A scene is ready if it has: voiceover + visual (animated video, stock video, OR static image)
            const allScenesReady = storyboardScenes.every(storyboardScene => {
                const animScene = animationScenes.find(a => a.sceneId === storyboardScene.sceneId) || {};

                // Must have voiceover
                const hasVoiceover = !!animScene.voiceoverUrl;

                // Must have visual: animated video, stock video, or at least a static image
                const hasAnimatedVideo = !!animScene.videoUrl;
                const hasStockVideo = storyboardScene.source === 'stock-video' && storyboardScene.videoUrl;
                const hasImage = !!storyboardScene.imageUrl;

                return hasVoiceover && (hasAnimatedVideo || hasStockVideo || hasImage);
            });

            html += renderNavButtons(4, allScenesReady ? 6 : null);

            html += '</div>';
            return html;
        }

        function initializeAnimationScenes() {
            const storyboardScenes = state.storyboard.scenes || [];
            const scriptScenes = state.script.scenes || [];

            state.animation.scenes = scriptScenes.map(scene => ({
                sceneId: scene.id,
                voiceoverStatus: 'idle',
                voiceoverUrl: null,
                animationStatus: 'idle',
                videoUrl: null,
                voice: state.animation.voiceover.voice,
                speed: state.animation.voiceover.speed,
                animationType: 'ken_burns',
                jobId: null
            }));
            saveProject();
        }

        function renderAnimationSceneCard(scriptScene, storyboardScene, animScene, index) {
            const imageUrl = storyboardScene.imageUrl;
            const voiceoverStatus = animScene.voiceoverStatus || 'idle';
            const voiceoverUrl = animScene.voiceoverUrl;
            const animationStatus = animScene.animationStatus || 'idle';
            const videoUrl = animScene.videoUrl;
            const animationType = animScene.animationType || 'ken_burns';

            return `
                <div class="content-card" style="padding: 0; overflow: hidden;">
                    <div style="display: grid; grid-template-columns: 200px 1fr; gap: 0;">
                        <!-- Left: Image/Video Preview -->
                        <div style="position: relative; background: rgba(0,0,0,0.3);">
                            ${videoUrl ? `
                                <video id="animation-video-${scriptScene.id}" src="${videoUrl}" style="width: 100%; height: 180px; object-fit: cover;"></video>
                                <div style="position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); cursor: pointer;" onclick="playAnimationPreview(${scriptScene.id}, '${videoUrl}')">
                                    <div style="width: 3rem; height: 3rem; background: rgba(16, 185, 129, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 0.5rem;">
                                        <span style="font-size: 1.5rem; margin-left: 0.2rem;"></span>
                                    </div>
                                    <span style="font-size: 0.7rem; color: white; font-weight: 600;">Click to Preview</span>
                                </div>
                                <div style="position: absolute; top: 0.5rem; right: 0.5rem; background: rgba(16, 185, 129, 0.9); padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.65rem; font-weight: 600;">
                                     ANIMATED
                                </div>
                            ` : imageUrl ? `
                                <img src="${imageUrl}" alt="Scene ${index + 1}" style="width: 100%; height: 180px; object-fit: cover;">
                                ${animationStatus === 'generating' ? `
                                    <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center;">
                                        <div class="animate-spin" style="width: 2rem; height: 2rem; border: 3px solid rgba(6,182,212,0.3); border-top-color: #06b6d4; border-radius: 50%; margin-bottom: 0.5rem;"></div>
                                        <div style="color: white; font-size: 0.75rem;">Animating...</div>
                                    </div>
                                ` : ''}
                            ` : `
                                <div style="width: 100%; height: 180px; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.4);">
                                    No Image
                                </div>
                            `}
                            <div style="position: absolute; top: 0.5rem; left: 0.5rem; width: 1.75rem; height: 1.75rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.75rem;">
                                ${index + 1}
                            </div>
                        </div>

                        <!-- Right: Controls -->
                        <div style="padding: 1rem;">
                            <!-- Narration Preview -->
                            <div style="font-size: 0.85rem; color: rgba(255,255,255,0.8); margin-bottom: 0.75rem; line-height: 1.4; max-height: 2.8em; overflow: hidden; text-overflow: ellipsis;">
                                "${scriptScene.narration?.substring(0, 100) || 'No narration'}${scriptScene.narration?.length > 100 ? '...' : ''}"
                            </div>

                            <!-- Voiceover Section -->
                            <div style="margin-bottom: 0.75rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> Voiceover:</span>
                                    ${voiceoverStatus === 'idle' ? `
                                        <span style="font-size: 0.7rem; color: rgba(255,255,255,0.4);">Not generated</span>
                                    ` : voiceoverStatus === 'generating' ? `
                                        <span style="font-size: 0.7rem; color: #a855f7;" class="animate-pulse">Generating...</span>
                                    ` : voiceoverStatus === 'ready' ? `
                                        <span style="font-size: 0.7rem; color: #10b981;"> Ready</span>
                                    ` : `
                                        <span style="font-size: 0.7rem; color: #ef4444;">Error</span>
                                    `}
                                </div>
                                ${voiceoverUrl ? `
                                    <audio src="${voiceoverUrl}" controls style="width: 100%; height: 28px; margin-bottom: 0.5rem;"></audio>
                                ` : ''}
                                <div style="display: flex; gap: 0.5rem;">
                                    <button onclick="generateSceneVoiceover(${scriptScene.id})"
                                            ${voiceoverStatus === 'generating' ? 'disabled' : ''}
                                            style="flex: 1; padding: 0.4rem 0.6rem; border-radius: 0.4rem; border: 1px solid rgba(139, 92, 246, 0.4); background: rgba(139, 92, 246, 0.15); color: ${voiceoverStatus === 'generating' ? 'rgba(255,255,255,0.4)' : 'white'}; cursor: ${voiceoverStatus === 'generating' ? 'wait' : 'pointer'}; font-size: 0.75rem;">
                                        ${voiceoverUrl ? ' Regenerate' : ' Generate'} Voice
                                    </button>
                                </div>
                            </div>

                            <!-- Animation Section -->
                            <div>
                                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> Animation Type:</span>
                                    <select onchange="setSceneAnimationType(${scriptScene.id}, this.value)"
                                            style="padding: 0.3rem 0.5rem; border-radius: 0.3rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white; font-size: 0.7rem;">
                                        ${[
                                            { id: 'ken_burns', name: 'Ken Burns (Zoom/Pan)' },
                                            { id: 'talking_head', name: 'Talking Head' },
                                            { id: 'static', name: 'Static (No Animation)' }
                                        ].map(type => `
                                            <option value="${type.id}" ${animationType === type.id ? 'selected' : ''}>${type.name}</option>
                                        `).join('')}
                                    </select>
                                </div>
                                <button onclick="animateScene(${scriptScene.id})"
                                        ${!voiceoverUrl || animationStatus === 'generating' ? 'disabled' : ''}
                                        style="width: 100%; padding: 0.5rem; border-radius: 0.4rem; border: none; background: ${voiceoverUrl && animationStatus !== 'generating' ? 'linear-gradient(135deg, #06b6d4, #10b981)' : 'rgba(255,255,255,0.1)'}; color: ${voiceoverUrl && animationStatus !== 'generating' ? 'white' : 'rgba(255,255,255,0.4)'}; cursor: ${voiceoverUrl && animationStatus !== 'generating' ? 'pointer' : 'not-allowed'}; font-size: 0.8rem; font-weight: 600;">
                                    ${animationStatus === 'generating' ? ' Animating...' : videoUrl ? ' Re-Animate' : ' Animate Scene'}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Animation Functions
        function setGlobalVoice(voice) {
            state.animation.voiceover.voice = voice;
            // Update all scenes that haven't generated voiceover yet
            state.animation.scenes.forEach(scene => {
                if (!scene.voiceoverUrl) {
                    scene.voice = voice;
                }
            });
            saveProject();
            render();
        }

        function setGlobalSpeed(speed) {
            state.animation.voiceover.speed = parseFloat(speed);
            // Update all scenes that haven't generated voiceover yet
            state.animation.scenes.forEach(scene => {
                if (!scene.voiceoverUrl) {
                    scene.speed = parseFloat(speed);
                }
            });
            saveProject();
            render();
        }

        function setSceneAnimationType(sceneId, type) {
            const scene = state.animation.scenes.find(s => s.sceneId === sceneId);
            if (scene) {
                scene.animationType = type;
                saveProject();
            }
        }

        async function generateSceneVoiceover(sceneId) {
            const animScene = state.animation.scenes.find(s => s.sceneId === sceneId);
            const scriptScene = state.script.scenes.find(s => s.id === sceneId);

            if (!animScene || !scriptScene || !scriptScene.narration) {
                showToast('No narration available for this scene', 'error');
                return;
            }

            animScene.voiceoverStatus = 'generating';
            render();

            try {
                const generateVoiceover = firebase.functions().httpsCallable('creationWizardGenerateVoiceover');
                const result = await generateVoiceover({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    text: scriptScene.narration,
                    voice: animScene.voice || state.animation.voiceover.voice,
                    speed: animScene.speed || state.animation.voiceover.speed
                });

                animScene.voiceoverStatus = 'ready';
                animScene.voiceoverUrl = result.data.audioUrl;
                animScene.voiceoverDuration = result.data.duration;  // Store actual audio duration

                // Phase 2: Audio-driven scene duration
                // Adjust scene duration to match voiceover + visual padding
                if (result.data.duration && result.data.duration > 0) {
                    const voiceoverDuration = result.data.duration;
                    const visualPadding = 1.0;  // 0.5s intro + 0.5s outro buffer
                    const newSceneDuration = Math.ceil(voiceoverDuration + visualPadding);

                    // Update script scene duration
                    const oldDuration = scriptScene.duration;
                    scriptScene.duration = newSceneDuration;

                    // Set voiceoverOffset to center audio within scene
                    // (padding / 2) gives equal buffer before and after voiceover
                    scriptScene.voiceoverOffset = visualPadding / 2;

                    // Recalculate total video duration
                    state.script.totalDuration = state.script.scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

                    console.log(`[Voiceover] Scene ${sceneId}: voiceover=${voiceoverDuration.toFixed(2)}s, scene adjusted ${oldDuration}s  ${newSceneDuration}s, offset=${scriptScene.voiceoverOffset}s`);
                }

                showToast('Voiceover generated successfully!', 'success');
            } catch (error) {
                console.error('Voiceover generation error:', error);
                animScene.voiceoverStatus = 'error';
                showToast('Failed to generate voiceover: ' + error.message, 'error');
            }

            saveProject();
            render();
        }

        async function generateAllVoiceovers() {
            const scenesToGenerate = state.animation.scenes.filter(s => !s.voiceoverUrl && s.voiceoverStatus !== 'generating');

            if (scenesToGenerate.length === 0) {
                showToast('All voiceovers are already generated', 'info');
                return;
            }

            showToast(`Generating ${scenesToGenerate.length} voiceovers...`, 'info');

            // Generate sequentially to avoid rate limits
            for (const scene of scenesToGenerate) {
                await generateSceneVoiceover(scene.sceneId);
                // Small delay between generations
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            showToast('All voiceovers generated!', 'success');
        }

        // Video preview modal for animated scenes
        function playAnimationPreview(sceneId, videoUrl) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('animation-preview-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'animation-preview-modal';
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 2rem;';
                modal.innerHTML = `
                    <div style="position: relative; max-width: 900px; width: 100%; background: #1a1a2e; border-radius: 1rem; overflow: hidden; box-shadow: 0 25px 50px rgba(0,0,0,0.5);">
                        <div style="padding: 1rem; display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.05);">
                            <span style="font-size: 1rem; font-weight: 600; color: white;" id="preview-modal-title">Animation Preview</span>
                            <button onclick="closeAnimationPreview()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.5rem;"></button>
                        </div>
                        <div style="padding: 0;">
                            <video id="preview-modal-video" controls autoplay style="width: 100%; max-height: 70vh; background: black;"></video>
                        </div>
                        <div style="padding: 1rem; background: rgba(255,255,255,0.05); text-align: center;">
                            <span style="font-size: 0.85rem; color: rgba(255,255,255,0.6);">Scene animation preview  Click outside or press ESC to close</span>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                // Close on click outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeAnimationPreview();
                });

                // Close on ESC
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeAnimationPreview();
                });
            }

            // Update modal content
            const video = document.getElementById('preview-modal-video');
            const title = document.getElementById('preview-modal-title');
            const sceneIndex = state.script.scenes.findIndex(s => s.id === sceneId);

            video.src = videoUrl;
            title.textContent = `Scene ${sceneIndex + 1} Animation Preview`;
            modal.style.display = 'flex';

            // Play the video
            video.play().catch(() => {});
        }

        function closeAnimationPreview() {
            const modal = document.getElementById('animation-preview-modal');
            const video = document.getElementById('preview-modal-video');
            if (modal) {
                modal.style.display = 'none';
                if (video) {
                    video.pause();
                    video.src = '';
                }
            }
        }

        async function animateScene(sceneId) {
            const animScene = state.animation.scenes.find(s => s.sceneId === sceneId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

            if (!animScene || !storyboardScene || !storyboardScene.imageUrl) {
                showToast('No image available for animation', 'error');
                return;
            }

            if (!animScene.voiceoverUrl) {
                showToast('Please generate voiceover first', 'error');
                return;
            }

            animScene.animationStatus = 'generating';
            render();

            try {
                const animate = firebase.functions().httpsCallable('creationWizardAnimateScene');
                const result = await animate({
                    projectId: state.project.id,
                    sceneId: sceneId,
                    imageUrl: storyboardScene.imageUrl,
                    audioUrl: animScene.voiceoverUrl,
                    animationType: animScene.animationType || 'ken_burns'
                });

                // Start polling for completion
                animScene.jobId = result.data.jobId;
                pollAnimationStatus(sceneId, result.data.jobId);

            } catch (error) {
                console.error('Animation error:', error);
                animScene.animationStatus = 'error';
                showToast('Failed to start animation: ' + error.message, 'error');
                saveProject();
                render();
            }
        }

        async function pollAnimationStatus(sceneId, jobId) {
            const animScene = state.animation.scenes.find(s => s.sceneId === sceneId);
            if (!animScene) return;

            try {
                const checkStatus = firebase.functions().httpsCallable('creationWizardCheckAnimationStatus');
                const result = await checkStatus({ jobId });

                if (result.data.status === 'COMPLETED') {
                    animScene.animationStatus = 'ready';
                    animScene.videoUrl = result.data.videoUrl;
                    animScene.jobId = null;
                    showToast(`Scene ${state.script.scenes.findIndex(s => s.id === sceneId) + 1} animated!`, 'success');
                    saveProject();
                    render();
                } else if (result.data.status === 'FAILED') {
                    animScene.animationStatus = 'error';
                    animScene.jobId = null;
                    showToast('Animation failed. Please try again.', 'error');
                    saveProject();
                    render();
                } else {
                    // Still processing, poll again
                    setTimeout(() => pollAnimationStatus(sceneId, jobId), 5000);
                }
            } catch (error) {
                console.error('Animation status check error:', error);
                // Retry polling
                setTimeout(() => pollAnimationStatus(sceneId, jobId), 8000);
            }
        }

        async function animateAllScenes() {
            const scenesToAnimate = state.animation.scenes.filter(s => s.voiceoverUrl && !s.videoUrl && s.animationStatus !== 'generating');

            if (scenesToAnimate.length === 0) {
                showToast('No scenes ready to animate', 'info');
                return;
            }

            showToast(`Starting animation for ${scenesToAnimate.length} scenes...`, 'info');

            // Start all animations (they will poll independently)
            for (const scene of scenesToAnimate) {
                await animateScene(scene.sceneId);
                // Small delay between starting jobs
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        // ==========================================
        // 7.10 STEP 6: ASSEMBLY
        // ==========================================

        async function initializeAssembly() {
            // Load music library and options if not already loaded
            if (state.assembly.musicLibrary.length === 0) {
                try {
                    const getMusicLibrary = firebase.functions().httpsCallable('creationWizardGetMusicLibrary');
                    const result = await getMusicLibrary({});
                    state.assembly.musicLibrary = result.data.tracks || [];
                    state.assembly.transitionTypes = result.data.transitionTypes || [];
                    state.assembly.captionStyles = result.data.captionStyles || [];
                } catch (error) {
                    console.error('Failed to load music library:', error);
                    // Use defaults
                    state.assembly.transitionTypes = [
                        { id: 'cut', name: 'Cut' },
                        { id: 'fade', name: 'Fade' },
                        { id: 'crossfade', name: 'Crossfade' },
                        { id: 'dissolve', name: 'Dissolve' }
                    ];
                    state.assembly.captionStyles = [
                        { id: 'karaoke', name: 'Karaoke' },
                        { id: 'subtitle', name: 'Subtitle' },
                        { id: 'dynamic', name: 'Dynamic' },
                        { id: 'none', name: 'No Captions' }
                    ];
                }
            }

            // Initialize scene order if empty
            if (state.assembly.sceneOrder.length === 0 && state.script.scenes.length > 0) {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Initialize transitions for each scene if empty
            if (Object.keys(state.assembly.transitions).length === 0) {
                state.script.scenes.forEach(scene => {
                    state.assembly.transitions[scene.id] = { type: 'cut' };
                });
            }
        }

        function renderStep6Assembly() {
            // Initialize on first render
            if (state.assembly.musicLibrary.length === 0) {
                setTimeout(() => initializeAssembly().then(() => render()), 100);
            }

            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            // Calculate total duration
            let totalDuration = 0;
            sceneOrder.forEach(sceneId => {
                const scene = scriptScenes.find(s => s.id === sceneId);
                if (scene) totalDuration += scene.duration || 8;
            });

            const activeTab = state.assembly.activeTab || 'text';

            let html = '<div class="fade-in">';

            // Compact Header
            html += `
                <div style="display: flex; align-items: center; gap: 1rem; padding: 0.75rem 1rem; background: rgba(30,30,50,0.95); border-radius: 0.75rem; margin-bottom: 1rem; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 1.2rem;"></span>
                        <span style="font-weight: 600; color: white;">Content Client</span>
                    </div>
                    <div style="width: 1px; height: 24px; background: rgba(255,255,255,0.2);"></div>
                    <span style="color: rgba(255,255,255,0.7); font-size: 0.85rem;">Rapid Dominate</span>
                    <div style="margin-left: auto; display: flex; align-items: center; gap: 0.75rem;">
                        <span style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">${sceneOrder.length} scenes  ${formatDuration(totalDuration)}</span>
                        <button onclick="saveAssemblySettings()" style="padding: 0.4rem 0.75rem; border-radius: 0.4rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-size: 0.75rem; font-weight: 600; cursor: pointer;">
                             Save
                        </button>
                    </div>
                </div>
            `;

            // Main Professional Layout - Three columns
            html += `<div style="display: grid; grid-template-columns: 200px 320px 1fr; gap: 1rem; height: calc(100vh - 280px); min-height: 500px;">`;

            // LEFT SIDEBAR - Navigation
            html += renderAssemblySidebar(sceneOrder.length, totalDuration);

            // MIDDLE PANEL - Tabbed Controls
            html += renderTabbedControlPanel(activeTab);

            // RIGHT PANEL - Preview
            html += renderCompactPreviewPanel();

            html += `</div>`;

            // BOTTOM - Professional Timeline
            html += `
                <div style="margin-top: 1rem;">
                    ${renderProfessionalTimeline(scriptScenes, animationScenes, totalDuration)}
                </div>
            `;

            // Navigation
            const isAssemblyReady = sceneOrder.length > 0;
            html += renderNavButtons(5, isAssemblyReady ? 7 : null);

            html += '</div>';
            return html;
        }

        // LEFT SIDEBAR for Assembly
        function renderAssemblySidebar(sceneCount, totalDuration) {
            return `
                <div style="background: rgba(20,20,35,0.95); border-radius: 0.75rem; border: 1px solid rgba(255,255,255,0.1); padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem;">
                    <!-- Project Info -->
                    <div style="padding: 0.5rem; background: rgba(139,92,246,0.1); border-radius: 0.5rem; margin-bottom: 0.5rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">Project</div>
                        <div style="font-size: 0.85rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${state.project.name || 'Untitled'}</div>
                    </div>

                    <!-- Navigation Items -->
                    <button onclick="setAssemblyTab('scenes')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Scenes</span>
                        <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5); background: rgba(139,92,246,0.2); padding: 0.15rem 0.4rem; border-radius: 0.25rem;">${sceneCount}</span>
                    </button>

                    <button onclick="setAssemblyTab('text')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: ${state.assembly.activeTab === 'text' ? 'rgba(139,92,246,0.2)' : 'transparent'}; border: 1px solid ${state.assembly.activeTab === 'text' ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Captions</span>
                        ${state.assembly.captions.enabled ? '<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%;"></span>' : ''}
                    </button>

                    <button onclick="setAssemblyTab('audio')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: ${state.assembly.activeTab === 'audio' ? 'rgba(139,92,246,0.2)' : 'transparent'}; border: 1px solid ${state.assembly.activeTab === 'audio' ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Audio</span>
                        ${state.assembly.music.enabled ? '<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%;"></span>' : ''}
                    </button>

                    <button onclick="setAssemblyTab('transitions')" style="display: flex; align-items: center; gap: 0.6rem; padding: 0.6rem 0.75rem; background: ${state.assembly.activeTab === 'transitions' ? 'rgba(139,92,246,0.2)' : 'transparent'}; border: 1px solid ${state.assembly.activeTab === 'transitions' ? 'rgba(139,92,246,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; color: white; cursor: pointer; text-align: left; width: 100%;">
                        <span></span>
                        <span style="flex: 1; font-size: 0.8rem;">Transitions</span>
                    </button>

                    <div style="flex: 1;"></div>

                    <!-- Quick Actions -->
                    <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.75rem; margin-top: 0.5rem;">
                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;">Quick Actions</div>
                        <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                            <button onclick="initializePreviewEngine()" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0.6rem; background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); border-radius: 0.4rem; color: #10b981; cursor: pointer; font-size: 0.7rem;">
                                <span></span> Preview
                            </button>
                            <button onclick="goToStep(7)" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0.6rem; background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.3); border-radius: 0.4rem; color: #a78bfa; cursor: pointer; font-size: 0.7rem;">
                                <span></span> Export
                            </button>
                        </div>
                    </div>

                    <!-- Duration Display -->
                    <div style="text-align: center; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 0.4rem; margin-top: 0.5rem;">
                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">Total Duration</div>
                        <div style="font-size: 1rem; color: white; font-weight: 600; font-family: monospace;">${formatDuration(totalDuration)}</div>
                    </div>
                </div>
            `;
        }

        // TABBED CONTROL PANEL
        function renderTabbedControlPanel(activeTab) {
            return `
                <div style="background: rgba(20,20,35,0.95); border-radius: 0.75rem; border: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; overflow: hidden;">
                    <!-- Tab Headers -->
                    <div style="display: flex; border-bottom: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2);">
                        <button onclick="setAssemblyTab('text')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'text' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'text' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'text' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'text' ? '600' : '400'}; transition: all 0.2s;">
                            TEXT
                        </button>
                        <button onclick="setAssemblyTab('audio')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'audio' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'audio' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'audio' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'audio' ? '600' : '400'}; transition: all 0.2s;">
                            Audio
                        </button>
                        <button onclick="setAssemblyTab('media')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'media' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'media' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'media' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'media' ? '600' : '400'}; transition: all 0.2s;">
                            Media
                        </button>
                        <button onclick="setAssemblyTab('transitions')" style="flex: 1; padding: 0.75rem 0.5rem; background: ${activeTab === 'transitions' ? 'rgba(139,92,246,0.15)' : 'transparent'}; border: none; border-bottom: 2px solid ${activeTab === 'transitions' ? '#8b5cf6' : 'transparent'}; color: ${activeTab === 'transitions' ? 'white' : 'rgba(255,255,255,0.5)'}; cursor: pointer; font-size: 0.75rem; font-weight: ${activeTab === 'transitions' ? '600' : '400'}; transition: all 0.2s;">
                            Transitions
                        </button>
                    </div>

                    <!-- Tab Content -->
                    <div style="flex: 1; overflow-y: auto; padding: 1rem;">
                        ${activeTab === 'text' ? renderTextTabContent() : ''}
                        ${activeTab === 'audio' ? renderAudioTabContent() : ''}
                        ${activeTab === 'media' ? renderMediaTabContent() : ''}
                        ${activeTab === 'transitions' ? renderTransitionsTabContent() : ''}
                    </div>
                </div>
            `;
        }

        // TEXT TAB - Professional Caption Controls
        function renderTextTabContent() {
            const captions = state.assembly.captions;
            const fonts = ['Montserrat', 'Poppins', 'Roboto', 'Inter', 'Oswald', 'Bebas Neue', 'Anton', 'Playfair Display'];
            const effects = [
                { id: 'none', name: 'None', icon: '' },
                { id: 'pop', name: 'Pop', icon: '' },
                { id: 'fade', name: 'Fade', icon: '' },
                { id: 'zoom', name: 'Zoom', icon: '' },
                { id: 'bounce', name: 'Bounce', icon: '' }
            ];

            // Generate live preview styles
            const previewStyle = `
                font-family: '${captions.fontFamily}', sans-serif;
                font-weight: ${captions.fontWeight || 600};
                color: ${captions.fillColor};
                text-shadow:
                    -${captions.strokeWidth}px -${captions.strokeWidth}px 0 ${captions.strokeColor},
                    ${captions.strokeWidth}px -${captions.strokeWidth}px 0 ${captions.strokeColor},
                    -${captions.strokeWidth}px ${captions.strokeWidth}px 0 ${captions.strokeColor},
                    ${captions.strokeWidth}px ${captions.strokeWidth}px 0 ${captions.strokeColor};
            `;

            return `
                <!-- Live Caption Preview -->
                <div style="margin-bottom: 1.25rem; padding: 1rem; background: linear-gradient(135deg, rgba(15,15,25,0.95), rgba(25,25,40,0.95)); border-radius: 0.75rem; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;">Live Preview</div>
                    <div id="caption-live-preview" style="min-height: 50px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); border-radius: 0.5rem; padding: 0.75rem; position: relative; overflow: hidden;">
                        <!-- Static word preview -->
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 1.1rem;">
                            <span style="${previewStyle} opacity: 1;">Your</span>
                            <span id="preview-highlight-word" style="${previewStyle} color: ${captions.highlightColor}; transform: scale(1.1); transition: all 0.3s;">caption</span>
                            <span style="${previewStyle} opacity: 0.5;">here</span>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 0.5rem;">
                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.3);">spoken</span>
                        <span style="font-size: 0.6rem; color: ${captions.highlightColor};"> current</span>
                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.3);">upcoming</span>
                    </div>
                </div>

                <!-- Captions Section Header -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Captions</div>
                </div>

                <!-- Show Captions Toggle -->
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem; margin-bottom: 1rem;">
                    <span style="font-size: 0.85rem; color: white;">Show Captions</span>
                    <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                        <input type="checkbox" ${captions.enabled ? 'checked' : ''} onchange="setCaptionEnabled(this.checked)" style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ${captions.enabled ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; transition: 0.3s; border-radius: 24px;">
                            <span style="position: absolute; content: ''; height: 18px; width: 18px; left: ${captions.enabled ? '23px' : '3px'}; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>
                        </span>
                    </label>
                </div>

                <div style="opacity: ${captions.enabled ? '1' : '0.4'}; pointer-events: ${captions.enabled ? 'auto' : 'none'};">
                    <!-- Caption Style (Word/Sentence) -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">Caption Style</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <button onclick="setCaptionMode('word')" style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${captions.mode === 'word' ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; background: ${captions.mode === 'word' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.75rem; font-weight: ${captions.mode === 'word' ? '600' : '400'};">
                                WORD LEVEL
                            </button>
                            <button onclick="setCaptionMode('sentence')" style="padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${captions.mode === 'sentence' ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; background: ${captions.mode === 'sentence' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.75rem; font-weight: ${captions.mode === 'sentence' ? '600' : '400'};">
                                SENTENCE LEVEL
                            </button>
                        </div>
                    </div>

                    <!-- Font Selection -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">Font</label>
                        <select onchange="setCaptionFont(this.value)" style="width: 100%; padding: 0.6rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.8rem; cursor: pointer;">
                            ${fonts.map(f => `<option value="${f}" ${captions.fontFamily === f ? 'selected' : ''} style="font-family: ${f};">${f}</option>`).join('')}
                        </select>
                    </div>

                    <!-- Fill Color -->
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                        <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Fill Color</span>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="color" value="${captions.fillColor}" onchange="setCaptionFillColor(this.value)" style="width: 32px; height: 24px; border: none; border-radius: 0.25rem; cursor: pointer; background: transparent;">
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5); font-family: monospace;">${captions.fillColor}</span>
                        </div>
                    </div>

                    <!-- Stroke Color -->
                    <div style="margin-bottom: 0.75rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem;">
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Stroke Color</span>
                            <input type="color" value="${captions.strokeColor}" onchange="setCaptionStrokeColor(this.value)" style="width: 24px; height: 18px; border: none; border-radius: 0.2rem; cursor: pointer;">
                        </div>
                    </div>

                    <!-- Stroke Width -->
                    <div style="margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4rem;">
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Stroke Width</span>
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.5);">${captions.strokeWidth}px</span>
                        </div>
                        <input type="range" min="0" max="5" step="0.5" value="${captions.strokeWidth}" onchange="setCaptionStrokeWidth(this.value)" style="width: 100%; height: 6px; cursor: pointer; accent-color: #8b5cf6;">
                    </div>

                    <!-- Effects Section -->
                    <div style="margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);"> EFFECTS</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.4rem;">
                            ${effects.map(e => `
                                <button onclick="setCaptionEffect('${e.id}')" style="padding: 0.4rem 0.25rem; border-radius: 0.3rem; border: 1px solid ${captions.effect === e.id ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.effect === e.id ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.65rem; text-align: center;">
                                    <div style="font-size: 0.9rem; margin-bottom: 2px;">${e.icon}</div>
                                    ${e.name}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Text Style Presets -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">Text Style</label>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.4rem;">
                            <button onclick="setCaptionStyle('karaoke')" style="padding: 0.5rem; border-radius: 0.3rem; border: 1px solid ${captions.style === 'karaoke' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.style === 'karaoke' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.7rem;">
                                Karaoke
                            </button>
                            <button onclick="setCaptionStyle('beasty')" style="padding: 0.5rem; border-radius: 0.3rem; border: 1px solid ${captions.style === 'beasty' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.style === 'beasty' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.7rem;">
                                Bold
                            </button>
                            <button onclick="setCaptionStyle('deepdiver')" style="padding: 0.5rem; border-radius: 0.3rem; border: 1px solid ${captions.style === 'deepdiver' ? '#8b5cf6' : 'rgba(255,255,255,0.15)'}; background: ${captions.style === 'deepdiver' ? 'rgba(139,92,246,0.2)' : 'transparent'}; color: white; cursor: pointer; font-size: 0.7rem;">
                                Minimal
                            </button>
                        </div>
                    </div>

                    <!-- Highlight Color -->
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; background: rgba(251,191,36,0.1); border: 1px solid rgba(251,191,36,0.3); border-radius: 0.5rem;">
                        <span style="font-size: 0.75rem; color: rgba(255,255,255,0.8);">Highlight Color</span>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="color" value="${captions.highlightColor}" onchange="setCaptionHighlightColor(this.value)" style="width: 32px; height: 24px; border: none; border-radius: 0.25rem; cursor: pointer;">
                            <span style="font-size: 0.65rem; padding: 0.2rem 0.4rem; background: rgba(251,191,36,0.2); color: #fbbf24; border-radius: 0.25rem;">KARAOKE</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // AUDIO TAB
        function renderAudioTabContent() {
            const musicLibrary = state.assembly.musicLibrary || [];
            const selectedTrackId = state.assembly.music.trackId;
            const musicEnabled = state.assembly.music.enabled;
            const musicVolume = state.assembly.music.volume;
            const voiceVolume = state.assembly.audioMix?.voiceVolume || 100;
            const audioDucking = state.assembly.audioMix?.ducking ?? true;
            const musicFadeIn = state.assembly.music.fadeIn ?? 2;
            const musicFadeOut = state.assembly.music.fadeOut ?? 3;

            return `
                <!-- Audio Mix Visualization -->
                <div style="margin-bottom: 1.25rem; padding: 0.75rem; background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(139,92,246,0.1)); border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem;">Audio Mix</div>
                    <div style="display: flex; align-items: flex-end; gap: 4px; height: 32px;">
                        ${[...Array(16)].map((_, i) => {
                            const voiceHeight = Math.random() * 60 + 40;
                            const musicHeight = musicEnabled ? Math.random() * 30 + 10 : 0;
                            return `
                                <div style="flex: 1; display: flex; flex-direction: column; gap: 2px; align-items: center;">
                                    <div style="width: 100%; height: ${voiceHeight}%; background: linear-gradient(to top, #06b6d4, #22d3ee); border-radius: 1px;"></div>
                                    <div style="width: 100%; height: ${musicHeight}%; background: linear-gradient(to top, #8b5cf6, #a78bfa); border-radius: 1px; opacity: 0.7;"></div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 0.5rem;">
                        <span style="font-size: 0.6rem; color: #06b6d4;"> Voice</span>
                        <span style="font-size: 0.6rem; color: #8b5cf6;"> Music</span>
                    </div>
                </div>

                <!-- Voice Settings -->
                <div style="margin-bottom: 1.25rem;">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;"> Voiceover</div>
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span style="font-size: 0.8rem; color: white;">Volume</span>
                        <span style="font-size: 0.75rem; color: #06b6d4; font-weight: 600;">${voiceVolume}%</span>
                    </div>
                    <input type="range" min="0" max="100" value="${voiceVolume}" onchange="setVoiceVolume(this.value)" style="width: 100%; height: 6px; cursor: pointer; accent-color: #06b6d4;">
                </div>

                <!-- Background Music -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;"> Background Music</div>

                    <!-- Enable Toggle -->
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem; margin-bottom: 1rem;">
                        <span style="font-size: 0.85rem; color: white;">Enable Music</span>
                        <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                            <input type="checkbox" ${musicEnabled ? 'checked' : ''} onchange="toggleMusic(this.checked)" style="opacity: 0; width: 0; height: 0;">
                            <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ${musicEnabled ? '#8b5cf6' : 'rgba(255,255,255,0.2)'}; transition: 0.3s; border-radius: 24px;">
                                <span style="position: absolute; height: 18px; width: 18px; left: ${musicEnabled ? '23px' : '3px'}; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>
                            </span>
                        </label>
                    </div>

                    <div style="opacity: ${musicEnabled ? '1' : '0.4'}; pointer-events: ${musicEnabled ? 'auto' : 'none'};">
                        <!-- Track Selection -->
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">Select Track</label>
                            <select id="music-select" onchange="selectMusicTrack(this.value)" style="width: 100%; padding: 0.6rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.4rem; color: white; font-size: 0.8rem; cursor: pointer;">
                                <option value="">Choose a track...</option>
                                ${musicLibrary.map(track => `
                                    <option value="${track.id}" ${selectedTrackId === track.id ? 'selected' : ''}>
                                        ${track.name} ${track.duration ? `(${Math.floor(track.duration / 60)}:${String(track.duration % 60).padStart(2, '0')})` : ''}
                                    </option>
                                `).join('')}
                            </select>
                        </div>

                        <!-- Volume -->
                        <div style="margin-bottom: 1rem;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                                <span style="font-size: 0.8rem; color: white;">Volume</span>
                                <span style="font-size: 0.75rem; color: #8b5cf6; font-weight: 600;">${musicVolume}%</span>
                            </div>
                            <input type="range" min="0" max="100" value="${musicVolume}" onchange="setMusicVolume(this.value)" style="width: 100%; height: 6px; cursor: pointer; accent-color: #8b5cf6;">
                        </div>

                        <!-- Audio Ducking -->
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.6rem; background: rgba(255,255,255,0.03); border-radius: 0.4rem; margin-bottom: 1rem;">
                            <div>
                                <span style="font-size: 0.8rem; color: white;">Auto-Duck</span>
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">Lower music during voice</div>
                            </div>
                            <label style="position: relative; display: inline-block; width: 36px; height: 20px;">
                                <input type="checkbox" ${audioDucking ? 'checked' : ''} onchange="setAudioDucking(this.checked)" style="opacity: 0; width: 0; height: 0;">
                                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: ${audioDucking ? '#10b981' : 'rgba(255,255,255,0.2)'}; transition: 0.3s; border-radius: 20px;">
                                    <span style="position: absolute; height: 14px; width: 14px; left: ${audioDucking ? '19px' : '3px'}; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>
                                </span>
                            </label>
                        </div>

                        <!-- Fade Controls -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                            <div>
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.3rem;">
                                    <span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Fade In</span>
                                    <span style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">${musicFadeIn}s</span>
                                </div>
                                <input type="range" min="0" max="5" step="0.5" value="${musicFadeIn}" onchange="setMusicFadeIn(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #8b5cf6;">
                            </div>
                            <div>
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.3rem;">
                                    <span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Fade Out</span>
                                    <span style="font-size: 0.65rem; color: rgba(255,255,255,0.4);">${musicFadeOut}s</span>
                                </div>
                                <input type="range" min="0" max="5" step="0.5" value="${musicFadeOut}" onchange="setMusicFadeOut(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #8b5cf6;">
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // MEDIA TAB
        function renderMediaTabContent() {
            const scriptScenes = state.script.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const currentSceneIndex = state.preview.currentSceneIndex;

            // Calculate total duration
            const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.visualDuration || s.duration || 5), 0);

            return `
                <!-- Media Overview -->
                <div style="margin-bottom: 1rem; padding: 0.75rem; background: linear-gradient(135deg, rgba(16,185,129,0.1), rgba(6,182,212,0.1)); border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); text-transform: uppercase;">Total Scenes</div>
                            <div style="font-size: 1.25rem; color: white; font-weight: 600;">${scriptScenes.length}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.4); text-transform: uppercase;">Duration</div>
                            <div style="font-size: 1.25rem; color: #10b981; font-weight: 600;">${formatDuration(totalDuration)}</div>
                        </div>
                    </div>
                </div>

                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;">Scene Media</div>

                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; max-height: 320px; overflow-y: auto; padding-right: 0.25rem;">
                    ${scriptScenes.map((scene, i) => {
                        const storyboard = storyboardScenes.find(s => s.sceneId === scene.id);
                        const anim = animationScenes.find(s => s.sceneId === scene.id);
                        const imageUrl = storyboard?.imageUrl;
                        const hasVideo = anim?.videoUrl;
                        const duration = scene.visualDuration || scene.duration || 5;
                        const isActive = i === currentSceneIndex;

                        return `
                            <div onclick="jumpToScene(${i})" style="background: rgba(255,255,255,0.03); border: 2px solid ${isActive ? '#8b5cf6' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; overflow: hidden; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='rgba(139,92,246,0.5)'" onmouseout="this.style.borderColor='${isActive ? '#8b5cf6' : 'rgba(255,255,255,0.1)}'">
                                <div style="aspect-ratio: 16/9; background: rgba(0,0,0,0.3); position: relative;">
                                    ${imageUrl ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` :
                                      `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3);"></div>`}
                                    ${isActive ? `<div style="position: absolute; top: 4px; left: 4px; padding: 2px 6px; background: #8b5cf6; border-radius: 3px; font-size: 0.55rem; color: white;"> PLAYING</div>` : ''}
                                    <div style="position: absolute; bottom: 4px; right: 4px; padding: 2px 6px; background: rgba(0,0,0,0.7); border-radius: 3px; font-size: 0.6rem; color: white;">${formatDuration(duration)}</div>
                                </div>
                                <div style="padding: 0.4rem; display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-size: 0.7rem; color: white; font-weight: ${isActive ? '600' : '400'};">Scene ${i + 1}</div>
                                        <div style="font-size: 0.6rem; color: ${hasVideo ? '#10b981' : '#f59e0b'};">
                                            ${hasVideo ? ' Video' : ' Image'}
                                        </div>
                                    </div>
                                    ${hasVideo ? '' : `<button onclick="event.stopPropagation(); regenerateSceneImage(${i})" style="padding: 0.2rem 0.4rem; background: rgba(139,92,246,0.2); border: 1px solid rgba(139,92,246,0.5); border-radius: 0.25rem; color: #a78bfa; font-size: 0.55rem; cursor: pointer;"></button>`}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // TRANSITIONS TAB
        function renderTransitionsTabContent() {
            const scriptScenes = state.script.scenes || [];
            const defaultTransitionTypes = [
                { id: 'fade', name: 'Fade', icon: '', desc: 'Smooth fade between scenes' },
                { id: 'dissolve', name: 'Dissolve', icon: '', desc: 'Cross-dissolve blend' },
                { id: 'wipe', name: 'Wipe', icon: '', desc: 'Horizontal wipe' },
                { id: 'zoom', name: 'Zoom', icon: '', desc: 'Zoom transition' },
                { id: 'slide', name: 'Slide', icon: '', desc: 'Slide in/out' },
                { id: 'none', name: 'Cut', icon: '', desc: 'Hard cut' }
            ];
            const transitionTypes = state.assembly.transitionTypes?.length ? state.assembly.transitionTypes : defaultTransitionTypes;
            const globalDuration = state.assembly.transitionDuration ?? 0.5;

            return `
                <!-- Global Settings -->
                <div style="margin-bottom: 1.25rem; padding: 0.75rem; background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(236,72,153,0.1)); border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase;">Default Duration</div>
                        <span style="font-size: 0.75rem; color: #a78bfa; font-weight: 600;">${globalDuration}s</span>
                    </div>
                    <input type="range" min="0.2" max="2" step="0.1" value="${globalDuration}" onchange="setGlobalTransitionDuration(this.value)" style="width: 100%; height: 4px; cursor: pointer; accent-color: #8b5cf6;">

                    <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                        <button onclick="applyTransitionToAll('fade')" style="flex: 1; padding: 0.4rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.3rem; color: rgba(255,255,255,0.7); font-size: 0.65rem; cursor: pointer;">Apply Fade to All</button>
                        <button onclick="applyTransitionToAll('none')" style="flex: 1; padding: 0.4rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 0.3rem; color: rgba(255,255,255,0.7); font-size: 0.65rem; cursor: pointer;">Cut All</button>
                    </div>
                </div>

                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem;">Scene Transitions</div>

                <div style="display: flex; flex-direction: column; gap: 0.5rem; max-height: 280px; overflow-y: auto; padding-right: 0.25rem;">
                    ${scriptScenes.slice(0, -1).map((scene, i) => {
                        const transition = state.assembly.transitions[scene.id] || { type: 'fade', duration: globalDuration };
                        const currentType = transitionTypes.find(t => t.id === transition.type) || transitionTypes[0];
                        return `
                            <div style="padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.1);">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <div style="width: 24px; height: 24px; background: rgba(139,92,246,0.2); border-radius: 0.25rem; display: flex; align-items: center; justify-content: center; font-size: 0.7rem;">${i + 1}</div>
                                    <div style="flex: 1; height: 2px; background: linear-gradient(90deg, rgba(139,92,246,0.5), rgba(6,182,212,0.5));"></div>
                                    <span style="font-size: 0.9rem;">${currentType.icon}</span>
                                    <div style="flex: 1; height: 2px; background: linear-gradient(90deg, rgba(6,182,212,0.5), rgba(139,92,246,0.5));"></div>
                                    <div style="width: 24px; height: 24px; background: rgba(6,182,212,0.2); border-radius: 0.25rem; display: flex; align-items: center; justify-content: center; font-size: 0.7rem;">${i + 2}</div>
                                </div>
                                <div style="display: flex; gap: 0.5rem;">
                                    <select onchange="setSceneTransition('${scene.id}', this.value)" style="flex: 1; padding: 0.4rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.3rem; color: white; font-size: 0.7rem; cursor: pointer;">
                                        ${transitionTypes.map(t => `
                                            <option value="${t.id}" ${transition.type === t.id ? 'selected' : ''}>${t.icon} ${t.name}</option>
                                        `).join('')}
                                    </select>
                                    <div style="display: flex; align-items: center; gap: 0.25rem; padding: 0 0.4rem; background: rgba(30,30,50,1); border: 1px solid rgba(255,255,255,0.2); border-radius: 0.3rem;">
                                        <input type="number" min="0.1" max="3" step="0.1" value="${transition.duration || globalDuration}" onchange="setTransitionDuration('${scene.id}', this.value)" style="width: 40px; background: transparent; border: none; color: white; font-size: 0.7rem; text-align: center;">
                                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">s</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>

                ${scriptScenes.length <= 1 ? `
                    <div style="text-align: center; padding: 2rem; color: rgba(255,255,255,0.4); font-size: 0.8rem;">
                        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;"></div>
                        Add more scenes to configure transitions
                    </div>
                ` : ''}
            `;
        }

        // COMPACT PREVIEW PANEL
        function renderCompactPreviewPanel() {
            const { isReady, isPlaying, currentTime, totalDuration, currentSceneIndex, loadProgress } = state.preview;
            const scriptScenes = state.script.scenes || [];
            const currentScene = scriptScenes[currentSceneIndex] || {};

            return `
                <div style="background: rgba(20,20,35,0.95); border-radius: 0.75rem; border: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; overflow: hidden;">
                    <!-- Preview Canvas -->
                    <div style="position: relative; width: 100%; aspect-ratio: 16/9; background: #000; flex-shrink: 0;">
                        <canvas id="preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                        ${!isReady ? `
                            <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem;">
                                ${loadProgress > 0 ? `
                                    <div style="width: 60%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                                        <div style="width: ${loadProgress}%; height: 100%; background: linear-gradient(135deg, #8b5cf6, #06b6d4); transition: width 0.3s;"></div>
                                    </div>
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Loading ${loadProgress}%</span>
                                ` : `
                                    <button onclick="initializePreviewEngine()" style="padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; font-size: 0.85rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 1.2rem;"></span> Load Preview
                                    </button>
                                `}
                            </div>
                        ` : `
                            <div id="preview-play-overlay" onclick="togglePreviewPlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.2); transition: opacity 0.2s; opacity: ${isPlaying ? '0' : '1'}; pointer-events: ${isPlaying ? 'none' : 'auto'};">
                                <div style="width: 50px; height: 50px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                    <span style="font-size: 1.2rem; margin-left: 3px;"></span>
                                </div>
                            </div>
                        `}
                    </div>

                    <!-- Playback Controls -->
                    <div style="padding: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <button onclick="togglePreviewPlayback()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; font-size: 0.8rem;">
                                ${isPlaying ? '' : ''}
                            </button>
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.6); font-family: monospace;">
                                ${formatDuration(currentTime)} / ${formatDuration(totalDuration)}
                            </span>
                            <div style="margin-left: auto; display: flex; align-items: center; gap: 0.25rem;">
                                <span style="font-size: 0.7rem;"></span>
                                <input type="range" min="0" max="100" value="${state.preview.volume || 100}" onchange="setPreviewVolume(this.value)" style="width: 50px; height: 3px; cursor: pointer;">
                            </div>
                        </div>
                        <input type="range" id="preview-scrubber" min="0" max="${totalDuration || 100}" step="0.1" value="${currentTime}" onchange="seekPreview(this.value)" ${!isReady ? 'disabled' : ''} style="width: 100%; height: 4px; cursor: ${isReady ? 'pointer' : 'not-allowed'}; accent-color: #8b5cf6;">
                    </div>

                    <!-- Scene Info -->
                    <div style="padding: 0.5rem 0.75rem; background: rgba(139,92,246,0.1); font-size: 0.7rem;">
                        <span style="color: rgba(255,255,255,0.5);">Scene ${currentSceneIndex + 1}:</span>
                        <span style="color: white; margin-left: 0.25rem;">${currentScene.narration?.substring(0, 30) || 'No scene'}${currentScene.narration?.length > 30 ? '...' : ''}</span>
                    </div>
                </div>
            `;
        }

        // Tab switching function
        function setAssemblyTab(tab) {
            state.assembly.activeTab = tab;
            render();
        }

        // New caption control functions
        function setCaptionEnabled(enabled) {
            state.assembly.captions.enabled = enabled;
            updatePreviewCaptions();
            render();
        }

        function setCaptionMode(mode) {
            state.assembly.captions.mode = mode;
            updatePreviewCaptions();
            render();
        }

        function setCaptionFont(font) {
            state.assembly.captions.fontFamily = font;
            updatePreviewCaptions();
            render();
        }

        function setCaptionFillColor(color) {
            state.assembly.captions.fillColor = color;
            updatePreviewCaptions();
            render();
        }

        function setCaptionStrokeColor(color) {
            state.assembly.captions.strokeColor = color;
            updatePreviewCaptions();
            render();
        }

        function setCaptionStrokeWidth(width) {
            state.assembly.captions.strokeWidth = parseFloat(width);
            updatePreviewCaptions();
            render();
        }

        function setCaptionEffect(effect) {
            state.assembly.captions.effect = effect;
            updatePreviewCaptions();
            render();
        }

        function setCaptionHighlightColor(color) {
            state.assembly.captions.highlightColor = color;
            updatePreviewCaptions();
            render();
        }

        function updatePreviewCaptions() {
            if (previewEngine) {
                const captions = state.assembly.captions;
                // Basic settings
                previewEngine.setCaptionStyle(captions.style);
                previewEngine.setCaptionPosition(captions.position);
                previewEngine.setCaptionSize(captions.size);
                previewEngine.setCaptionsEnabled(captions.enabled);
                // Enhanced settings (Phase 2)
                previewEngine.setCaptionMode(captions.mode);
                previewEngine.setCaptionFontFamily(captions.fontFamily);
                previewEngine.setCaptionFillColor(captions.fillColor);
                previewEngine.setCaptionStrokeColor(captions.strokeColor);
                previewEngine.setCaptionStrokeWidth(captions.strokeWidth);
                previewEngine.setCaptionEffect(captions.effect);
                previewEngine.setCaptionHighlightColor(captions.highlightColor);
            }
        }

        function renderPreviewPanel() {
            const { isReady, isPlaying, currentTime, totalDuration, currentSceneIndex, loadProgress } = state.preview;
            const scriptScenes = state.script.scenes || [];
            const currentScene = scriptScenes[currentSceneIndex] || {};

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Live Preview
                        ${isReady ? '<span style="font-size: 0.65rem; padding: 0.15rem 0.4rem; background: rgba(16, 185, 129, 0.2); color: #10b981; border-radius: 0.25rem; margin-left: auto;">Ready</span>' :
                          loadProgress > 0 ? `<span style="font-size: 0.65rem; padding: 0.15rem 0.4rem; background: rgba(139, 92, 246, 0.2); color: #a78bfa; border-radius: 0.25rem; margin-left: auto;">Loading ${loadProgress}%</span>` :
                          '<span style="font-size: 0.65rem; padding: 0.15rem 0.4rem; background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.5); border-radius: 0.25rem; margin-left: auto;">Click to load</span>'}
                    </div>

                    <!-- Preview Canvas Container -->
                    <div style="position: relative; width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 0.5rem; overflow: hidden; margin-bottom: 0.75rem;">
                        <canvas id="preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                        <!-- Captions are rendered directly on canvas by PreviewEngine -->

                        <!-- Loading Overlay -->
                        ${!isReady ? `
                            <div id="preview-loading-overlay" style="position: absolute; inset: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem;">
                                ${loadProgress > 0 ? `
                                    <div style="width: 60%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                                        <div style="width: ${loadProgress}%; height: 100%; background: linear-gradient(135deg, #8b5cf6, #06b6d4); transition: width 0.3s;"></div>
                                    </div>
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6);">Loading media...</span>
                                ` : `
                                    <button onclick="initializePreviewEngine()" style="padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; font-size: 0.85rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 1.2rem;"></span> Load Preview
                                    </button>
                                    <span style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 0.25rem;">Loads all scenes for preview</span>
                                `}
                            </div>
                        ` : ''}

                        <!-- Play Button Overlay (when paused) - Always rendered, visibility controlled by JS -->
                        ${isReady ? `
                            <div id="preview-play-overlay" onclick="togglePreviewPlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.3); transition: opacity 0.2s; opacity: ${isPlaying ? '0' : '1'}; pointer-events: ${isPlaying ? 'none' : 'auto'};" onmouseover="if(!state.preview.isPlaying) this.style.background='rgba(0,0,0,0.1)'" onmouseout="if(!state.preview.isPlaying) this.style.background='rgba(0,0,0,0.3)'">
                                <div style="width: 60px; height: 60px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                    <span style="font-size: 1.5rem; margin-left: 4px;"></span>
                                </div>
                            </div>
                        ` : ''}
                    </div>

                    <!-- Playback Controls -->
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <button id="preview-play-btn" onclick="togglePreviewPlayback()" ${!isReady ? 'disabled' : ''}
                                style="width: 36px; height: 36px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; font-size: 0.9rem;">
                            ${isPlaying ? '' : ''}
                        </button>

                        <button onclick="stopPreview()" ${!isReady ? 'disabled' : ''}
                                style="width: 28px; height: 28px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; font-size: 0.7rem;">
                            
                        </button>

                        <!-- Time Display -->
                        <span id="preview-time-display" style="font-size: 0.75rem; color: rgba(255,255,255,0.7); font-family: monospace; min-width: 90px;">
                            ${formatDuration(currentTime)} / ${formatDuration(totalDuration)}
                        </span>

                        <!-- Volume Control -->
                        <div style="margin-left: auto; display: flex; align-items: center; gap: 0.3rem;">
                            <span style="font-size: 0.75rem;"></span>
                            <input type="range" min="0" max="100" value="${(state.preview.volume || 100)}"
                                   onchange="setPreviewVolume(this.value)"
                                   style="width: 60px; height: 4px; cursor: pointer;">
                        </div>
                    </div>

                    <!-- Scrubber -->
                    <div style="margin-bottom: 0.75rem;">
                        <input type="range" id="preview-scrubber" min="0" max="${totalDuration || 100}" step="0.1" value="${currentTime}"
                               onchange="seekPreview(this.value)" oninput="updateScrubberPreview(this.value)"
                               ${!isReady ? 'disabled' : ''}
                               style="width: 100%; height: 6px; cursor: ${isReady ? 'pointer' : 'not-allowed'}; background: linear-gradient(to right, #8b5cf6 0%, #8b5cf6 ${(currentTime / (totalDuration || 1)) * 100}%, rgba(255,255,255,0.2) ${(currentTime / (totalDuration || 1)) * 100}%, rgba(255,255,255,0.2) 100%); border-radius: 3px;">
                    </div>

                    <!-- Current Scene Info -->
                    <div style="background: rgba(139, 92, 246, 0.1); border-radius: 0.4rem; padding: 0.5rem;">
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem;">Currently Playing</div>
                        <div id="current-scene-info" style="font-size: 0.8rem; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            Scene ${currentSceneIndex + 1}: "${currentScene.narration?.substring(0, 35) || 'No scene loaded'}${currentScene.narration?.length > 35 ? '...' : ''}"
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <button onclick="prevPreviewScene()" ${!isReady || currentSceneIndex <= 0 ? 'disabled' : ''}
                                    style="flex: 1; padding: 0.3rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady && currentSceneIndex > 0 ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady && currentSceneIndex > 0 ? 'pointer' : 'not-allowed'}; font-size: 0.7rem;">
                                 Prev
                            </button>
                            <button onclick="nextPreviewScene()" ${!isReady || currentSceneIndex >= (scriptScenes.length - 1) ? 'disabled' : ''}
                                    style="flex: 1; padding: 0.3rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady && currentSceneIndex < (scriptScenes.length - 1) ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady && currentSceneIndex < (scriptScenes.length - 1) ? 'pointer' : 'not-allowed'}; font-size: 0.7rem;">
                                Next 
                            </button>
                        </div>
                    </div>

                    <!-- Keyboard Shortcuts Hint -->
                    ${isReady ? `
                        <div style="margin-top: 0.5rem; font-size: 0.65rem; color: rgba(255,255,255,0.4); text-align: center;">
                            <span title="Space: Play/Pause, /: Seek 5s, Shift+/: Prev/Next Scene, M: Mute">
                                 Space: Play/Pause  : Seek  M: Mute
                            </span>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderTimelineSceneCard(scriptScene, animScene, storyboardScene, transition, index, totalScenes) {
            const imageUrl = storyboardScene?.imageUrl;
            const hasVideo = animScene?.videoUrl;
            const hasStockVideo = storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl;
            const transitionTypes = state.assembly.transitionTypes || [];
            const isCurrentScene = state.preview.isReady && state.preview.currentSceneIndex === index;

            let html = `
                <div class="timeline-scene" data-scene-id="${scriptScene.id}" data-scene-index="${index}"
                     onclick="seekToScene(${scriptScene.id})"
                     style="background: ${isCurrentScene ? 'rgba(139, 92, 246, 0.1)' : 'rgba(255,255,255,0.03)'}; border: 2px solid ${isCurrentScene ? 'rgba(139, 92, 246, 0.8)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; overflow: hidden; cursor: pointer; transition: all 0.2s; ${isCurrentScene ? 'box-shadow: 0 0 20px rgba(139, 92, 246, 0.4);' : ''}"
                     onmouseover="if(!this.dataset.playing) this.style.borderColor='rgba(139, 92, 246, 0.5)'"
                     onmouseout="if(!this.dataset.playing) this.style.borderColor='${isCurrentScene ? 'rgba(139, 92, 246, 0.8)' : 'rgba(255,255,255,0.1)'}'"
                     ${isCurrentScene ? 'data-playing="true"' : ''}>

                    <!-- Scene Progress Bar -->
                    <div class="scene-progress-bar" style="height: 3px; background: rgba(255,255,255,0.1);">
                        <div class="scene-progress-fill" style="height: 100%; width: 0%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); transition: width 0.1s linear;"></div>
                    </div>

                    <div style="display: flex; gap: 0.75rem; padding: 0.75rem;">
                        <!-- Drag Handle & Number -->
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 0.25rem;" onclick="event.stopPropagation()">
                            <div style="cursor: grab; color: rgba(255,255,255,0.3); font-size: 1rem;"></div>
                            <div style="width: 1.5rem; height: 1.5rem; background: linear-gradient(135deg, #8b5cf6, #06b6d4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700;">
                                ${index + 1}
                            </div>
                        </div>

                        <!-- Thumbnail -->
                        <div style="width: 80px; height: 50px; border-radius: 0.25rem; overflow: hidden; background: rgba(0,0,0,0.3); flex-shrink: 0;">
                            ${imageUrl ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` :
                              `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 0.7rem;">No image</div>`}
                        </div>

                        <!-- Scene Info -->
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 0.8rem; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 0.25rem;">
                                ${scriptScene.narration?.substring(0, 40) || 'No narration'}...
                            </div>
                            <div style="display: flex; gap: 0.5rem; font-size: 0.7rem; color: rgba(255,255,255,0.5);">
                                <span> ${scriptScene.duration || 8}s</span>
                                ${hasVideo ? '<span style="color: #10b981;"> Video</span>' : '<span style="color: #f59e0b;"> No video</span>'}
                            </div>
                        </div>

                        <!-- Reorder Buttons -->
                        <div style="display: flex; flex-direction: column; gap: 0.25rem;" onclick="event.stopPropagation()">
                            <button onclick="event.stopPropagation(); moveSceneInOrder(${scriptScene.id}, -1)" ${index === 0 ? 'disabled' : ''}
                                    style="padding: 0.25rem 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: ${index === 0 ? 'rgba(255,255,255,0.2)' : 'white'}; cursor: ${index === 0 ? 'not-allowed' : 'pointer'}; font-size: 0.65rem;">
                                
                            </button>
                            <button onclick="event.stopPropagation(); moveSceneInOrder(${scriptScene.id}, 1)" ${index === totalScenes - 1 ? 'disabled' : ''}
                                    style="padding: 0.25rem 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: ${index === totalScenes - 1 ? 'rgba(255,255,255,0.2)' : 'white'}; cursor: ${index === totalScenes - 1 ? 'not-allowed' : 'pointer'}; font-size: 0.65rem;">
                                
                            </button>
                        </div>
                    </div>

                    <!-- Transition Selector (between scenes) -->
                    ${index < totalScenes - 1 ? `
                        <div onclick="event.stopPropagation()" style="padding: 0.5rem 0.75rem; background: rgba(139, 92, 246, 0.1); border-top: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Transition:</span>
                            <select onchange="setSceneTransition(${scriptScene.id}, this.value)"
                                    style="flex: 1; padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white; font-size: 0.7rem;">
                                ${transitionTypes.map(t => `
                                    <option value="${t.id}" ${transition.type === t.id ? 'selected' : ''}>${t.name}</option>
                                `).join('')}
                            </select>
                        </div>
                    ` : ''}
                </div>
            `;
            return html;
        }

        function renderMusicSettings() {
            const musicLibrary = state.assembly.musicLibrary || [];
            const selectedTrackId = state.assembly.music.trackId;
            const musicEnabled = state.assembly.music.enabled;
            const musicVolume = state.assembly.music.volume;

            // Group by category
            const categories = ['upbeat', 'calm', 'dramatic', 'electronic', 'hiphop', 'none'];
            const categoryNames = {
                upbeat: ' Upbeat',
                calm: ' Calm',
                dramatic: ' Dramatic',
                electronic: ' Electronic',
                hiphop: ' Hip Hop',
                none: ' None'
            };

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Background Music
                        <label style="margin-left: auto; display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" ${musicEnabled ? 'checked' : ''} onchange="toggleMusic(this.checked)"
                                   style="width: 1rem; height: 1rem; cursor: pointer;">
                            <span style="font-size: 0.75rem; font-weight: 400; color: rgba(255,255,255,0.6);">Enable</span>
                        </label>
                    </div>

                    <div style="opacity: ${musicEnabled ? '1' : '0.5'}; pointer-events: ${musicEnabled ? 'auto' : 'none'};">
                        <select id="music-select" onchange="selectMusicTrack(this.value)"
                                style="width: 100%; padding: 0.6rem; border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(30,30,50,1); color: white; font-size: 0.85rem; margin-bottom: 0.75rem;">
                            <option value="">Select a track...</option>
                            ${categories.map(cat => `
                                <optgroup label="${categoryNames[cat] || cat}">
                                    ${musicLibrary.filter(t => t.category === cat).map(track => `
                                        <option value="${track.id}" ${selectedTrackId === track.id ? 'selected' : ''}>
                                            ${track.name} ${track.duration ? `(${Math.floor(track.duration / 60)}:${(track.duration % 60).toString().padStart(2, '0')})` : ''}
                                        </option>
                                    `).join('')}
                                </optgroup>
                            `).join('')}
                        </select>

                        ${selectedTrackId && selectedTrackId !== 'none' ? `
                            <div style="background: rgba(139, 92, 246, 0.1); border-radius: 0.4rem; padding: 0.5rem; margin-bottom: 0.75rem;">
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                    ${musicLibrary.find(t => t.id === selectedTrackId)?.mood || ''}
                                </div>
                            </div>
                        ` : ''}

                        <div>
                            <label style="display: block; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">
                                Volume: ${musicVolume}%
                            </label>
                            <input type="range" min="0" max="100" value="${musicVolume}"
                                   onchange="setMusicVolume(this.value)"
                                   style="width: 100%; height: 6px; cursor: pointer;">
                        </div>
                    </div>
                </div>
            `;
        }

        // NOTE: Caption rendering is now handled by VideoPreviewEngine._renderCaption()
        // which provides style-aware, word-by-word synchronized captions on the canvas

        function renderCaptionSettings() {
            const selectedStyle = state.assembly.captions.style || 'karaoke';
            const position = state.assembly.captions.position || 'bottom';
            const size = state.assembly.captions.size || 1;

            // Same styles as video-wizard.html for consistency and correct export
            const captionStyles = [
                { id: 'none', name: 'None', preview: '' },
                { id: 'karaoke', name: 'Karaoke', preview: '<span style="color:#fff">The</span> <span style="color:#fbbf24;font-weight:700">biggest</span>' },
                { id: 'beasty', name: 'MrBeast', preview: '<span style="color:#fbbf24;font-weight:900;text-transform:uppercase;font-size:0.8rem">BOLD</span>' },
                { id: 'deepdiver', name: 'Minimal', preview: '<span style="font-weight:400;font-size:0.7rem;opacity:0.8">minimal style</span>' },
                { id: 'podp', name: 'Podcast', preview: '<span style="font-weight:500;letter-spacing:0.3px">Clean Text</span>' },
                { id: 'hormozi', name: 'Hormozi', preview: '<span style="background:linear-gradient(180deg,#22c55e,#16a34a);padding:2px 6px;border-radius:3px;font-weight:600;color:#fff">KEY</span>' },
                { id: 'ali', name: 'Ali', preview: '<span style="text-shadow:0 0 8px rgba(236,72,153,0.8);color:#ec4899">Glow</span>' },
                { id: 'custom', name: 'Custom', preview: '' }
            ];

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Captions
                        <span style="margin-left: auto; font-size: 0.7rem; color: rgba(255,255,255,0.5); padding: 0.2rem 0.5rem; background: rgba(255,255,255,0.05); border-radius: 0.25rem;">8 Styles</span>
                    </div>

                    <!-- Style Selection Grid - 4 columns like video-wizard -->
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">
                        ${captionStyles.map(style => `
                            <button onclick="setCaptionStyle('${style.id}')"
                                    style="padding: 0.5rem 0.25rem; border-radius: 0.5rem; border: 2px solid ${selectedStyle === style.id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.1)'}; background: ${selectedStyle === style.id ? 'rgba(139, 92, 246, 0.15)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; text-align: center; transition: all 0.2s; position: relative;">
                                <div style="height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; margin-bottom: 0.25rem;">
                                    ${style.preview}
                                </div>
                                <div style="font-size: 0.65rem; color: rgba(255,255,255,0.7);">${style.name}</div>
                                ${selectedStyle === style.id ? '<div style="position: absolute; top: 2px; right: 2px; width: 8px; height: 8px; background: #8b5cf6; border-radius: 50%;"></div>' : ''}
                            </button>
                        `).join('')}
                    </div>

                    <!-- Position and Size Controls -->
                    <div style="display: flex; gap: 0.75rem; opacity: ${selectedStyle === 'none' ? '0.4' : '1'}; pointer-events: ${selectedStyle === 'none' ? 'none' : 'auto'};">
                        <!-- Position -->
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Position</label>
                            <select onchange="setCaptionPosition(this.value)"
                                    style="width: 100%; padding: 0.4rem; background: rgba(30,30,30,0.9); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                <option value="bottom" ${position === 'bottom' ? 'selected' : ''}> Bottom</option>
                                <option value="middle" ${position === 'middle' || position === 'center' ? 'selected' : ''}> Middle</option>
                                <option value="top" ${position === 'top' ? 'selected' : ''}> Top</option>
                            </select>
                        </div>

                        <!-- Size (numeric like video-wizard) -->
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem;">Size</label>
                            <select onchange="setCaptionSize(this.value)"
                                    style="width: 100%; padding: 0.4rem; background: rgba(30,30,30,0.9); border: 1px solid rgba(255,255,255,0.15); border-radius: 0.4rem; color: white; font-size: 0.75rem; cursor: pointer;">
                                <option value="0.7" ${size == 0.7 ? 'selected' : ''}>70%</option>
                                <option value="0.85" ${size == 0.85 ? 'selected' : ''}>85%</option>
                                <option value="1" ${size == 1 ? 'selected' : ''}>100%</option>
                                <option value="1.15" ${size == 1.15 ? 'selected' : ''}>115%</option>
                                <option value="1.3" ${size == 1.3 ? 'selected' : ''}>130%</option>
                                <option value="1.5" ${size == 1.5 ? 'selected' : ''}>150%</option>
                            </select>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAudioMixSettings() {
            const voiceVolume = state.assembly.audioMix?.voiceVolume || 100;
            const musicVolume = state.assembly.audioMix?.musicVolume || 30;

            return `
                <div class="content-card" style="padding: 1rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Audio Mix
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                        <div>
                            <label style="display: flex; justify-content: space-between; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">
                                <span> Voiceover</span>
                                <span>${voiceVolume}%</span>
                            </label>
                            <input type="range" min="0" max="100" value="${voiceVolume}"
                                   onchange="setVoiceVolume(this.value)"
                                   style="width: 100%; height: 6px; cursor: pointer;">
                        </div>

                        <div>
                            <label style="display: flex; justify-content: space-between; font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.4rem;">
                                <span> Music</span>
                                <span>${musicVolume}%</span>
                            </label>
                            <input type="range" min="0" max="100" value="${musicVolume}"
                                   onchange="setAudioMixMusicVolume(this.value)"
                                   style="width: 100%; height: 6px; cursor: pointer;">
                        </div>
                    </div>
                </div>
            `;
        }

        // Assembly Functions
        function moveSceneInOrder(sceneId, direction) {
            const order = state.assembly.sceneOrder.length > 0
                ? [...state.assembly.sceneOrder]
                : state.script.scenes.map(s => s.id);

            const currentIndex = order.indexOf(sceneId);
            const newIndex = currentIndex + direction;

            if (newIndex >= 0 && newIndex < order.length) {
                [order[currentIndex], order[newIndex]] = [order[newIndex], order[currentIndex]];
                state.assembly.sceneOrder = order;
                saveProject();
                render();
            }
        }

        function setSceneTransition(sceneId, transitionType) {
            state.assembly.transitions[sceneId] = { type: transitionType };
            saveProject();
            // Update preview engine transitions
            updatePreviewTransitions();
        }

        function toggleMusic(enabled) {
            state.assembly.music.enabled = enabled;
            saveProject();
            // Update preview music
            updatePreviewMusic();
            render();
        }

        function selectMusicTrack(trackId) {
            state.assembly.music.trackId = trackId;
            if (trackId && trackId !== 'none') {
                state.assembly.music.enabled = true;
            }
            saveProject();
            // Update preview music
            updatePreviewMusic();
            render();
        }

        function setMusicVolume(volume) {
            state.assembly.music.volume = parseInt(volume);
            saveProject();
            // Update preview music volume
            if (previewEngine) {
                previewEngine.musicVolume = volume / 100;
            }
        }

        function toggleCaptions(enabled) {
            state.assembly.captions.enabled = enabled;
            saveProject();
            // Update preview captions
            if (previewEngine) {
                previewEngine.captionsEnabled = enabled;
            }
            render();
        }

        function setCaptionStyle(style) {
            state.assembly.captions.style = style;
            saveProject();
            // Update preview caption style
            if (previewEngine) {
                previewEngine.captionStyle = style;
            }
            render();
        }

        function setCaptionPosition(position) {
            state.assembly.captions.position = position;
            saveProject();
            // Update preview caption position
            if (previewEngine) {
                previewEngine.captionPosition = position;
            }
            render();
        }

        function setCaptionSize(size) {
            state.assembly.captions.size = parseFloat(size);
            saveProject();
            // Update preview caption size
            if (previewEngine) {
                previewEngine.captionSize = parseFloat(size);
            }
            render();
        }

        function setVoiceVolume(volume) {
            if (!state.assembly.audioMix) state.assembly.audioMix = {};
            state.assembly.audioMix.voiceVolume = parseInt(volume);
            saveProject();
            // Update preview voice volume
            if (previewEngine) {
                previewEngine.voiceVolume = volume / 100;
            }
            render();
        }

        function setAudioMixMusicVolume(volume) {
            if (!state.assembly.audioMix) state.assembly.audioMix = {};
            state.assembly.audioMix.musicVolume = parseInt(volume);
            saveProject();
            // Update preview music volume
            if (previewEngine) {
                previewEngine.musicVolume = volume / 100;
            }
            render();
        }

        // Phase 4: Enhanced audio controls
        function setAudioDucking(enabled) {
            if (!state.assembly.audioMix) state.assembly.audioMix = {};
            state.assembly.audioMix.ducking = enabled;
            saveProject();
            render();
        }

        function setMusicFadeIn(seconds) {
            state.assembly.music.fadeIn = parseFloat(seconds);
            saveProject();
            render();
        }

        function setMusicFadeOut(seconds) {
            state.assembly.music.fadeOut = parseFloat(seconds);
            saveProject();
            render();
        }

        // Phase 4: Media tab functions
        function jumpToScene(sceneIndex) {
            if (!previewEngine) return;
            const scriptScenes = state.script.scenes || [];
            let targetTime = 0;
            for (let i = 0; i < sceneIndex; i++) {
                targetTime += scriptScenes[i]?.visualDuration || scriptScenes[i]?.duration || 5;
            }
            previewEngine.seek(targetTime);
            state.preview.currentSceneIndex = sceneIndex;
            render();
        }

        function regenerateSceneImage(sceneIndex) {
            const scriptScenes = state.script.scenes || [];
            const scene = scriptScenes[sceneIndex];
            if (!scene) return;
            // Trigger regeneration - would call storyboard generation function
            console.log('Regenerate scene image:', sceneIndex, scene.id);
            showNotification('Image regeneration coming soon!', 'info');
        }

        // Phase 4: Transitions tab functions
        function setGlobalTransitionDuration(duration) {
            state.assembly.transitionDuration = parseFloat(duration);
            saveProject();
            render();
        }

        function applyTransitionToAll(transitionType) {
            const scriptScenes = state.script.scenes || [];
            const duration = state.assembly.transitionDuration ?? 0.5;
            scriptScenes.slice(0, -1).forEach(scene => {
                state.assembly.transitions[scene.id] = { type: transitionType, duration };
            });
            saveProject();
            updatePreviewTransitions();
            render();
        }

        function setTransitionDuration(sceneId, duration) {
            if (!state.assembly.transitions[sceneId]) {
                state.assembly.transitions[sceneId] = { type: 'fade' };
            }
            state.assembly.transitions[sceneId].duration = parseFloat(duration);
            saveProject();
            updatePreviewTransitions();
        }

        // Helper functions to update preview settings
        function updatePreviewTransitions() {
            if (!previewEngine || !state.preview.isReady) return;
            // Update transition settings in preview engine scenes
            previewEngine.scenes.forEach(scene => {
                const transition = state.assembly.transitions[scene.id] || { type: 'cut' };
                scene.transition = transition.type;
                scene.transitionDuration = transition.duration || 0.5;
            });
        }

        async function updatePreviewMusic() {
            if (!previewEngine || !state.preview.isReady) return;

            if (state.assembly.music.enabled && state.assembly.music.trackId) {
                const track = state.assembly.musicLibrary.find(t => t.id === state.assembly.music.trackId);
                if (track?.url) {
                    try {
                        await previewEngine.setBackgroundMusic(track.url, state.assembly.music.volume / 100);
                    } catch (e) {
                        console.error('Failed to update music:', e);
                    }
                }
            } else {
                // Disable music
                previewEngine.stopBackgroundMusic();
            }
        }

        async function saveAssemblySettings() {
            try {
                const updateAssembly = firebase.functions().httpsCallable('creationWizardUpdateAssembly');
                await updateAssembly({
                    projectId: state.project.id,
                    assembly: {
                        status: 'ready',
                        sceneOrder: state.assembly.sceneOrder,
                        transitions: state.assembly.transitions,
                        music: state.assembly.music,
                        captions: state.assembly.captions,
                        audioMix: state.assembly.audioMix
                    }
                });
                state.assembly.status = 'ready';
                showToast('Assembly settings saved!', 'success');
                saveProject();
                render();
            } catch (error) {
                console.error('Failed to save assembly:', error);
                showToast('Failed to save assembly settings', 'error');
            }
        }

        // ==========================================
        // 7.10.1 VIDEO PREVIEW ENGINE CONTROLS
        // ==========================================

        let previewEngine = null;

        async function initializePreviewEngine() {
            const canvas = document.getElementById('preview-canvas');
            if (!canvas) {
                console.error('Preview canvas not found');
                return;
            }

            // Update state to show loading
            state.preview.loadProgress = 1;
            render();

            // Create the engine
            previewEngine = new VideoPreviewEngine(canvas, {
                width: 1280,
                height: 720,
                onTimeUpdate: (time) => {
                    state.preview.currentTime = time;

                    // Update scrubber without full re-render
                    const scrubber = document.getElementById('preview-scrubber');
                    if (scrubber) {
                        scrubber.value = time;
                        const percent = (time / state.preview.totalDuration) * 100;
                        scrubber.style.background = `linear-gradient(to right, #8b5cf6 0%, #8b5cf6 ${percent}%, rgba(255,255,255,0.2) ${percent}%, rgba(255,255,255,0.2) 100%)`;
                    }

                    // Update time display without full re-render
                    const timeDisplay = document.getElementById('preview-time-display');
                    if (timeDisplay) {
                        timeDisplay.textContent = `${formatDuration(time)} / ${formatDuration(state.preview.totalDuration)}`;
                    }

                    // Update scene progress bar
                    updateSceneProgress(time);
                },
                onSceneChange: (sceneIndex) => {
                    state.preview.currentSceneIndex = sceneIndex;
                    highlightTimelineScene(sceneIndex);
                    updateCurrentSceneIndicator(sceneIndex);
                    // NO render() - prevents flickering during playback
                },
                onEnded: () => {
                    state.preview.isPlaying = false;
                    state.preview.currentTime = 0;
                    updatePreviewPlayButton(false);
                    // NO render() - selective update only
                },
                onLoadProgress: (progress) => {
                    state.preview.loadProgress = progress;
                    updatePreviewLoadProgress(progress);
                    // NO render() - selective update only
                },
                onReady: () => {
                    state.preview.isReady = true;
                    state.preview.loadProgress = 100;
                    updatePreviewLoadProgress(100);
                    updatePreviewPlayButton(false);
                    // NO render() - selective update only
                }
            });

            // Build scenes array from current state
            const scenes = buildPreviewScenes();
            state.preview.totalDuration = scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

            try {
                await previewEngine.loadScenes(scenes);

                // Set caption settings - unified style-aware system
                const captions = state.assembly.captions;
                previewEngine.captionsEnabled = captions.enabled;
                previewEngine.captionStyle = captions.style;
                previewEngine.captionPosition = captions.position;
                previewEngine.captionSize = captions.size || 1;
                // Enhanced settings (Phase 2)
                previewEngine.captionMode = captions.mode || 'word';
                previewEngine.captionFontFamily = captions.fontFamily || 'Montserrat';
                previewEngine.captionFillColor = captions.fillColor || '#FFFFFF';
                previewEngine.captionStrokeColor = captions.strokeColor || '#000000';
                previewEngine.captionStrokeWidth = captions.strokeWidth || 2;
                previewEngine.captionEffect = captions.effect || 'none';
                previewEngine.captionHighlightColor = captions.highlightColor || '#FBBF24';

                // Set music if enabled
                if (state.assembly.music.enabled && state.assembly.music.trackId) {
                    const track = state.assembly.musicLibrary.find(t => t.id === state.assembly.music.trackId);
                    if (track?.url) {
                        await previewEngine.setBackgroundMusic(track.url, state.assembly.music.volume / 100);
                    }
                }

            } catch (error) {
                console.error('Failed to initialize preview:', error);
                showToast('Failed to load preview', 'error');
                state.preview.loadProgress = 0;
                render();
            }
        }

        function buildPreviewScenes() {
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            return sceneOrder.map(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = storyboardScenes.find(s => s.sceneId === sceneId);
                const transition = state.assembly.transitions[sceneId] || { type: 'cut' };

                if (!scriptScene) return null;

                return {
                    id: sceneId,
                    type: animScene?.videoUrl ? 'video' : (storyboardScene?.source === 'stock-video' ? 'video' : 'image'),
                    imageUrl: storyboardScene?.imageUrl,
                    videoUrl: animScene?.videoUrl || (storyboardScene?.source === 'stock-video' ? storyboardScene?.videoUrl : null),
                    duration: scriptScene.duration || 8,
                    voiceoverUrl: animScene?.voiceoverUrl,
                    voiceoverDuration: animScene?.voiceoverDuration,
                    voiceoverOffset: scriptScene.voiceoverOffset || 0,
                    caption: scriptScene.narration,
                    transition: transition.type,
                    transitionDuration: transition.duration || 0.5,
                    kenBurns: {
                        startZoom: 1.0,
                        endZoom: 1.15,
                        startX: 0.5 + (Math.random() - 0.5) * 0.1,
                        startY: 0.5 + (Math.random() - 0.5) * 0.1,
                        endX: 0.5 + (Math.random() - 0.5) * 0.1,
                        endY: 0.5 + (Math.random() - 0.5) * 0.1
                    }
                };
            }).filter(Boolean);
        }

        function togglePreviewPlayback() {
            if (!previewEngine || !state.preview.isReady) return;

            if (state.preview.isPlaying) {
                previewEngine.pause();
                state.preview.isPlaying = false;
            } else {
                previewEngine.play();
                state.preview.isPlaying = true;
            }
            updatePreviewPlayButton(state.preview.isPlaying);
            // NO render() - selective update prevents flickering
        }

        function stopPreview() {
            if (!previewEngine || !state.preview.isReady) return;

            previewEngine.pause();
            previewEngine.seek(0);
            state.preview.isPlaying = false;
            state.preview.currentTime = 0;
            state.preview.currentSceneIndex = 0;
            updatePreviewPlayButton(false);
            highlightTimelineScene(0);
            updateCurrentSceneIndicator(0);
            // NO render() - selective update prevents flickering
        }

        function seekPreview(time) {
            if (!previewEngine || !state.preview.isReady) return;

            const newTime = parseFloat(time);
            previewEngine.seek(newTime);
            state.preview.currentTime = newTime;
        }

        function updateScrubberPreview(time) {
            // Visual feedback while dragging - update time display
            state.preview.currentTime = parseFloat(time);
            const timeDisplay = document.querySelector('[style*="font-family: monospace"]');
            if (timeDisplay) {
                timeDisplay.textContent = `${formatDuration(parseFloat(time))} / ${formatDuration(state.preview.totalDuration)}`;
            }
        }

        function setPreviewVolume(volume) {
            state.preview.volume = parseInt(volume);
            if (previewEngine) {
                previewEngine.voiceVolume = volume / 100;
            }
        }

        function prevPreviewScene() {
            if (!previewEngine || !state.preview.isReady) return;
            if (state.preview.currentSceneIndex > 0) {
                const newIndex = state.preview.currentSceneIndex - 1;
                const scenes = previewEngine.scenes;
                if (scenes[newIndex]) {
                    previewEngine.seek(scenes[newIndex].startTime);
                    state.preview.currentSceneIndex = newIndex;
                    state.preview.currentTime = scenes[newIndex].startTime;
                    highlightTimelineScene(newIndex);
                    updateCurrentSceneIndicator(newIndex);
                    // NO render() - selective update prevents flickering
                }
            }
        }

        function nextPreviewScene() {
            if (!previewEngine || !state.preview.isReady) return;
            const scriptScenes = state.script.scenes || [];
            if (state.preview.currentSceneIndex < scriptScenes.length - 1) {
                const newIndex = state.preview.currentSceneIndex + 1;
                const scenes = previewEngine.scenes;
                if (scenes[newIndex]) {
                    previewEngine.seek(scenes[newIndex].startTime);
                    state.preview.currentSceneIndex = newIndex;
                    state.preview.currentTime = scenes[newIndex].startTime;
                    highlightTimelineScene(newIndex);
                    updateCurrentSceneIndicator(newIndex);
                    // NO render() - selective update prevents flickering
                }
            }
        }

        function seekToScene(sceneId) {
            if (!previewEngine || !state.preview.isReady) return;

            const sceneIndex = previewEngine.scenes.findIndex(s => s.id === sceneId);
            if (sceneIndex >= 0) {
                const scene = previewEngine.scenes[sceneIndex];
                previewEngine.seek(scene.startTime);
                state.preview.currentSceneIndex = sceneIndex;
                state.preview.currentTime = scene.startTime;
                render();
            }
        }

        function highlightTimelineScene(sceneIndex) {
            // Highlight the currently playing scene in the timeline
            const timelineScenes = document.querySelectorAll('.timeline-scene');
            timelineScenes.forEach((el, idx) => {
                const progressFill = el.querySelector('.scene-progress-fill');
                if (idx === sceneIndex) {
                    el.style.borderColor = 'rgba(139, 92, 246, 0.8)';
                    el.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.4)';
                    el.style.background = 'rgba(139, 92, 246, 0.1)';
                    el.dataset.playing = 'true';
                } else {
                    el.style.borderColor = 'rgba(255,255,255,0.1)';
                    el.style.boxShadow = 'none';
                    el.style.background = 'rgba(255,255,255,0.03)';
                    delete el.dataset.playing;
                    // Reset progress bar for non-current scenes
                    if (progressFill) progressFill.style.width = '0%';
                }
            });
        }

        function updateSceneProgress(currentTime) {
            if (!previewEngine || !state.preview.isReady) return;

            const scenes = previewEngine.scenes;
            const currentSceneIndex = state.preview.currentSceneIndex;
            const currentScene = scenes[currentSceneIndex];

            if (!currentScene) return;

            // Calculate progress within the current scene
            const sceneStartTime = currentScene.startTime;
            const sceneDuration = currentScene.duration || 8;
            const timeInScene = currentTime - sceneStartTime;
            const progress = Math.min(100, Math.max(0, (timeInScene / sceneDuration) * 100));

            // Update the progress bar for the current scene
            const currentSceneEl = document.querySelector(`.timeline-scene[data-scene-index="${currentSceneIndex}"]`);
            if (currentSceneEl) {
                const progressFill = currentSceneEl.querySelector('.scene-progress-fill');
                if (progressFill) {
                    progressFill.style.width = `${progress}%`;
                }
            }
        }

        // ==========================================
        // SELECTIVE DOM UPDATE FUNCTIONS (Prevent Flickering)
        // These functions update specific UI elements without full re-render
        // ==========================================

        function updatePreviewPlayButton(isPlaying) {
            // Update Assembly step play button (uses text characters)
            const playBtn = document.getElementById('preview-play-btn');
            if (playBtn) {
                playBtn.innerHTML = isPlaying ? '' : '';
            }

            // Update center play overlay visibility
            const playOverlay = document.getElementById('preview-play-overlay');
            if (playOverlay) {
                playOverlay.style.opacity = isPlaying ? '0' : '1';
                playOverlay.style.pointerEvents = isPlaying ? 'none' : 'auto';
                playOverlay.style.background = 'rgba(0,0,0,0.3)';
            }

            // Update Timeline step play button if on that step (uses text characters)
            const timelinePlayBtn = document.getElementById('timeline-play-btn');
            if (timelinePlayBtn) {
                timelinePlayBtn.innerHTML = isPlaying ? '' : '';
            }
        }

        function updatePreviewLoadProgress(progress) {
            // Update loading indicator
            const loadingOverlay = document.getElementById('preview-loading-overlay');
            if (loadingOverlay) {
                if (progress >= 100) {
                    loadingOverlay.style.display = 'none';
                } else {
                    loadingOverlay.style.display = 'flex';
                    const progressText = loadingOverlay.querySelector('.loading-progress-text');
                    if (progressText) {
                        progressText.textContent = `Loading... ${Math.round(progress)}%`;
                    }
                }
            }

            // Update progress bar if exists
            const progressBar = document.getElementById('preview-load-bar');
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        function updateCurrentSceneIndicator(sceneIndex) {
            // Update scene info panel with current scene narration
            const sceneInfo = document.getElementById('current-scene-info');
            if (sceneInfo && state.script.scenes) {
                const scene = state.script.scenes[sceneIndex];
                if (scene) {
                    const narrationPreview = (scene.narration || 'No scene loaded').substring(0, 35);
                    const ellipsis = scene.narration?.length > 35 ? '...' : '';
                    sceneInfo.textContent = `Scene ${sceneIndex + 1}: "${narrationPreview}${ellipsis}"`;
                }
            }
        }

        // Cleanup preview when leaving Assembly step
        function cleanupPreviewEngine() {
            if (previewEngine) {
                previewEngine.pause();
                previewEngine.destroy();
                previewEngine = null;
            }
            state.preview.isReady = false;
            state.preview.isPlaying = false;
            state.preview.loadProgress = 0;
        }

        // Keyboard shortcuts for preview playback (works on Assembly and Export steps)
        document.addEventListener('keydown', function(e) {
            // Only handle when on Assembly or Export step and preview is ready
            if ((state.currentStep !== 6 && state.currentStep !== 7) || !state.preview.isReady) return;

            // Don't handle if user is typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

            // Use timeline functions on Export step, preview functions on Assembly
            const isTimeline = state.currentStep === 7;

            switch(e.code) {
                case 'Space':
                    e.preventDefault();
                    isTimeline ? toggleTimelinePlayback() : togglePreviewPlayback();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Left: Previous scene
                        prevPreviewScene();
                    } else {
                        // Left: Seek back 5 seconds
                        const newTime = Math.max(0, state.preview.currentTime - 5);
                        if (isTimeline) {
                            previewEngine?.seek(newTime);
                            state.preview.currentTime = newTime;
                            updateTimelinePlayhead(newTime);
                        } else {
                            seekPreview(newTime);
                        }
                    }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Right: Next scene
                        nextPreviewScene();
                    } else {
                        // Right: Seek forward 5 seconds
                        const newTime = Math.min(state.preview.totalDuration, state.preview.currentTime + 5);
                        if (isTimeline) {
                            previewEngine?.seek(newTime);
                            state.preview.currentTime = newTime;
                            updateTimelinePlayhead(newTime);
                        } else {
                            seekPreview(newTime);
                        }
                    }
                    break;
                case 'Home':
                    e.preventDefault();
                    if (isTimeline) {
                        seekTimelineStart();
                    } else {
                        seekPreview(0);
                    }
                    break;
                case 'End':
                    e.preventDefault();
                    if (isTimeline) {
                        seekTimelineEnd();
                    } else {
                        seekPreview(state.preview.totalDuration - 0.1);
                    }
                    break;
                case 'KeyM':
                    e.preventDefault();
                    // Toggle mute
                    if (state.preview.volume > 0) {
                        state.preview.previousVolume = state.preview.volume;
                        setPreviewVolume(0);
                    } else {
                        setPreviewVolume(state.preview.previousVolume || 100);
                    }
                    render();
                    break;

                // Edit shortcuts (only on Export step timeline)
                case 'KeyZ':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.shiftKey) {
                            redoEdit();
                        } else {
                            undoEdit();
                        }
                    }
                    break;
                case 'KeyY':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        redoEdit();
                    }
                    break;
                case 'KeyS':
                    if (!e.ctrlKey && !e.metaKey && isTimeline) {
                        e.preventDefault();
                        splitClipAtPlayhead();
                    }
                    break;
                case 'KeyD':
                    if ((e.ctrlKey || e.metaKey) && isTimeline) {
                        e.preventDefault();
                        duplicateSelectedClip();
                    }
                    break;
                case 'Delete':
                case 'Backspace':
                    if (isTimeline && state.timeline.selectedClipId !== null) {
                        e.preventDefault();
                        deleteSelectedClip();
                    }
                    break;
            }
        });

        // ==========================================
        // 7.11 STEP 7: EXPORT
        // ==========================================

        const EXPORT_QUALITIES = {
            '720p': { name: '720p HD', description: 'Good quality, smaller file', icon: '' },
            '1080p': { name: '1080p Full HD', description: 'High quality, recommended', icon: '' },
            '4k': { name: '4K Ultra HD', description: 'Maximum quality, large file', icon: '' }
        };

        // ==========================================
        // FULL-SCREEN EDITOR LAYOUT (Step 7)
        // ==========================================

        function renderFullScreenEditor() {
            const exportState = state.export || {};
            const isExporting = exportState.status === 'exporting' || exportState.status === 'processing';
            const isCompleted = exportState.status === 'completed';
            const isFailed = exportState.status === 'failed' || exportState.status === 'error';
            const progress = exportState.progress || 0;

            // Calculate video summary
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const animatedCount = animationScenes.filter(s => s.videoUrl).length;
            const imageCount = storyboardScenes.filter(s => s.imageUrl).length;
            const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.duration || 8), 0);
            const platform = PLATFORM_PRESETS[state.platform.selected] || {};

            const { zoom, scrollLeft, selectedClipId, snapToGrid } = state.timeline;
            const { isReady, isPlaying, currentTime } = state.preview;
            const timelineWidth = totalDuration * zoom;

            const canExport = animatedCount > 0 || imageCount > 0;
            const selectedQuality = state.export.selectedQuality || '1080p';

            // If exporting, completed, or failed - show overlay modal
            if (isExporting || isCompleted || isFailed) {
                return renderFullScreenEditorWithModal(exportState, isExporting, isCompleted, isFailed, progress);
            }

            return `
                <div class="fullscreen-editor" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100vw;
                    height: 100vh;
                    background: #0a0a0f;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    z-index: 1000;
                ">
                    <!-- Top Bar -->
                    <div style="
                        height: 50px;
                        min-height: 50px;
                        background: rgba(20, 20, 30, 0.95);
                        border-bottom: 1px solid rgba(255,255,255,0.1);
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 0 1rem;
                    ">
                        <!-- Left: Back Button -->
                        <button onclick="goToStep(6)" style="
                            padding: 0.5rem 1rem;
                            border-radius: 0.4rem;
                            border: 1px solid rgba(255,255,255,0.2);
                            background: transparent;
                            color: white;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            gap: 0.5rem;
                            font-size: 0.85rem;
                        ">
                            <span></span> Back to Assembly
                        </button>

                        <!-- Center: Project Info -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="font-size: 0.9rem; font-weight: 600; color: white;">Timeline Editor</span>
                            <span style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">${formatDuration(totalDuration)}</span>
                        </div>

                        <!-- Right: Export Controls -->
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <!-- Quality Selector -->
                            <select onchange="setExportQuality(this.value)" style="
                                padding: 0.4rem 0.6rem;
                                border-radius: 0.3rem;
                                border: 1px solid rgba(255,255,255,0.2);
                                background: rgba(0,0,0,0.3);
                                color: white;
                                font-size: 0.8rem;
                                cursor: pointer;
                            ">
                                ${Object.entries(EXPORT_QUALITIES).map(([id, q]) => `
                                    <option value="${id}" ${selectedQuality === id ? 'selected' : ''}>${q.icon} ${id}</option>
                                `).join('')}
                            </select>

                            <!-- Export Button -->
                            <button onclick="startExport()" ${!canExport ? 'disabled' : ''} style="
                                padding: 0.5rem 1.5rem;
                                border-radius: 0.4rem;
                                border: none;
                                background: ${canExport ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'};
                                color: ${canExport ? 'white' : 'rgba(255,255,255,0.4)'};
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: ${canExport ? 'pointer' : 'not-allowed'};
                                display: flex;
                                align-items: center;
                                gap: 0.5rem;
                            ">
                                <span></span> Export
                            </button>
                        </div>
                    </div>

                    <!-- Main Content Area -->
                    <div style="
                        flex: 1;
                        display: grid;
                        grid-template-columns: 1fr 280px;
                        min-height: 0;
                        overflow: hidden;
                    ">
                        <!-- Left: Preview Player -->
                        <div style="
                            display: flex;
                            flex-direction: column;
                            background: #000;
                            padding: 1rem;
                            min-height: 0;
                            overflow: hidden;
                        ">
                            <!-- Preview Container -->
                            <div style="
                                flex: 1;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                min-height: 0;
                            ">
                                <div style="
                                    position: relative;
                                    width: 100%;
                                    max-width: calc((100vh - 280px) * 16 / 9);
                                    aspect-ratio: 16/9;
                                    background: #111;
                                    border-radius: 0.5rem;
                                    overflow: hidden;
                                ">
                                    <canvas id="timeline-preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                                    <!-- Play overlay -->
                                    ${!isReady ? `
                                        <div style="position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7);">
                                            <button onclick="initializeTimelinePreview()" style="padding: 1rem 2rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; font-size: 1rem;">
                                                <span style="font-size: 1.5rem;"></span> Load Preview
                                            </button>
                                        </div>
                                    ` : (!isPlaying ? `
                                        <div onclick="toggleTimelinePlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
                                            <div style="width: 70px; height: 70px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                                <span style="font-size: 2rem; margin-left: 5px;"></span>
                                            </div>
                                        </div>
                                    ` : '')}
                                </div>
                            </div>

                            <!-- Transport Controls -->
                            <div style="
                                height: 50px;
                                min-height: 50px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 1rem;
                                background: rgba(0,0,0,0.5);
                                border-radius: 0.5rem;
                                margin-top: 0.75rem;
                                padding: 0 1rem;
                            ">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <button onclick="seekTimelineStart()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                    <button onclick="toggleTimelinePlayback()" ${!isReady ? 'disabled' : ''} style="width: 44px; height: 44px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 1.1rem;">${isPlaying ? '' : ''}</button>
                                    <button onclick="seekTimelineEnd()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                </div>

                                <!-- Time Display -->
                                <div style="font-family: monospace; font-size: 1.1rem; color: white; background: rgba(0,0,0,0.5); padding: 0.4rem 0.75rem; border-radius: 0.25rem;">
                                    ${formatTimecode(currentTime)} <span style="color: rgba(255,255,255,0.4);">/</span> ${formatTimecode(totalDuration)}
                                </div>

                                <div style="flex: 1;"></div>

                                <!-- Volume -->
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem;">${state.preview.volume > 0 ? '' : ''}</span>
                                    <input type="range" min="0" max="100" value="${state.preview.volume || 100}" onchange="setTimelineVolume(this.value)" style="width: 80px; height: 4px; cursor: pointer;">
                                </div>
                            </div>
                        </div>

                        <!-- Right: Sidebar -->
                        <div style="
                            background: rgba(15, 15, 25, 0.95);
                            border-left: 1px solid rgba(255,255,255,0.1);
                            display: flex;
                            flex-direction: column;
                            overflow-y: auto;
                        ">
                            ${renderFullScreenClipInspector(selectedClipId, scriptScenes, animationScenes)}
                            ${renderFullScreenExportSettings(canExport, animatedCount, imageCount, scriptScenes.length)}
                        </div>
                    </div>

                    <!-- Bottom: Professional Timeline -->
                    ${renderProfessionalTimeline(scriptScenes, animationScenes, totalDuration, zoom, snapToGrid, selectedClipId, currentTime, isReady)}
                </div>
            `;
        }

        function renderFullScreenEditorWithModal(exportState, isExporting, isCompleted, isFailed, progress) {
            // Base editor layout with modal overlay
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.duration || 8), 0);

            let modalContent = '';

            if (isExporting) {
                modalContent = `
                    <div style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <h2 style="color: white; margin-bottom: 0.5rem;">Exporting Video...</h2>
                        <p style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">
                            ${exportState.stage || 'Processing your video'}
                        </p>
                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 0.5rem;">
                            <div style="width: ${progress}%; height: 100%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); transition: width 0.3s;"></div>
                        </div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.5);">${Math.round(progress)}% complete</div>
                    </div>
                `;
            } else if (isCompleted && exportState.outputUrl) {
                modalContent = `
                    <div style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <h2 style="color: white; margin-bottom: 0.5rem;">Export Complete!</h2>
                        <p style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">Your video is ready to download</p>
                        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                            <a href="${exportState.outputUrl}" download style="
                                padding: 0.75rem 1.5rem;
                                border-radius: 0.5rem;
                                background: linear-gradient(135deg, #8b5cf6, #06b6d4);
                                color: white;
                                text-decoration: none;
                                font-weight: 600;
                                display: flex;
                                align-items: center;
                                gap: 0.5rem;
                            "> Download Video</a>
                            <button onclick="resetExport()" style="
                                padding: 0.75rem 1.5rem;
                                border-radius: 0.5rem;
                                border: 1px solid rgba(255,255,255,0.3);
                                background: transparent;
                                color: white;
                                cursor: pointer;
                                font-weight: 600;
                            ">Export Another</button>
                        </div>
                    </div>
                `;
            } else if (isFailed) {
                modalContent = `
                    <div style="text-align: center; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                        <h2 style="color: #ef4444; margin-bottom: 0.5rem;">Export Failed</h2>
                        <p style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">
                            ${exportState.error || 'An error occurred during export'}
                        </p>
                        <button onclick="resetExport()" style="
                            padding: 0.75rem 1.5rem;
                            border-radius: 0.5rem;
                            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
                            color: white;
                            border: none;
                            cursor: pointer;
                            font-weight: 600;
                        ">Try Again</button>
                    </div>
                `;
            }

            return `
                <div class="fullscreen-editor" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100vw;
                    height: 100vh;
                    background: #0a0a0f;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    z-index: 1000;
                ">
                    <!-- Darkened background -->
                    <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1001;">
                        <div style="
                            background: rgba(30, 30, 45, 0.98);
                            border: 1px solid rgba(255,255,255,0.1);
                            border-radius: 1rem;
                            min-width: 400px;
                            max-width: 500px;
                            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                        ">
                            ${modalContent}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderFullScreenClipInspector(selectedClipId, scriptScenes, animationScenes) {
            if (!selectedClipId) {
                return `
                    <div style="padding: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.4rem;">
                            <span></span> Clip Inspector
                        </div>
                        <div style="text-align: center; padding: 1.5rem 0.5rem; color: rgba(255,255,255,0.4); font-size: 0.75rem;">
                            Select a clip in the timeline
                        </div>
                    </div>
                `;
            }

            const scriptScene = scriptScenes.find(s => s.id === selectedClipId);
            const animScene = animationScenes.find(s => s.sceneId === selectedClipId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === selectedClipId);
            const transition = state.assembly.transitions[selectedClipId] || { type: 'cut' };

            if (!scriptScene) return '';

            const sceneIndex = scriptScenes.findIndex(s => s.id === selectedClipId) + 1;

            return `
                <div style="padding: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.4rem;">
                        <span></span> Scene ${sceneIndex}
                    </div>

                    <!-- Thumbnail -->
                    <div style="width: 100%; aspect-ratio: 16/9; background: rgba(0,0,0,0.3); border-radius: 0.3rem; overflow: hidden; margin-bottom: 0.6rem;">
                        ${storyboardScene?.imageUrl ? `<img src="${storyboardScene.imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` : '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 0.7rem;">No image</div>'}
                    </div>

                    <!-- Properties -->
                    <div style="display: flex; flex-direction: column; gap: 0.5rem; font-size: 0.7rem;">
                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.15rem;">Duration</label>
                            <div style="display: flex; align-items: center; gap: 0.4rem;">
                                <input type="number" value="${scriptScene.duration || 8}" min="1" max="60" step="0.5"
                                       onchange="updateClipDuration(${selectedClipId}, this.value)"
                                       style="flex: 1; padding: 0.35rem; border-radius: 0.2rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.75rem;">
                                <span style="color: rgba(255,255,255,0.5);">sec</span>
                            </div>
                        </div>

                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.15rem;">Transition</label>
                            <select onchange="updateClipTransition(${selectedClipId}, this.value)"
                                    style="width: 100%; padding: 0.35rem; border-radius: 0.2rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.75rem;">
                                ${(state.assembly.transitionTypes || []).map(t => `
                                    <option value="${t.id}" ${transition.type === t.id ? 'selected' : ''}>${t.name}</option>
                                `).join('')}
                            </select>
                        </div>

                        <div style="display: flex; gap: 0.4rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Voice</span>
                                <div style="color: ${animScene?.voiceoverUrl ? '#10b981' : 'rgba(255,255,255,0.4)'}; margin-top: 0.1rem;">
                                    ${animScene?.voiceoverUrl ? '' : ''}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Video</span>
                                <div style="color: ${animScene?.videoUrl ? '#10b981' : (storyboardScene?.source === 'stock-video' ? '#06b6d4' : '#f59e0b')}; margin-top: 0.1rem;">
                                    ${animScene?.videoUrl ? ' Anim' : (storyboardScene?.source === 'stock-video' ? ' Stock' : ' Img')}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderFullScreenExportSettings(canExport, animatedCount, imageCount, totalScenes) {
            return `
                <div style="padding: 1rem; flex: 1;">
                    <div style="font-size: 0.8rem; font-weight: 600; color: white; margin-bottom: 0.6rem; display: flex; align-items: center; gap: 0.4rem;">
                        <span></span> Video Summary
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem; font-size: 0.7rem; margin-bottom: 0.75rem;">
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Scenes</div>
                            <div style="color: white;">${totalScenes}</div>
                        </div>
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Animated</div>
                            <div style="color: ${animatedCount === totalScenes ? '#10b981' : animatedCount > 0 ? '#06b6d4' : 'rgba(255,255,255,0.4)'};">${animatedCount}/${totalScenes}</div>
                        </div>
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Images</div>
                            <div style="color: ${imageCount === totalScenes ? '#10b981' : imageCount > 0 ? '#06b6d4' : '#f59e0b'};">${imageCount}/${totalScenes}</div>
                        </div>
                        <div style="padding: 0.4rem; background: rgba(255,255,255,0.03); border-radius: 0.2rem;">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.65rem;">Ready</div>
                            <div style="color: ${canExport ? '#10b981' : '#f59e0b'};">${canExport ? 'Yes' : 'No'}</div>
                        </div>
                    </div>

                    ${!canExport ? `
                        <div style="padding: 0.4rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.2rem; font-size: 0.7rem; color: #ef4444;">
                            Generate images first
                        </div>
                    ` : animatedCount < totalScenes ? `
                        <div style="padding: 0.4rem; background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.2rem; font-size: 0.7rem; color: #06b6d4;">
                            ${animatedCount === 0 ? 'Ken Burns on images' : `${totalScenes - animatedCount} scene(s) use Ken Burns`}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // ==========================================
        // PROFESSIONAL TIMELINE COMPONENT
        // ==========================================

        function renderProfessionalTimeline(scriptScenes, animationScenes, totalDuration, zoom, snapToGrid, selectedClipId, currentTime, isReady) {
            const timelineWidth = totalDuration * zoom;
            const trackLabelWidth = 100;

            return `
                <div class="pro-timeline" style="
                    height: 280px;
                    min-height: 280px;
                    background: linear-gradient(180deg, rgba(15, 15, 25, 0.98) 0%, rgba(10, 10, 18, 0.99) 100%);
                    border-top: 1px solid rgba(139, 92, 246, 0.3);
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 -4px 20px rgba(0,0,0,0.4);
                ">
                    <!-- Timeline Toolbar -->
                    <div style="
                        height: 40px;
                        min-height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 0 1rem;
                        background: linear-gradient(90deg, rgba(139, 92, 246, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
                        border-bottom: 1px solid rgba(255,255,255,0.08);
                    ">
                        <!-- Left: Transport & Edit Tools -->
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <!-- Transport -->
                            <div style="display: flex; align-items: center; gap: 0.25rem; padding-right: 0.5rem; border-right: 1px solid rgba(255,255,255,0.15);">
                                <button onclick="seekTimelineStart()" title="Go to Start" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'"></button>
                                <button onclick="toggleTimelinePlayback()" title="Play/Pause" style="width: 32px; height: 32px; border-radius: 6px; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.9rem; box-shadow: ${isReady ? '0 2px 8px rgba(139,92,246,0.4)' : 'none'};">${state.preview.isPlaying ? '' : ''}</button>
                                <button onclick="seekTimelineEnd()" title="Go to End" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-size: 0.75rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'"></button>
                            </div>

                            <!-- Edit Tools -->
                            <div style="display: flex; align-items: center; gap: 0.25rem;">
                                <button onclick="undoEdit()" ${!editHistory.canUndo() ? 'disabled' : ''} title="Undo (Ctrl+Z)" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: ${editHistory.canUndo() ? 'rgba(255,255,255,0.08)' : 'transparent'}; color: ${editHistory.canUndo() ? 'white' : 'rgba(255,255,255,0.25)'}; cursor: ${editHistory.canUndo() ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                <button onclick="redoEdit()" ${!editHistory.canRedo() ? 'disabled' : ''} title="Redo (Ctrl+Y)" style="width: 28px; height: 28px; border-radius: 4px; border: none; background: ${editHistory.canRedo() ? 'rgba(255,255,255,0.08)' : 'transparent'}; color: ${editHistory.canRedo() ? 'white' : 'rgba(255,255,255,0.25)'}; cursor: ${editHistory.canRedo() ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.15); margin: 0 0.25rem;"></div>
                                <button onclick="splitClipAtPlayhead()" ${!isReady ? 'disabled' : ''} title="Split at Playhead (S)" style="padding: 0.35rem 0.6rem; border-radius: 4px; border: none; background: ${isReady ? 'rgba(255,255,255,0.08)' : 'transparent'}; color: ${isReady ? 'white' : 'rgba(255,255,255,0.25)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.75rem; display: flex; align-items: center; gap: 0.3rem;"><span></span> Split</button>
                                <button onclick="deleteSelectedClip()" ${!selectedClipId ? 'disabled' : ''} title="Delete Selected (Del)" style="padding: 0.35rem 0.6rem; border-radius: 4px; border: none; background: ${selectedClipId ? 'rgba(239,68,68,0.15)' : 'transparent'}; color: ${selectedClipId ? '#f87171' : 'rgba(255,255,255,0.25)'}; cursor: ${selectedClipId ? 'pointer' : 'not-allowed'}; font-size: 0.75rem; display: flex; align-items: center; gap: 0.3rem;"><span></span> Delete</button>
                            </div>
                        </div>

                        <!-- Center: Timeline Title & Time -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 1rem;"></span>
                                <span style="font-size: 0.85rem; font-weight: 600; color: white;">Timeline</span>
                            </div>
                            <div style="font-family: 'SF Mono', Monaco, monospace; font-size: 0.85rem; color: #8b5cf6; background: rgba(139,92,246,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; border: 1px solid rgba(139,92,246,0.2);">
                                ${formatTimecode(currentTime)} <span style="color: rgba(255,255,255,0.3);">/</span> ${formatTimecode(totalDuration)}
                            </div>
                        </div>

                        <!-- Right: Zoom & View Controls -->
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-size: 0.75rem; color: rgba(255,255,255,0.7); padding: 0.3rem 0.5rem; background: ${snapToGrid ? 'rgba(139,92,246,0.15)' : 'transparent'}; border-radius: 4px; border: 1px solid ${snapToGrid ? 'rgba(139,92,246,0.3)' : 'transparent'};">
                                <input type="checkbox" ${snapToGrid ? 'checked' : ''} onchange="toggleTimelineSnap(this.checked)" style="cursor: pointer; accent-color: #8b5cf6;">
                                <span>Snap</span>
                            </label>
                            <div style="display: flex; align-items: center; gap: 0.3rem; background: rgba(0,0,0,0.3); border-radius: 6px; padding: 0.2rem;">
                                <button onclick="zoomTimeline(-10)" title="Zoom Out" style="width: 26px; height: 26px; border-radius: 4px; border: none; background: transparent; color: white; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'"></button>
                                <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 50px; text-align: center; font-family: monospace;">${zoom}px/s</div>
                                <button onclick="zoomTimeline(10)" title="Zoom In" style="width: 26px; height: 26px; border-radius: 4px; border: none; background: transparent; color: white; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">+</button>
                            </div>
                            <button onclick="fitTimelineToView()" title="Fit to View" style="padding: 0.35rem 0.6rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.75rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">Fit</button>
                        </div>
                    </div>

                    <!-- Timeline Content Area -->
                    <div id="timeline-scroll-container" style="flex: 1; overflow-x: auto; overflow-y: hidden; position: relative;" onscroll="handleTimelineScroll(this)">
                        <div style="position: relative; min-width: ${Math.max(timelineWidth + 150, 900)}px; height: 100%; display: flex;">

                            <!-- Track Labels Column -->
                            <div style="width: ${trackLabelWidth}px; min-width: ${trackLabelWidth}px; flex-shrink: 0; background: rgba(0,0,0,0.4); border-right: 1px solid rgba(255,255,255,0.1); position: sticky; left: 0; z-index: 10;">
                                <!-- Time Ruler Label -->
                                <div style="height: 28px; border-bottom: 1px solid rgba(255,255,255,0.1);"></div>

                                <!-- Video Track Label -->
                                <div style="height: 75px; display: flex; align-items: center; padding: 0 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); background: linear-gradient(90deg, rgba(139,92,246,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; flex-direction: column; gap: 0.2rem;">
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <span style="font-size: 0.9rem;"></span>
                                            <span style="font-size: 0.75rem; font-weight: 600; color: white;">Video</span>
                                        </div>
                                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">${scriptScenes.length} clips</span>
                                    </div>
                                    <button onclick="toggleTrackMute('video')" title="Mute Track" style="width: 22px; height: 22px; border-radius: 3px; border: none; background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.6rem;"></button>
                                </div>

                                <!-- Voice Track Label -->
                                <div style="height: 50px; display: flex; align-items: center; padding: 0 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); background: linear-gradient(90deg, rgba(6,182,212,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; flex-direction: column; gap: 0.2rem;">
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <span style="font-size: 0.9rem;"></span>
                                            <span style="font-size: 0.75rem; font-weight: 600; color: white;">Voice</span>
                                        </div>
                                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4);">Narration</span>
                                    </div>
                                    <button onclick="toggleTrackMute('voice')" title="Mute Track" style="width: 22px; height: 22px; border-radius: 3px; border: none; background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.6rem;"></button>
                                </div>

                                <!-- Music Track Label -->
                                <div style="height: 40px; display: flex; align-items: center; padding: 0 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); background: linear-gradient(90deg, rgba(16,185,129,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; flex-direction: column; gap: 0.1rem;">
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <span style="font-size: 0.85rem;"></span>
                                            <span style="font-size: 0.75rem; font-weight: 600; color: white;">Music</span>
                                        </div>
                                    </div>
                                    <button onclick="toggleTrackMute('music')" title="Mute Track" style="width: 22px; height: 22px; border-radius: 3px; border: none; background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.6rem;"></button>
                                </div>

                                <!-- Caption Track Label -->
                                <div style="height: 35px; display: flex; align-items: center; padding: 0 0.5rem; background: linear-gradient(90deg, rgba(245,158,11,0.08) 0%, transparent 100%);">
                                    <div style="flex: 1; display: flex; align-items: center; gap: 0.4rem;">
                                        <span style="font-size: 0.85rem;"></span>
                                        <span style="font-size: 0.75rem; font-weight: 600; color: white;">Captions</span>
                                    </div>
                                    <div style="width: 8px; height: 8px; border-radius: 50%; background: ${state.assembly.captions?.enabled ? '#10b981' : 'rgba(255,255,255,0.2)'};"></div>
                                </div>
                            </div>

                            <!-- Tracks Content Area -->
                            <div style="flex: 1; position: relative;">
                                <!-- Time Ruler -->
                                ${renderProTimeRuler(totalDuration, zoom)}

                                <!-- Playhead -->
                                <div id="timeline-playhead" style="position: absolute; top: 0; left: ${currentTime * zoom}px; width: 2px; height: 100%; z-index: 50; pointer-events: none;">
                                    <!-- Playhead Head -->
                                    <div style="position: absolute; top: 0; left: -7px; width: 16px; height: 16px; background: linear-gradient(180deg, #ef4444, #dc2626); border-radius: 3px 3px 0 0; display: flex; align-items: center; justify-content: center;">
                                        <div style="width: 0; height: 0; border-left: 4px solid transparent; border-right: 4px solid transparent; border-top: 5px solid white; margin-top: 2px;"></div>
                                    </div>
                                    <!-- Playhead Line -->
                                    <div style="position: absolute; top: 16px; left: 0; width: 2px; height: calc(100% - 16px); background: linear-gradient(180deg, #ef4444 0%, rgba(239,68,68,0.6) 100%); box-shadow: 0 0 8px rgba(239,68,68,0.5);"></div>
                                </div>

                                <!-- Tracks -->
                                <div style="position: absolute; top: 28px; left: 0; right: 0; bottom: 0;">
                                    ${renderProVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId)}
                                    ${renderProVoiceTrack(scriptScenes, animationScenes, zoom)}
                                    ${renderProMusicTrack(totalDuration, zoom)}
                                    ${renderProCaptionTrack(scriptScenes, animationScenes, zoom)}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderProTimeRuler(totalDuration, zoom) {
            let tickInterval = 1;
            if (zoom < 15) tickInterval = 10;
            else if (zoom < 30) tickInterval = 5;
            else if (zoom < 60) tickInterval = 2;
            else tickInterval = 1;

            let rulerHtml = `<div style="height: 28px; background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.15); position: relative; cursor: pointer;" onclick="seekTimelineFromRuler(event)">`;

            for (let t = 0; t <= totalDuration; t += tickInterval) {
                const x = t * zoom;
                const isMajor = t % (tickInterval * 5) === 0 || tickInterval >= 5;

                rulerHtml += `
                    <div style="position: absolute; left: ${x}px; bottom: 0; height: ${isMajor ? '12px' : '6px'}; width: 1px; background: rgba(255,255,255,${isMajor ? '0.4' : '0.15'});"></div>
                    ${isMajor ? `<span style="position: absolute; left: ${x + 4}px; top: 4px; font-size: 0.65rem; color: rgba(255,255,255,0.5); font-family: monospace;">${formatTimecode(t)}</span>` : ''}
                `;
            }

            rulerHtml += `</div>`;
            return rulerHtml;
        }

        function renderProVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 75px; position: relative; background: linear-gradient(180deg, rgba(139,92,246,0.06) 0%, rgba(139,92,246,0.02) 100%); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);
                const transition = state.assembly.transitions?.[sceneId] || { type: 'cut' };

                if (!scriptScene) return;

                const duration = scriptScene.duration || 8;
                const width = duration * zoom;
                const x = currentTime * zoom;
                const isSelected = selectedClipId === sceneId;
                const hasVideo = animScene?.videoUrl || (storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl);
                const imageUrl = storyboardScene?.imageUrl;

                // Transition indicator (diamond) between clips
                if (index > 0 && transition.type !== 'cut') {
                    trackHtml += `
                        <div style="position: absolute; left: ${x - 8}px; top: 50%; transform: translateY(-50%); z-index: 5;">
                            <div style="width: 14px; height: 14px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 2px; transform: rotate(45deg); box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>
                        </div>
                    `;
                }

                trackHtml += `
                    <div class="timeline-clip pro-clip" data-clip-id="${sceneId}"
                         onclick="selectTimelineClip(${sceneId}, 'video')"
                         style="
                            position: absolute;
                            left: ${x + 2}px;
                            top: 4px;
                            width: ${width - 4}px;
                            height: 67px;
                            background: ${isSelected
                                ? 'linear-gradient(180deg, rgba(139,92,246,0.5) 0%, rgba(139,92,246,0.3) 100%)'
                                : 'linear-gradient(180deg, rgba(139,92,246,0.25) 0%, rgba(139,92,246,0.15) 100%)'};
                            border: 2px solid ${isSelected ? '#a78bfa' : 'rgba(139,92,246,0.4)'};
                            border-radius: 6px;
                            overflow: hidden;
                            cursor: pointer;
                            display: flex;
                            transition: all 0.15s ease;
                            box-shadow: ${isSelected ? '0 0 12px rgba(139,92,246,0.4), inset 0 1px 0 rgba(255,255,255,0.1)' : 'inset 0 1px 0 rgba(255,255,255,0.05)'};
                        "
                        onmouseover="this.style.borderColor='${isSelected ? '#a78bfa' : 'rgba(139,92,246,0.6)'}'"
                        onmouseout="this.style.borderColor='${isSelected ? '#a78bfa' : 'rgba(139,92,246,0.4)'}'"
                    >
                        <!-- Thumbnail -->
                        <div style="width: 60px; min-width: 60px; height: 100%; background: rgba(0,0,0,0.4); border-right: 1px solid rgba(255,255,255,0.1); pointer-events: none;">
                            ${imageUrl
                                ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">`
                                : `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 1.2rem;"></div>`
                            }
                        </div>
                        <!-- Info Panel -->
                        <div style="flex: 1; padding: 0.4rem 0.5rem; min-width: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;">
                            <div>
                                <div style="font-size: 0.75rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    Scene ${index + 1}
                                </div>
                                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.5); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 2px;">
                                    ${scriptScene.narration?.substring(0, 25) || 'No narration'}${scriptScene.narration?.length > 25 ? '...' : ''}
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.4rem;">
                                <span style="font-size: 0.65rem; color: rgba(255,255,255,0.6); background: rgba(0,0,0,0.3); padding: 0.15rem 0.35rem; border-radius: 3px;">${duration}s</span>
                                <span style="font-size: 0.6rem; color: ${hasVideo ? '#10b981' : '#f59e0b'}; background: ${hasVideo ? 'rgba(16,185,129,0.15)' : 'rgba(245,158,11,0.15)'}; padding: 0.15rem 0.35rem; border-radius: 3px;">
                                    ${hasVideo ? ' video' : ' img'}
                                </span>
                            </div>
                        </div>
                        <!-- Selection Handles -->
                        ${isSelected ? `
                            <div style="position: absolute; left: 0; top: 0; width: 6px; height: 100%; background: linear-gradient(180deg, #a78bfa, #8b5cf6); cursor: ew-resize; border-radius: 6px 0 0 6px;" onmousedown="startTrimClip(${sceneId}, 'left', event)"></div>
                            <div style="position: absolute; right: 0; top: 0; width: 6px; height: 100%; background: linear-gradient(180deg, #a78bfa, #8b5cf6); cursor: ew-resize; border-radius: 0 6px 6px 0;" onmousedown="startTrimClip(${sceneId}, 'right', event)"></div>
                        ` : ''}
                    </div>
                `;

                currentTime += duration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderProVoiceTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 50px; position: relative; background: linear-gradient(180deg, rgba(6,182,212,0.06) 0%, rgba(6,182,212,0.02) 100%); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const sceneDuration = scriptScene.duration || 8;
                const hasVoiceover = animScene?.voiceoverUrl;
                const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.85;
                const voiceoverOffset = scriptScene.voiceoverOffset || 0;
                const width = voiceoverDuration * zoom;
                const x = (currentTime + voiceoverOffset) * zoom;

                if (hasVoiceover) {
                    // Format duration for display
                    const durationDisplay = voiceoverDuration.toFixed(1) + 's';
                    const hasOffset = voiceoverOffset > 0.1;

                    trackHtml += `
                        <div style="
                            position: absolute;
                            left: ${x + 2}px;
                            top: 5px;
                            width: ${width - 2}px;
                            height: 40px;
                            background: linear-gradient(180deg, rgba(6,182,212,0.35) 0%, rgba(6,182,212,0.2) 100%);
                            border: 1px solid rgba(6,182,212,0.5);
                            border-radius: 5px;
                            overflow: hidden;
                            box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
                        ">
                            <!-- Duration indicator -->
                            <div style="position: absolute; top: 2px; right: 4px; font-size: 0.55rem; color: rgba(6,182,212,0.9); font-weight: 600; z-index: 1;">
                                ${durationDisplay}
                            </div>
                            ${hasOffset ? `
                                <div style="position: absolute; top: 2px; left: 4px; font-size: 0.5rem; color: rgba(255,255,255,0.5); z-index: 1;">
                                    +${voiceoverOffset.toFixed(1)}s
                                </div>
                            ` : ''}
                            <!-- Waveform Visualization -->
                            <svg width="100%" height="100%" viewBox="0 0 200 40" preserveAspectRatio="none" style="opacity: 0.8;">
                                <defs>
                                    <linearGradient id="waveGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:0.9" />
                                        <stop offset="50%" style="stop-color:#0891b2;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:0.9" />
                                    </linearGradient>
                                </defs>
                                ${generateDetailedWaveformPath()}
                            </svg>
                        </div>
                    `;
                }

                currentTime += sceneDuration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderProMusicTrack(totalDuration, zoom) {
            const musicEnabled = state.assembly.music?.enabled;
            const musicTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
            const width = totalDuration * zoom;

            let trackHtml = `<div style="height: 40px; position: relative; background: linear-gradient(180deg, rgba(16,185,129,0.06) 0%, rgba(16,185,129,0.02) 100%); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            if (musicEnabled && musicTrack) {
                trackHtml += `
                    <div style="
                        position: absolute;
                        left: 2px;
                        top: 4px;
                        width: ${width - 4}px;
                        height: 32px;
                        background: linear-gradient(90deg, rgba(16,185,129,0.25) 0%, rgba(16,185,129,0.15) 50%, rgba(16,185,129,0.25) 100%);
                        border: 1px solid rgba(16,185,129,0.4);
                        border-radius: 5px;
                        display: flex;
                        align-items: center;
                        padding: 0 0.6rem;
                        gap: 0.5rem;
                        overflow: hidden;
                    ">
                        <span style="font-size: 0.9rem;"></span>
                        <span style="font-size: 0.7rem; color: #34d399; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${musicTrack.name || 'Background Music'}
                        </span>
                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.4); margin-left: auto;">
                            ${state.assembly.music?.volume || 30}%
                        </span>
                        <!-- Repeating pattern indicator -->
                        <div style="position: absolute; right: 0; top: 0; bottom: 0; width: 60px; background: linear-gradient(90deg, transparent, rgba(16,185,129,0.3)); display: flex; align-items: center; justify-content: center;">
                            <span style="font-size: 0.6rem; color: rgba(255,255,255,0.5);"></span>
                        </div>
                    </div>
                `;
            } else {
                trackHtml += `
                    <div style="position: absolute; left: 2px; top: 4px; right: 2px; height: 32px; border: 1px dashed rgba(16,185,129,0.3); border-radius: 5px; display: flex; align-items: center; justify-content: center;">
                        <span style="font-size: 0.65rem; color: rgba(255,255,255,0.3);">No background music</span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderProCaptionTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);
            const captionsEnabled = state.assembly.captions?.enabled;

            let currentTime = 0;
            let trackHtml = `<div style="height: 35px; position: relative; background: linear-gradient(180deg, rgba(245,158,11,0.06) 0%, rgba(245,158,11,0.02) 100%);">`;

            if (captionsEnabled) {
                sceneOrder.forEach(sceneId => {
                    const scriptScene = scriptScenes.find(s => s.id === sceneId);
                    const animScene = animationScenes.find(s => s.sceneId === sceneId);
                    if (!scriptScene) return;

                    const sceneDuration = scriptScene.duration || 8;
                    // Use voiceover timing to sync with voice track
                    const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.85;
                    const voiceoverOffset = scriptScene.voiceoverOffset || 0;
                    const width = voiceoverDuration * zoom;
                    const x = (currentTime + voiceoverOffset) * zoom;
                    const caption = scriptScene.narration?.substring(0, 25) || '';
                    const durationDisplay = voiceoverDuration.toFixed(1) + 's';

                    trackHtml += `
                        <div style="
                            position: absolute;
                            left: ${x + 2}px;
                            top: 4px;
                            width: ${width - 4}px;
                            height: 27px;
                            background: linear-gradient(180deg, rgba(245,158,11,0.25) 0%, rgba(245,158,11,0.15) 100%);
                            border: 1px solid rgba(245,158,11,0.4);
                            border-radius: 4px;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            padding: 0 0.4rem;
                            overflow: hidden;
                        ">
                            <span style="font-size: 0.55rem; color: rgba(255,255,255,0.8); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-style: italic; flex: 1;">
                                "${caption}${caption.length >= 25 ? '...' : ''}"
                            </span>
                            <span style="font-size: 0.5rem; color: rgba(245,158,11,0.8); font-weight: 600; margin-left: 4px;">
                                ${durationDisplay}
                            </span>
                        </div>
                    `;

                    currentTime += sceneDuration;
                });
            } else {
                trackHtml += `
                    <div style="position: absolute; left: 2px; top: 4px; right: 2px; height: 27px; border: 1px dashed rgba(245,158,11,0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center;">
                        <span style="font-size: 0.6rem; color: rgba(255,255,255,0.3);">Captions disabled</span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function generateDetailedWaveformPath() {
            // Generate a more detailed, realistic waveform
            let pathTop = 'M0,20 ';
            let pathBottom = 'M0,20 ';

            for (let x = 0; x <= 200; x += 2) {
                const amplitude = 6 + Math.random() * 10;
                const noise = Math.sin(x * 0.3) * 3 + Math.cos(x * 0.7) * 2;
                const y1 = 20 - amplitude - noise;
                const y2 = 20 + amplitude + noise;
                pathTop += `L${x},${Math.max(2, y1)} `;
                pathBottom += `L${x},${Math.min(38, y2)} `;
            }

            return `
                <path d="${pathTop}" fill="none" stroke="url(#waveGradient)" stroke-width="1.5"/>
                <path d="${pathBottom}" fill="none" stroke="url(#waveGradient)" stroke-width="1.5"/>
            `;
        }

        function toggleTrackMute(trackName) {
            // Placeholder for track mute functionality
            showToast(`${trackName} track mute toggled`, 'info');
        }

        // Compact track renderers for full-screen editor (kept for backwards compatibility)
        function renderCompactVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 50px; position: relative; background: rgba(139, 92, 246, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const duration = scriptScene.duration || 8;
                const width = duration * zoom;
                const x = currentTime * zoom;
                const isSelected = selectedClipId === sceneId;
                const hasVideo = animScene?.videoUrl || (storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl);
                const imageUrl = storyboardScene?.imageUrl;

                trackHtml += `
                    <div class="timeline-clip" data-clip-id="${sceneId}"
                         onclick="selectTimelineClip(${sceneId}, 'video')"
                         style="position: absolute; left: ${x}px; top: 3px; width: ${width - 2}px; height: 44px; background: ${isSelected ? 'rgba(139, 92, 246, 0.4)' : 'rgba(139, 92, 246, 0.2)'}; border: 2px solid ${isSelected ? '#8b5cf6' : 'rgba(139, 92, 246, 0.5)'}; border-radius: 3px; overflow: hidden; cursor: grab; display: flex; transition: all 0.15s;">
                        <!-- Thumbnail -->
                        <div style="width: 40px; height: 100%; flex-shrink: 0; background: rgba(0,0,0,0.3); pointer-events: none;">
                            ${imageUrl ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">` : ''}
                        </div>
                        <!-- Info -->
                        <div style="flex: 1; padding: 0.2rem 0.3rem; min-width: 0; pointer-events: none;">
                            <div style="font-size: 0.6rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                Scene ${index + 1}
                            </div>
                            <div style="font-size: 0.5rem; color: rgba(255,255,255,0.6); display: flex; gap: 0.2rem; margin-top: 1px;">
                                <span>${duration}s</span>
                                ${hasVideo ? '<span style="color: #10b981;"></span>' : '<span style="color: #f59e0b;">img</span>'}
                            </div>
                        </div>
                    </div>
                `;

                currentTime += duration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCompactVoiceTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 32px; position: relative; background: rgba(6, 182, 212, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const sceneDuration = scriptScene.duration || 8;
                const hasVoiceover = animScene?.voiceoverUrl;
                const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.8;
                const width = voiceoverDuration * zoom;
                const x = currentTime * zoom;

                if (hasVoiceover) {
                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 4px; width: ${width}px; height: 24px; background: rgba(6, 182, 212, 0.3); border: 1px solid rgba(6, 182, 212, 0.5); border-radius: 2px; overflow: hidden;">
                            <svg width="100%" height="18" viewBox="0 0 100 18" preserveAspectRatio="none" style="opacity: 0.6; margin-top: 2px;">
                                ${generateSimpleWaveformPath()}
                            </svg>
                        </div>
                    `;
                }

                currentTime += sceneDuration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCompactMusicTrack(totalDuration, zoom) {
            const musicEnabled = state.assembly.music?.enabled;
            const musicTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
            const width = totalDuration * zoom;

            let trackHtml = `<div style="height: 24px; position: relative; background: rgba(16, 185, 129, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            if (musicEnabled && musicTrack) {
                trackHtml += `
                    <div style="position: absolute; left: 0; top: 3px; width: ${width}px; height: 18px; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 2px; display: flex; align-items: center; padding: 0 0.4rem;">
                        <span style="font-size: 0.6rem; color: #10b981; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                             ${musicTrack.name || 'Music'}
                        </span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCompactCaptionTrack(scriptScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);
            const captionsEnabled = state.assembly.captions?.enabled;

            let currentTime = 0;
            let trackHtml = `<div style="height: 24px; position: relative; background: rgba(245, 158, 11, 0.05);">`;

            if (captionsEnabled) {
                sceneOrder.forEach(sceneId => {
                    const scriptScene = scriptScenes.find(s => s.id === sceneId);
                    if (!scriptScene) return;

                    const duration = scriptScene.duration || 8;
                    const width = duration * zoom;
                    const x = currentTime * zoom;
                    const caption = scriptScene.narration?.substring(0, 15) || '';

                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 3px; width: ${width - 3}px; height: 18px; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 2px; display: flex; align-items: center; padding: 0 0.25rem; overflow: hidden;">
                            <span style="font-size: 0.5rem; color: rgba(255,255,255,0.7); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${caption}${caption.length >= 15 ? '...' : ''}
                            </span>
                        </div>
                    `;

                    currentTime += duration;
                });
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function resetExport() {
            state.export = {
                status: null,
                progress: 0,
                outputUrl: null,
                error: null,
                selectedQuality: state.export.selectedQuality || '1080p'
            };
            render();
        }

        function renderStep7Export() {
            const exportState = state.export || {};
            const isExporting = exportState.status === 'exporting' || exportState.status === 'processing';
            const isCompleted = exportState.status === 'completed';
            const isFailed = exportState.status === 'failed' || exportState.status === 'error';
            const progress = exportState.progress || 0;

            // Calculate video summary
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const animatedCount = animationScenes.filter(s => s.videoUrl).length;
            const imageCount = storyboardScenes.filter(s => s.imageUrl).length;
            const totalDuration = scriptScenes.reduce((sum, s) => sum + (s.duration || 8), 0);
            const platform = PLATFORM_PRESETS[state.platform.selected] || {};

            let html = '<div class="fade-in">';

            // Header
            html += `
                <div class="content-card">
                    <div class="content-card-header">
                        <div class="content-card-icon"></div>
                        <div style="flex: 1;">
                            <div class="content-card-title">Timeline Editor & Export</div>
                            <div class="content-card-subtitle">Fine-tune your video and export  ${formatDuration(totalDuration)}</div>
                        </div>
                    </div>
                </div>
            `;

            // Main content based on state
            if (isExporting) {
                html += renderExportProgress(exportState);
            } else if (isCompleted && exportState.outputUrl) {
                html += renderExportComplete(exportState);
            } else if (isFailed) {
                html += renderExportFailed(exportState);
            } else {
                // Show Timeline Editor + Export Settings
                html += renderTimelineEditor(scriptScenes, animationScenes, totalDuration);
                html += renderExportPanel(scriptScenes, animatedCount, imageCount, totalDuration, platform);
            }

            // Navigation (only back button on export step)
            html += `
                <div class="nav-buttons">
                    <button class="nav-button nav-button-back" onclick="goToStep(6)">
                        <span></span>
                        <span>Back</span>
                    </button>
                    <div></div>
                </div>
            `;

            html += '</div>';
            return html;
        }

        // ==========================================
        // TIMELINE EDITOR
        // ==========================================

        function renderTimelineEditor(scriptScenes, animationScenes, totalDuration) {
            const { zoom, scrollLeft, selectedClipId, snapToGrid } = state.timeline;
            const timelineWidth = totalDuration * zoom;
            const { isReady, isPlaying, currentTime } = state.preview;

            return `
                <div class="content-card" style="padding: 0; margin-top: 1rem; overflow: hidden;">
                    <!-- Preview + Controls Row -->
                    <div style="display: grid; grid-template-columns: 1fr 300px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <!-- Main Preview -->
                        <div style="padding: 1rem; background: #000;">
                            <div style="position: relative; width: 100%; aspect-ratio: 16/9; background: #111; border-radius: 0.5rem; overflow: hidden;">
                                <canvas id="timeline-preview-canvas" style="width: 100%; height: 100%; display: block;"></canvas>

                                <!-- Play overlay -->
                                ${!isReady ? `
                                    <div style="position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7);">
                                        <button onclick="initializeTimelinePreview()" style="padding: 1rem 2rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; font-size: 1rem;">
                                            <span style="font-size: 1.5rem;"></span> Load Preview
                                        </button>
                                    </div>
                                ` : (!isPlaying ? `
                                    <div onclick="toggleTimelinePlayback()" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; cursor: pointer; background: rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
                                        <div style="width: 70px; height: 70px; background: rgba(139, 92, 246, 0.9); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(0,0,0,0.4);">
                                            <span style="font-size: 2rem; margin-left: 5px;"></span>
                                        </div>
                                    </div>
                                ` : '')}
                            </div>

                            <!-- Transport Controls -->
                            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.75rem; padding: 0 0.5rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <button onclick="seekTimelineStart()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                    <button onclick="toggleTimelinePlayback()" ${!isReady ? 'disabled' : ''} style="width: 40px; height: 40px; border-radius: 50%; border: none; background: ${isReady ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: white; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 1rem;">${isPlaying ? '' : ''}</button>
                                    <button onclick="seekTimelineEnd()" ${!isReady ? 'disabled' : ''} style="width: 32px; height: 32px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${isReady ? 'pointer' : 'not-allowed'}; font-size: 0.8rem;"></button>
                                </div>

                                <!-- Time Display -->
                                <div style="font-family: monospace; font-size: 1.1rem; color: white; background: rgba(0,0,0,0.5); padding: 0.4rem 0.75rem; border-radius: 0.25rem;">
                                    ${formatTimecode(currentTime)} <span style="color: rgba(255,255,255,0.4);">/</span> ${formatTimecode(totalDuration)}
                                </div>

                                <div style="flex: 1;"></div>

                                <!-- Volume -->
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem;">${state.preview.volume > 0 ? '' : ''}</span>
                                    <input type="range" min="0" max="100" value="${state.preview.volume || 100}" onchange="setTimelineVolume(this.value)" style="width: 80px; height: 4px; cursor: pointer;">
                                </div>
                            </div>
                        </div>

                        <!-- Clip Inspector -->
                        ${renderClipInspector(selectedClipId, scriptScenes, animationScenes)}
                    </div>

                    <!-- Timeline Container -->
                    <div style="background: rgba(0,0,0,0.3);">
                        <!-- Timeline Header with Zoom Controls -->
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 1rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <div style="font-size: 0.85rem; font-weight: 600; color: white; display: flex; align-items: center; gap: 0.5rem;">
                                <span></span> Timeline
                            </div>
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <!-- Snap Toggle -->
                                <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer; font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                    <input type="checkbox" ${snapToGrid ? 'checked' : ''} onchange="toggleTimelineSnap(this.checked)" style="cursor: pointer;">
                                    Snap
                                </label>

                                <!-- Zoom Controls -->
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <button onclick="zoomTimeline(-10)" style="width: 24px; height: 24px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.9rem;"></button>
                                    <span style="font-size: 0.75rem; color: rgba(255,255,255,0.6); min-width: 50px; text-align: center;">${zoom}px/s</span>
                                    <button onclick="zoomTimeline(10)" style="width: 24px; height: 24px; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.9rem;">+</button>
                                </div>

                                <!-- Fit Button -->
                                <button onclick="fitTimelineToView()" style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; cursor: pointer; font-size: 0.7rem;">Fit</button>
                            </div>
                        </div>

                        <!-- Edit Toolbar -->
                        ${renderEditToolbar()}

                        <!-- Timeline Tracks -->
                        <div id="timeline-scroll-container" style="overflow-x: auto; overflow-y: hidden;" onscroll="handleTimelineScroll(this)">
                            <div style="position: relative; min-width: ${Math.max(timelineWidth + 100, 800)}px;">
                                <!-- Time Ruler -->
                                ${renderTimeRuler(totalDuration, zoom)}

                                <!-- Playhead -->
                                <div id="timeline-playhead" style="position: absolute; top: 30px; left: ${80 + (currentTime * zoom)}px; width: 2px; height: calc(100% - 30px); background: #ef4444; z-index: 100; pointer-events: none;">
                                    <div style="position: absolute; top: -8px; left: -6px; width: 14px; height: 14px; background: #ef4444; border-radius: 2px; transform: rotate(45deg);"></div>
                                </div>

                                <!-- Track Labels + Tracks -->
                                <div style="display: flex;">
                                    <!-- Track Labels -->
                                    <div style="width: 80px; flex-shrink: 0; background: rgba(0,0,0,0.3); border-right: 1px solid rgba(255,255,255,0.1);">
                                        <div style="height: 60px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7); border-bottom: 1px solid rgba(255,255,255,0.05);"> Video</div>
                                        <div style="height: 40px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7); border-bottom: 1px solid rgba(255,255,255,0.05);"> Voice</div>
                                        <div style="height: 30px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7); border-bottom: 1px solid rgba(255,255,255,0.05);"> Music</div>
                                        <div style="height: 30px; display: flex; align-items: center; padding-left: 0.75rem; font-size: 0.75rem; color: rgba(255,255,255,0.7);"> Captions</div>
                                    </div>

                                    <!-- Tracks Content -->
                                    <div style="flex: 1; position: relative;">
                                        ${renderVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId)}
                                        ${renderVoiceTrack(scriptScenes, animationScenes, zoom)}
                                        ${renderMusicTrack(totalDuration, zoom)}
                                        ${renderCaptionTrack(scriptScenes, zoom)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderTimeRuler(totalDuration, zoom) {
            // Calculate tick interval based on zoom level
            let tickInterval = 1; // seconds
            if (zoom < 20) tickInterval = 10;
            else if (zoom < 40) tickInterval = 5;
            else if (zoom < 80) tickInterval = 2;
            else tickInterval = 1;

            let rulerHtml = `<div style="height: 30px; margin-left: 80px; background: rgba(0,0,0,0.4); border-bottom: 1px solid rgba(255,255,255,0.2); position: relative; cursor: pointer;" onclick="seekTimelineFromRuler(event)">`;

            for (let t = 0; t <= totalDuration; t += tickInterval) {
                const x = t * zoom;
                const isMajor = t % (tickInterval * 5) === 0 || tickInterval >= 5;
                rulerHtml += `
                    <div style="position: absolute; left: ${x}px; top: 0; height: ${isMajor ? '100%' : '50%'}; width: 1px; background: rgba(255,255,255,${isMajor ? '0.4' : '0.15'});"></div>
                    ${isMajor ? `<span style="position: absolute; left: ${x + 4}px; top: 4px; font-size: 0.65rem; color: rgba(255,255,255,0.6);">${formatTimecode(t)}</span>` : ''}
                `;
            }

            rulerHtml += `</div>`;
            return rulerHtml;
        }

        function renderVideoTrack(scriptScenes, animationScenes, zoom, selectedClipId) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 60px; position: relative; background: rgba(139, 92, 246, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const duration = scriptScene.duration || 8;
                const width = duration * zoom;
                const x = currentTime * zoom;
                const isSelected = selectedClipId === sceneId;
                const hasVideo = animScene?.videoUrl || (storyboardScene?.source === 'stock-video' && storyboardScene?.videoUrl);
                const imageUrl = storyboardScene?.imageUrl;

                trackHtml += `
                    <div class="timeline-clip" data-clip-id="${sceneId}"
                         onclick="selectTimelineClip(${sceneId}, 'video')"
                         onmousedown="startDragClip(${sceneId}, event)"
                         style="position: absolute; left: ${x}px; top: 4px; width: ${width - 2}px; height: 52px; background: ${isSelected ? 'rgba(139, 92, 246, 0.4)' : 'rgba(139, 92, 246, 0.2)'}; border: 2px solid ${isSelected ? '#8b5cf6' : 'rgba(139, 92, 246, 0.5)'}; border-radius: 4px; overflow: hidden; cursor: grab; display: flex; transition: all 0.15s;">
                        <!-- Thumbnail -->
                        <div style="width: 50px; height: 100%; flex-shrink: 0; background: rgba(0,0,0,0.3); pointer-events: none;">
                            ${imageUrl ? `<img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">` : ''}
                        </div>
                        <!-- Info -->
                        <div style="flex: 1; padding: 0.25rem 0.4rem; min-width: 0; pointer-events: none;">
                            <div style="font-size: 0.65rem; color: white; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                Scene ${index + 1}
                            </div>
                            <div style="font-size: 0.55rem; color: rgba(255,255,255,0.6); display: flex; gap: 0.3rem; margin-top: 2px;">
                                <span>${duration}s</span>
                                ${hasVideo ? '<span style="color: #10b981;"></span>' : '<span style="color: #f59e0b;">img</span>'}
                            </div>
                        </div>
                        <!-- Resize Handles -->
                        ${isSelected ? `
                            <div class="clip-handle clip-handle-left" onmousedown="startTrimClip(${sceneId}, 'left', event)" style="position: absolute; left: 0; top: 0; width: 6px; height: 100%; background: #8b5cf6; cursor: ew-resize;"></div>
                            <div class="clip-handle clip-handle-right" onmousedown="startTrimClip(${sceneId}, 'right', event)" style="position: absolute; right: 0; top: 0; width: 6px; height: 100%; background: #8b5cf6; cursor: ew-resize;"></div>
                        ` : ''}
                    </div>
                `;

                currentTime += duration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderVoiceTrack(scriptScenes, animationScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            let currentTime = 0;
            let trackHtml = `<div style="height: 40px; position: relative; background: rgba(6, 182, 212, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            sceneOrder.forEach(sceneId => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);

                if (!scriptScene) return;

                const sceneDuration = scriptScene.duration || 8;
                const hasVoiceover = animScene?.voiceoverUrl;
                const voiceoverDuration = animScene?.voiceoverDuration || sceneDuration * 0.8;
                const width = voiceoverDuration * zoom;
                const x = currentTime * zoom;

                if (hasVoiceover) {
                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 6px; width: ${width}px; height: 28px; background: rgba(6, 182, 212, 0.3); border: 1px solid rgba(6, 182, 212, 0.5); border-radius: 3px; overflow: hidden;">
                            <!-- Waveform placeholder -->
                            <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
                                <svg width="100%" height="20" viewBox="0 0 100 20" preserveAspectRatio="none" style="opacity: 0.6;">
                                    ${generateSimpleWaveformPath()}
                                </svg>
                            </div>
                        </div>
                    `;
                }

                currentTime += sceneDuration;
            });

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderMusicTrack(totalDuration, zoom) {
            const musicEnabled = state.assembly.music?.enabled;
            const musicTrack = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
            const width = totalDuration * zoom;

            let trackHtml = `<div style="height: 30px; position: relative; background: rgba(16, 185, 129, 0.05); border-bottom: 1px solid rgba(255,255,255,0.05);">`;

            if (musicEnabled && musicTrack) {
                trackHtml += `
                    <div style="position: absolute; left: 0; top: 4px; width: ${width}px; height: 22px; background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.4); border-radius: 3px; display: flex; align-items: center; padding: 0 0.5rem;">
                        <span style="font-size: 0.65rem; color: #10b981; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                             ${musicTrack.name || 'Background Music'}
                        </span>
                    </div>
                `;
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderCaptionTrack(scriptScenes, zoom) {
            const sceneOrder = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);
            const captionsEnabled = state.assembly.captions?.enabled;

            let currentTime = 0;
            let trackHtml = `<div style="height: 30px; position: relative; background: rgba(245, 158, 11, 0.05);">`;

            if (captionsEnabled) {
                sceneOrder.forEach(sceneId => {
                    const scriptScene = scriptScenes.find(s => s.id === sceneId);
                    if (!scriptScene) return;

                    const duration = scriptScene.duration || 8;
                    const width = duration * zoom;
                    const x = currentTime * zoom;
                    const caption = scriptScene.narration?.substring(0, 20) || '';

                    trackHtml += `
                        <div style="position: absolute; left: ${x}px; top: 4px; width: ${width - 4}px; height: 22px; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 3px; display: flex; align-items: center; padding: 0 0.3rem; overflow: hidden;">
                            <span style="font-size: 0.55rem; color: rgba(255,255,255,0.7); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${caption}${caption.length >= 20 ? '...' : ''}
                            </span>
                        </div>
                    `;

                    currentTime += duration;
                });
            }

            trackHtml += `</div>`;
            return trackHtml;
        }

        function renderClipInspector(selectedClipId, scriptScenes, animationScenes) {
            if (!selectedClipId) {
                return `
                    <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-left: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Clip Inspector
                        </div>
                        <div style="text-align: center; padding: 2rem 1rem; color: rgba(255,255,255,0.4); font-size: 0.8rem;">
                            Select a clip to view details
                        </div>
                    </div>
                `;
            }

            const scriptScene = scriptScenes.find(s => s.id === selectedClipId);
            const animScene = animationScenes.find(s => s.sceneId === selectedClipId);
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === selectedClipId);
            const transition = state.assembly.transitions[selectedClipId] || { type: 'cut' };

            if (!scriptScene) return '';

            const sceneIndex = scriptScenes.findIndex(s => s.id === selectedClipId) + 1;

            return `
                <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-left: 1px solid rgba(255,255,255,0.1); overflow-y: auto;">
                    <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span></span> Scene ${sceneIndex}
                    </div>

                    <!-- Thumbnail -->
                    <div style="width: 100%; aspect-ratio: 16/9; background: rgba(0,0,0,0.3); border-radius: 0.4rem; overflow: hidden; margin-bottom: 0.75rem;">
                        ${storyboardScene?.imageUrl ? `<img src="${storyboardScene.imageUrl}" style="width: 100%; height: 100%; object-fit: cover;">` : '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3); font-size: 0.8rem;">No image</div>'}
                    </div>

                    <!-- Properties -->
                    <div style="display: flex; flex-direction: column; gap: 0.6rem; font-size: 0.75rem;">
                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.2rem;">Duration</label>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="number" value="${scriptScene.duration || 8}" min="1" max="60" step="0.5"
                                       onchange="updateClipDuration(${selectedClipId}, this.value)"
                                       style="flex: 1; padding: 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.8rem;">
                                <span style="color: rgba(255,255,255,0.5);">sec</span>
                            </div>
                        </div>

                        <div>
                            <label style="color: rgba(255,255,255,0.5); display: block; margin-bottom: 0.2rem;">Transition</label>
                            <select onchange="updateClipTransition(${selectedClipId}, this.value)"
                                    style="width: 100%; padding: 0.4rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: white; font-size: 0.8rem;">
                                ${(state.assembly.transitionTypes || []).map(t => `
                                    <option value="${t.id}" ${transition.type === t.id ? 'selected' : ''}>${t.name}</option>
                                `).join('')}
                            </select>
                        </div>

                        <div style="display: flex; gap: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Voiceover</span>
                                <div style="color: ${animScene?.voiceoverUrl ? '#10b981' : 'rgba(255,255,255,0.4)'}; margin-top: 0.2rem;">
                                    ${animScene?.voiceoverUrl ? ' Ready' : ' None'}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <span style="color: rgba(255,255,255,0.5);">Video</span>
                                <div style="color: ${animScene?.videoUrl ? '#10b981' : (storyboardScene?.source === 'stock-video' ? '#06b6d4' : '#f59e0b')}; margin-top: 0.2rem;">
                                    ${animScene?.videoUrl ? ' Animated' : (storyboardScene?.source === 'stock-video' ? ' Stock' : ' Image')}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateSimpleWaveformPath() {
            // Generate a simple random waveform pattern
            let path = 'M0,10 ';
            for (let x = 0; x <= 100; x += 2) {
                const y = 10 + (Math.random() - 0.5) * 14;
                path += `L${x},${y} `;
            }
            return `<path d="${path}" fill="none" stroke="#06b6d4" stroke-width="1"/>`;
        }

        function formatTimecode(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const frames = Math.floor((seconds % 1) * 30);
            return `${mins}:${secs.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')}`;
        }

        function renderExportPanel(scriptScenes, animatedCount, imageCount, totalDuration, platform) {
            const selectedQuality = state.export.selectedQuality || '1080p';
            const canExport = animatedCount > 0 || imageCount > 0;
            const hasAllContent = animatedCount === scriptScenes.length || imageCount === scriptScenes.length;

            return `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <!-- Left: Video Summary -->
                    <div class="content-card" style="padding: 1rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Video Summary
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.8rem;">
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Platform</div>
                                <div style="color: white;">${platform.icon || ''} ${platform.name || 'YouTube'}</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Duration</div>
                                <div style="color: white;">${formatDuration(totalDuration)}</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Images</div>
                                <div style="color: ${imageCount === scriptScenes.length ? '#10b981' : imageCount > 0 ? '#06b6d4' : '#f59e0b'};">${imageCount}/${scriptScenes.length}</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 0.25rem;">
                                <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem;">Animated</div>
                                <div style="color: ${animatedCount === scriptScenes.length ? '#10b981' : animatedCount > 0 ? '#06b6d4' : 'rgba(255,255,255,0.4)'};">${animatedCount}/${scriptScenes.length}</div>
                            </div>
                        </div>

                        ${!canExport ? `
                            <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.25rem; font-size: 0.75rem; color: #ef4444;">
                                Generate images in Storyboard step first
                            </div>
                        ` : animatedCount < scriptScenes.length ? `
                            <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(6, 182, 212, 0.1); border: 1px solid rgba(6, 182, 212, 0.3); border-radius: 0.25rem; font-size: 0.75rem; color: #06b6d4;">
                                ${animatedCount === 0 ? 'Using Ken Burns effect on images (animation optional)' : `${scriptScenes.length - animatedCount} scene(s) will use Ken Burns effect`}
                            </div>
                        ` : ''}
                    </div>

                    <!-- Right: Export Button -->
                    <div class="content-card" style="padding: 1rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; color: white; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Export Settings
                        </div>

                        <!-- Quality Selection (compact) -->
                        <div style="display: flex; gap: 0.4rem; margin-bottom: 0.75rem;">
                            ${Object.entries(EXPORT_QUALITIES).map(([id, q]) => `
                                <button onclick="setExportQuality('${id}')"
                                        style="flex: 1; padding: 0.5rem; border-radius: 0.4rem; border: 1px solid ${selectedQuality === id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.15)'}; background: ${selectedQuality === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; font-size: 0.75rem;">
                                    ${q.icon} ${id}
                                </button>
                            `).join('')}
                        </div>

                        <!-- Export Button -->
                        <button onclick="startExport()"
                                ${!canExport ? 'disabled' : ''}
                                style="width: 100%; padding: 0.9rem; border-radius: 0.5rem; border: none; background: ${canExport ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: ${canExport ? 'white' : 'rgba(255,255,255,0.4)'}; font-size: 0.95rem; font-weight: 700; cursor: ${canExport ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <span></span> Export Video
                        </button>
                    </div>
                </div>
            `;
        }

        // ==========================================
        // TIMELINE CONTROL FUNCTIONS
        // ==========================================

        async function initializeTimelinePreview() {
            const canvas = document.getElementById('timeline-preview-canvas');
            if (!canvas) {
                console.error('Timeline preview canvas not found');
                return;
            }

            // Reuse the preview engine from Assembly step or create new one
            state.preview.loadProgress = 1;
            render();

            // Create the engine if it doesn't exist
            if (!previewEngine) {
                previewEngine = new VideoPreviewEngine(canvas, {
                    width: 1280,
                    height: 720,
                    onTimeUpdate: (time) => {
                        state.preview.currentTime = time;
                        updateTimelinePlayhead(time);
                    },
                    onSceneChange: (sceneIndex) => {
                        state.preview.currentSceneIndex = sceneIndex;
                    },
                    onEnded: () => {
                        state.preview.isPlaying = false;
                        state.preview.currentTime = 0;
                        render();
                    },
                    onLoadProgress: (progress) => {
                        state.preview.loadProgress = progress;
                        render();
                    },
                    onReady: () => {
                        state.preview.isReady = true;
                        state.preview.loadProgress = 100;
                        state.timeline.isInitialized = true;
                        render();
                    }
                });

                const scenes = buildPreviewScenes();
                state.preview.totalDuration = scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

                try {
                    await previewEngine.loadScenes(scenes);
                    previewEngine.captionsEnabled = state.assembly.captions?.enabled;
                    previewEngine.captionStyle = state.assembly.captions?.style;
                    previewEngine.captionPosition = state.assembly.captions?.position;
                    previewEngine.captionSize = state.assembly.captions?.size || 1;

                    if (state.assembly.music?.enabled && state.assembly.music?.trackId) {
                        const track = state.assembly.musicLibrary?.find(t => t.id === state.assembly.music?.trackId);
                        if (track?.url) {
                            await previewEngine.setBackgroundMusic(track.url, state.assembly.music.volume / 100);
                        }
                    }
                } catch (error) {
                    console.error('Failed to initialize timeline preview:', error);
                    showToast('Failed to load preview', 'error');
                    state.preview.loadProgress = 0;
                    render();
                }
            } else {
                // Engine already exists, just update canvas reference
                previewEngine.canvas = canvas;
                previewEngine.ctx = canvas.getContext('2d');
                previewEngine._renderFrame();
                state.preview.isReady = true;
                state.timeline.isInitialized = true;
                render();
            }
        }

        function toggleTimelinePlayback() {
            if (!previewEngine || !state.preview.isReady) return;

            if (state.preview.isPlaying) {
                previewEngine.pause();
                state.preview.isPlaying = false;
            } else {
                previewEngine.play();
                state.preview.isPlaying = true;
            }
            render();
        }

        function seekTimelineStart() {
            if (!previewEngine || !state.preview.isReady) return;
            previewEngine.seek(0);
            state.preview.currentTime = 0;
            updateTimelinePlayhead(0);
        }

        function seekTimelineEnd() {
            if (!previewEngine || !state.preview.isReady) return;
            const endTime = state.preview.totalDuration - 0.1;
            previewEngine.seek(endTime);
            state.preview.currentTime = endTime;
            updateTimelinePlayhead(endTime);
        }

        function seekTimelineFromRuler(event) {
            if (!previewEngine || !state.preview.isReady) return;

            const ruler = event.currentTarget;
            const rect = ruler.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const time = x / state.timeline.zoom;
            const clampedTime = Math.max(0, Math.min(time, state.preview.totalDuration));

            previewEngine.seek(clampedTime);
            state.preview.currentTime = clampedTime;
            updateTimelinePlayhead(clampedTime);
        }

        function setTimelineVolume(volume) {
            state.preview.volume = parseInt(volume);
            if (previewEngine) {
                previewEngine.voiceVolume = volume / 100;
            }
        }

        function zoomTimeline(delta) {
            const newZoom = Math.max(10, Math.min(200, state.timeline.zoom + delta));
            state.timeline.zoom = newZoom;
            render();
        }

        function fitTimelineToView() {
            const container = document.getElementById('timeline-scroll-container');
            if (!container) return;

            const containerWidth = container.clientWidth - 100; // Account for labels
            const totalDuration = state.preview.totalDuration || state.script.scenes.reduce((sum, s) => sum + (s.duration || 8), 0);

            if (totalDuration > 0) {
                state.timeline.zoom = Math.max(10, Math.floor(containerWidth / totalDuration));
                render();
            }
        }

        function toggleTimelineSnap(enabled) {
            state.timeline.snapToGrid = enabled;
        }

        function handleTimelineScroll(container) {
            state.timeline.scrollLeft = container.scrollLeft;
        }

        function selectTimelineClip(clipId, track) {
            state.timeline.selectedClipId = clipId;
            state.timeline.selectedTrack = track;

            // Also seek to the clip's start time
            if (previewEngine && state.preview.isReady) {
                const scene = previewEngine.scenes.find(s => s.id === clipId);
                if (scene) {
                    previewEngine.seek(scene.startTime);
                    state.preview.currentTime = scene.startTime;
                    updateTimelinePlayhead(scene.startTime);
                }
            }

            render();
        }

        function updateClipDuration(clipId, newDuration) {
            const duration = parseFloat(newDuration);
            if (isNaN(duration) || duration < 1 || duration > 60) return;

            const scene = state.script.scenes.find(s => s.id === clipId);
            if (scene) {
                scene.duration = duration;
                saveProject();

                // Update preview engine if initialized
                if (previewEngine && state.preview.isReady) {
                    const previewScene = previewEngine.scenes.find(s => s.id === clipId);
                    if (previewScene) {
                        previewScene.duration = duration;
                        previewEngine._calculateTiming();
                    }
                    state.preview.totalDuration = previewEngine.totalDuration;
                }

                render();
            }
        }

        function updateClipTransition(clipId, transitionType) {
            state.assembly.transitions[clipId] = { type: transitionType };
            saveProject();

            // Update preview engine
            if (previewEngine && state.preview.isReady) {
                const scene = previewEngine.scenes.find(s => s.id === clipId);
                if (scene) {
                    scene.transition = transitionType;
                }
            }

            render();
        }

        function updateTimelinePlayhead(time) {
            const playhead = document.getElementById('timeline-playhead');
            if (playhead) {
                const x = 80 + (time * state.timeline.zoom);
                playhead.style.left = `${x}px`;
            }

            // Auto-scroll timeline to keep playhead visible
            const container = document.getElementById('timeline-scroll-container');
            if (container && state.preview.isPlaying) {
                const playheadX = time * state.timeline.zoom;
                const scrollLeft = container.scrollLeft;
                const containerWidth = container.clientWidth - 80;

                if (playheadX < scrollLeft || playheadX > scrollLeft + containerWidth - 50) {
                    container.scrollLeft = Math.max(0, playheadX - 100);
                }
            }
        }

        // ==========================================
        // TIMELINE EDITING OPERATIONS
        // ==========================================

        // Edit History for Undo/Redo
        class EditHistory {
            constructor(maxHistory = 50) {
                this.history = [];
                this.position = -1;
                this.maxHistory = maxHistory;
            }

            push(state) {
                // Remove any redo history
                this.history = this.history.slice(0, this.position + 1);
                this.history.push(JSON.parse(JSON.stringify(state)));
                this.position++;

                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.position--;
                }
            }

            undo() {
                if (this.position > 0) {
                    this.position--;
                    return JSON.parse(JSON.stringify(this.history[this.position]));
                }
                return null;
            }

            redo() {
                if (this.position < this.history.length - 1) {
                    this.position++;
                    return JSON.parse(JSON.stringify(this.history[this.position]));
                }
                return null;
            }

            canUndo() {
                return this.position > 0;
            }

            canRedo() {
                return this.position < this.history.length - 1;
            }
        }

        const editHistory = new EditHistory();

        function saveEditState() {
            editHistory.push({
                scenes: state.script.scenes,
                sceneOrder: state.assembly.sceneOrder,
                transitions: state.assembly.transitions
            });
        }

        function undoEdit() {
            const previousState = editHistory.undo();
            if (previousState) {
                state.script.scenes = previousState.scenes;
                state.assembly.sceneOrder = previousState.sceneOrder;
                state.assembly.transitions = previousState.transitions;
                saveProject();
                rebuildPreviewScenes();
                render();
                showToast('Undo', 'info');
            }
        }

        function redoEdit() {
            const nextState = editHistory.redo();
            if (nextState) {
                state.script.scenes = nextState.scenes;
                state.assembly.sceneOrder = nextState.sceneOrder;
                state.assembly.transitions = nextState.transitions;
                saveProject();
                rebuildPreviewScenes();
                render();
                showToast('Redo', 'info');
            }
        }

        function rebuildPreviewScenes() {
            if (previewEngine && state.preview.isReady) {
                const scenes = buildPreviewScenes();
                state.preview.totalDuration = scenes.reduce((sum, s) => sum + (s.duration || 8), 0);
                previewEngine.scenes = scenes.map((scene, index) => ({
                    ...scene,
                    index,
                    startTime: 0,
                    endTime: 0
                }));
                previewEngine._calculateTiming();
            }
        }

        // Split clip at playhead
        function splitClipAtPlayhead() {
            if (!state.preview.isReady) return;

            const currentTime = state.preview.currentTime;
            const scenes = previewEngine?.scenes || [];

            // Find which scene contains the current time
            const sceneIndex = scenes.findIndex(s =>
                currentTime >= s.startTime && currentTime < s.startTime + s.duration
            );

            if (sceneIndex === -1) return;

            const scene = scenes[sceneIndex];
            const splitPoint = currentTime - scene.startTime;

            // Don't split if too close to edges
            if (splitPoint < 1 || splitPoint > scene.duration - 1) {
                showToast('Cannot split here - too close to edge', 'warning');
                return;
            }

            saveEditState();

            // Find the original scene
            const originalScene = state.script.scenes.find(s => s.id === scene.id);
            if (!originalScene) return;

            // Create new scene ID
            const newSceneId = Math.max(...state.script.scenes.map(s => s.id)) + 1;

            // Create the new scene (second half)
            const newScene = {
                ...JSON.parse(JSON.stringify(originalScene)),
                id: newSceneId,
                duration: originalScene.duration - splitPoint
            };

            // Update original scene duration (first half)
            originalScene.duration = splitPoint;

            // Add new scene to script
            const originalIndex = state.script.scenes.findIndex(s => s.id === scene.id);
            state.script.scenes.splice(originalIndex + 1, 0, newScene);

            // Update scene order
            const orderIndex = state.assembly.sceneOrder.indexOf(scene.id);
            if (orderIndex !== -1) {
                state.assembly.sceneOrder.splice(orderIndex + 1, 0, newSceneId);
            } else {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Copy storyboard data for new scene
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === scene.id);
            if (storyboardScene) {
                state.storyboard.scenes.push({
                    ...JSON.parse(JSON.stringify(storyboardScene)),
                    sceneId: newSceneId
                });
            }

            // Copy animation data for new scene
            const animScene = state.animation.scenes.find(s => s.sceneId === scene.id);
            if (animScene) {
                state.animation.scenes.push({
                    ...JSON.parse(JSON.stringify(animScene)),
                    sceneId: newSceneId
                });
            }

            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip split at playhead', 'success');
        }

        // Delete selected clip
        function deleteSelectedClip() {
            const clipId = state.timeline.selectedClipId;
            if (!clipId) {
                showToast('No clip selected', 'warning');
                return;
            }

            // Prevent deleting if only one scene
            if (state.script.scenes.length <= 1) {
                showToast('Cannot delete the only scene', 'warning');
                return;
            }

            saveEditState();

            // Remove from script scenes
            state.script.scenes = state.script.scenes.filter(s => s.id !== clipId);

            // Remove from scene order
            state.assembly.sceneOrder = state.assembly.sceneOrder.filter(id => id !== clipId);
            if (state.assembly.sceneOrder.length === 0) {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Remove from storyboard
            state.storyboard.scenes = state.storyboard.scenes.filter(s => s.sceneId !== clipId);

            // Remove from animation
            state.animation.scenes = state.animation.scenes.filter(s => s.sceneId !== clipId);

            // Remove transition
            delete state.assembly.transitions[clipId];

            // Clear selection
            state.timeline.selectedClipId = null;

            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip deleted', 'success');
        }

        // Duplicate selected clip
        function duplicateSelectedClip() {
            const clipId = state.timeline.selectedClipId;
            if (!clipId) {
                showToast('No clip selected', 'warning');
                return;
            }

            saveEditState();

            const originalScene = state.script.scenes.find(s => s.id === clipId);
            if (!originalScene) return;

            // Create new scene ID
            const newSceneId = Math.max(...state.script.scenes.map(s => s.id)) + 1;

            // Create duplicate scene
            const newScene = {
                ...JSON.parse(JSON.stringify(originalScene)),
                id: newSceneId
            };

            // Add after original in script
            const originalIndex = state.script.scenes.findIndex(s => s.id === clipId);
            state.script.scenes.splice(originalIndex + 1, 0, newScene);

            // Add after original in order
            const orderIndex = state.assembly.sceneOrder.indexOf(clipId);
            if (orderIndex !== -1) {
                state.assembly.sceneOrder.splice(orderIndex + 1, 0, newSceneId);
            } else {
                state.assembly.sceneOrder = state.script.scenes.map(s => s.id);
            }

            // Copy storyboard data
            const storyboardScene = state.storyboard.scenes.find(s => s.sceneId === clipId);
            if (storyboardScene) {
                state.storyboard.scenes.push({
                    ...JSON.parse(JSON.stringify(storyboardScene)),
                    sceneId: newSceneId
                });
            }

            // Copy animation data
            const animScene = state.animation.scenes.find(s => s.sceneId === clipId);
            if (animScene) {
                state.animation.scenes.push({
                    ...JSON.parse(JSON.stringify(animScene)),
                    sceneId: newSceneId
                });
            }

            // Copy transition
            const transition = state.assembly.transitions[clipId];
            if (transition) {
                state.assembly.transitions[newSceneId] = { ...transition };
            }

            // Select the new clip
            state.timeline.selectedClipId = newSceneId;

            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip duplicated', 'success');
        }

        // Move clip in order (reorder)
        function moveClipInTimeline(clipId, direction) {
            const order = state.assembly.sceneOrder.length > 0
                ? [...state.assembly.sceneOrder]
                : state.script.scenes.map(s => s.id);

            const currentIndex = order.indexOf(clipId);
            const newIndex = currentIndex + direction;

            if (newIndex < 0 || newIndex >= order.length) return;

            saveEditState();

            // Swap positions
            [order[currentIndex], order[newIndex]] = [order[newIndex], order[currentIndex]];
            state.assembly.sceneOrder = order;

            saveProject();
            rebuildPreviewScenes();
            render();
        }

        // Trim clip (adjust duration)
        let trimState = null;

        function startTrimClip(clipId, handle, event) {
            event.stopPropagation();
            event.preventDefault();

            const scene = state.script.scenes.find(s => s.id === clipId);
            if (!scene) return;

            saveEditState();

            trimState = {
                clipId,
                handle, // 'left' or 'right'
                startX: event.clientX,
                originalDuration: scene.duration || 8,
                minDuration: 1,
                maxDuration: 60
            };

            document.addEventListener('mousemove', handleTrimMove);
            document.addEventListener('mouseup', handleTrimEnd);
        }

        function handleTrimMove(event) {
            if (!trimState) return;

            const deltaX = event.clientX - trimState.startX;
            const deltaTime = deltaX / state.timeline.zoom;

            let newDuration;
            if (trimState.handle === 'right') {
                newDuration = trimState.originalDuration + deltaTime;
            } else {
                // Left handle - trimming from start would need more complex logic
                // For now, just adjust duration
                newDuration = trimState.originalDuration - deltaTime;
            }

            // Clamp duration
            newDuration = Math.max(trimState.minDuration, Math.min(trimState.maxDuration, newDuration));

            // Update scene duration
            const scene = state.script.scenes.find(s => s.id === trimState.clipId);
            if (scene) {
                scene.duration = Math.round(newDuration * 10) / 10; // Round to 0.1s
                rebuildPreviewScenes();
                render();
            }
        }

        function handleTrimEnd() {
            if (trimState) {
                saveProject();
                showToast('Clip trimmed', 'success');
            }
            trimState = null;
            document.removeEventListener('mousemove', handleTrimMove);
            document.removeEventListener('mouseup', handleTrimEnd);
        }

        // Drag to reorder clips
        let dragState = null;

        function startDragClip(clipId, event) {
            // Don't start drag if clicking on handles
            if (event.target.classList.contains('clip-handle')) return;

            event.preventDefault();

            dragState = {
                clipId,
                startX: event.clientX,
                startY: event.clientY,
                isDragging: false
            };

            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
        }

        function handleDragMove(event) {
            if (!dragState) return;

            const deltaX = Math.abs(event.clientX - dragState.startX);
            const deltaY = Math.abs(event.clientY - dragState.startY);

            // Start dragging after moving 5px
            if (!dragState.isDragging && (deltaX > 5 || deltaY > 5)) {
                dragState.isDragging = true;
                document.body.style.cursor = 'grabbing';
            }

            if (dragState.isDragging) {
                // Show drop indicator
                updateDropIndicator(event);
            }
        }

        function handleDragEnd(event) {
            if (dragState && dragState.isDragging) {
                // Calculate drop position
                const dropIndex = calculateDropIndex(event);
                if (dropIndex !== -1) {
                    reorderClip(dragState.clipId, dropIndex);
                }
            }

            // Cleanup
            document.body.style.cursor = '';
            removeDropIndicator();
            dragState = null;
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
        }

        function updateDropIndicator(event) {
            // Get timeline container
            const container = document.querySelector('#timeline-scroll-container');
            if (!container) return;

            const rect = container.getBoundingClientRect();
            const x = event.clientX - rect.left + container.scrollLeft - 80;

            // Calculate which position this corresponds to
            let indicator = document.getElementById('drop-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'drop-indicator';
                indicator.style.cssText = 'position: absolute; top: 34px; width: 3px; height: 56px; background: #8b5cf6; z-index: 200; pointer-events: none; border-radius: 2px;';
                container.querySelector('div').appendChild(indicator);
            }

            // Find the x position to show indicator
            const order = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : state.script.scenes.map(s => s.id);

            let accumulatedX = 0;
            let indicatorX = 0;

            for (let i = 0; i <= order.length; i++) {
                if (i < order.length) {
                    const scene = state.script.scenes.find(s => s.id === order[i]);
                    const width = (scene?.duration || 8) * state.timeline.zoom;

                    if (x < accumulatedX + width / 2) {
                        indicatorX = accumulatedX;
                        break;
                    }
                    accumulatedX += width;
                } else {
                    indicatorX = accumulatedX;
                }
            }

            indicator.style.left = `${80 + indicatorX}px`;
        }

        function removeDropIndicator() {
            const indicator = document.getElementById('drop-indicator');
            if (indicator) indicator.remove();
        }

        function calculateDropIndex(event) {
            const container = document.querySelector('#timeline-scroll-container');
            if (!container) return -1;

            const rect = container.getBoundingClientRect();
            const x = event.clientX - rect.left + container.scrollLeft - 80;

            const order = state.assembly.sceneOrder.length > 0
                ? state.assembly.sceneOrder
                : state.script.scenes.map(s => s.id);

            let accumulatedX = 0;

            for (let i = 0; i <= order.length; i++) {
                if (i < order.length) {
                    const scene = state.script.scenes.find(s => s.id === order[i]);
                    const width = (scene?.duration || 8) * state.timeline.zoom;

                    if (x < accumulatedX + width / 2) {
                        return i;
                    }
                    accumulatedX += width;
                } else {
                    return order.length;
                }
            }

            return order.length;
        }

        function reorderClip(clipId, newIndex) {
            const order = state.assembly.sceneOrder.length > 0
                ? [...state.assembly.sceneOrder]
                : state.script.scenes.map(s => s.id);

            const currentIndex = order.indexOf(clipId);
            if (currentIndex === -1 || currentIndex === newIndex || currentIndex === newIndex - 1) return;

            saveEditState();

            // Remove from current position
            order.splice(currentIndex, 1);

            // Adjust new index if we removed from before it
            const adjustedIndex = currentIndex < newIndex ? newIndex - 1 : newIndex;

            // Insert at new position
            order.splice(adjustedIndex, 0, clipId);

            state.assembly.sceneOrder = order;
            saveProject();
            rebuildPreviewScenes();
            render();
            showToast('Clip reordered', 'success');
        }

        // Add edit toolbar to timeline header
        function renderEditToolbar() {
            const hasSelection = state.timeline.selectedClipId !== null;
            const canUndo = editHistory.canUndo();
            const canRedo = editHistory.canRedo();

            return `
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <!-- Undo/Redo -->
                    <button onclick="undoEdit()" ${!canUndo ? 'disabled' : ''} title="Undo (Ctrl+Z)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${canUndo ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${canUndo ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Undo
                    </button>
                    <button onclick="redoEdit()" ${!canRedo ? 'disabled' : ''} title="Redo (Ctrl+Y)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${canRedo ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${canRedo ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Redo
                    </button>

                    <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 0.25rem;"></div>

                    <!-- Clip Operations -->
                    <button onclick="splitClipAtPlayhead()" ${!state.preview.isReady ? 'disabled' : ''} title="Split at Playhead (S)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${state.preview.isReady ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${state.preview.isReady ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Split
                    </button>
                    <button onclick="duplicateSelectedClip()" ${!hasSelection ? 'disabled' : ''} title="Duplicate (Ctrl+D)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${hasSelection ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Duplicate
                    </button>
                    <button onclick="deleteSelectedClip()" ${!hasSelection ? 'disabled' : ''} title="Delete (Del)"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid ${hasSelection ? 'rgba(239, 68, 68, 0.4)' : 'rgba(255,255,255,0.2)'}; background: ${hasSelection ? 'rgba(239, 68, 68, 0.1)' : 'transparent'}; color: ${hasSelection ? '#ef4444' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Delete
                    </button>

                    <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 0.25rem;"></div>

                    <!-- Move -->
                    <button onclick="moveClipInTimeline(state.timeline.selectedClipId, -1)" ${!hasSelection ? 'disabled' : ''} title="Move Left"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${hasSelection ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                         Move
                    </button>
                    <button onclick="moveClipInTimeline(state.timeline.selectedClipId, 1)" ${!hasSelection ? 'disabled' : ''} title="Move Right"
                            style="padding: 0.3rem 0.5rem; border-radius: 0.25rem; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: ${hasSelection ? 'white' : 'rgba(255,255,255,0.3)'}; cursor: ${hasSelection ? 'pointer' : 'not-allowed'}; font-size: 0.75rem;">
                        Move 
                    </button>
                </div>
            `;
        }

        function renderExportSettings(scriptScenes, animatedCount, totalDuration, platform) {
            const selectedQuality = state.export.selectedQuality || '1080p';
            const selectedRenderQuality = state.export.selectedRenderQuality || 'balanced';

            // Render quality options for speed vs quality tradeoff
            const RENDER_QUALITY_OPTIONS = {
                fast: {
                    name: 'Fast',
                    icon: '',
                    description: 'Quick export (~50% faster)',
                    time: Math.ceil(totalDuration * 0.8 / 60)
                },
                balanced: {
                    name: 'Balanced',
                    icon: '',
                    description: 'Good speed & quality (recommended)',
                    time: Math.ceil(totalDuration * 1.5 / 60)
                },
                best: {
                    name: 'Best Quality',
                    icon: '',
                    description: 'Highest quality, slower',
                    time: Math.ceil(totalDuration * 3 / 60)
                }
            };

            return `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <!-- Left: Video Summary -->
                    <div class="content-card" style="padding: 1.25rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Video Summary
                        </div>

                        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Platform</span>
                                <span style="color: white; font-size: 0.85rem;">${platform.icon || ''} ${platform.name || 'YouTube'}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Aspect Ratio</span>
                                <span style="color: white; font-size: 0.85rem;">${state.platform.aspectRatio || '16:9'}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Total Scenes</span>
                                <span style="color: white; font-size: 0.85rem;">${scriptScenes.length} scenes</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Animated Scenes</span>
                                <span style="color: ${animatedCount === scriptScenes.length ? '#10b981' : '#f59e0b'}; font-size: 0.85rem;">
                                    ${animatedCount}/${scriptScenes.length} ${animatedCount === scriptScenes.length ? '' : ''}
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Duration</span>
                                <span style="color: white; font-size: 0.85rem;">${formatDuration(totalDuration)}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Background Music</span>
                                <span style="color: white; font-size: 0.85rem;">${state.assembly.music?.enabled ? ' Enabled' : ' Disabled'}</span>
                            </div>
                        </div>

                        ${animatedCount < scriptScenes.length ? `
                            <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 0.5rem;">
                                <div style="font-size: 0.8rem; color: #f59e0b;">
                                     ${scriptScenes.length - animatedCount} scene(s) don't have animated videos. They will use static images.
                                </div>
                            </div>
                        ` : ''}
                    </div>

                    <!-- Right: Export Settings -->
                    <div class="content-card" style="padding: 1.25rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: white; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span> Export Settings
                        </div>

                        <!-- Quality Selection -->
                        <div style="margin-bottom: 1.25rem;">
                            <label style="display: block; font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Video Quality</label>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                ${Object.entries(EXPORT_QUALITIES).map(([id, q]) => `
                                    <button onclick="setExportQuality('${id}')"
                                            style="padding: 0.75rem; border-radius: 0.5rem; border: 1px solid ${selectedQuality === id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.15)'}; background: ${selectedQuality === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; text-align: left; display: flex; align-items: center; gap: 0.75rem;">
                                        <span style="font-size: 1.25rem;">${q.icon}</span>
                                        <div>
                                            <div style="font-size: 0.9rem; font-weight: 600;">${q.name}</div>
                                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">${q.description}</div>
                                        </div>
                                        ${selectedQuality === id ? '<span style="margin-left: auto; color: #8b5cf6;"></span>' : ''}
                                    </button>
                                `).join('')}
                            </div>
                        </div>

                        <!-- Render Speed Selection -->
                        <div style="margin-bottom: 1.25rem;">
                            <label style="display: block; font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.5rem;">Render Speed</label>
                            <div style="display: flex; gap: 0.5rem;">
                                ${Object.entries(RENDER_QUALITY_OPTIONS).map(([id, rq]) => `
                                    <button onclick="setRenderQuality('${id}')"
                                            style="flex: 1; padding: 0.6rem 0.5rem; border-radius: 0.5rem; border: 1px solid ${selectedRenderQuality === id ? 'rgba(139, 92, 246, 0.6)' : 'rgba(255,255,255,0.15)'}; background: ${selectedRenderQuality === id ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.03)'}; color: white; cursor: pointer; text-align: center;">
                                        <div style="font-size: 1.1rem;">${rq.icon}</div>
                                        <div style="font-size: 0.8rem; font-weight: 600; margin-top: 0.25rem;">${rq.name}</div>
                                        <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-top: 0.15rem;">~${rq.time} min</div>
                                    </button>
                                `).join('')}
                            </div>
                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 0.5rem; text-align: center;">
                                ${RENDER_QUALITY_OPTIONS[selectedRenderQuality].description}
                            </div>
                        </div>

                        <!-- Estimated Info -->
                        <div style="padding: 0.75rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem; margin-bottom: 1.25rem;">
                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.6); margin-bottom: 0.25rem;">Estimated Processing Time</div>
                            <div style="font-size: 1rem; color: white; font-weight: 600;">~${Math.ceil(totalDuration * 2 / 60)} minutes</div>
                        </div>

                        <!-- Export Button -->
                        <button onclick="startExport()"
                                ${animatedCount === 0 ? 'disabled' : ''}
                                style="width: 100%; padding: 1rem; border-radius: 0.75rem; border: none; background: ${animatedCount > 0 ? 'linear-gradient(135deg, #8b5cf6, #06b6d4)' : 'rgba(255,255,255,0.1)'}; color: ${animatedCount > 0 ? 'white' : 'rgba(255,255,255,0.4)'}; font-size: 1rem; font-weight: 700; cursor: ${animatedCount > 0 ? 'pointer' : 'not-allowed'}; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <span></span>
                            <span>Start Export</span>
                        </button>

                        ${animatedCount === 0 ? `
                            <div style="text-align: center; margin-top: 0.75rem; font-size: 0.8rem; color: rgba(255,255,255,0.5);">
                                Complete the Animation step before exporting
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderExportProgress(exportState) {
            const progress = exportState.progress || 0;
            const currentStage = exportState.currentStage || 'Starting export...';
            const scenesCompleted = exportState.scenesCompleted || 0;
            const scenesTotal = exportState.scenesTotal || 0;
            const sceneStatuses = exportState.sceneStatuses || [];

            // Render scene indicators if we have scene data
            let sceneIndicatorsHtml = '';
            if (scenesTotal > 0) {
                sceneIndicatorsHtml = `
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
                        ${Array.from({ length: scenesTotal }, (_, i) => {
                            const sceneStatus = sceneStatuses[i];
                            const status = sceneStatus?.status || 'queued';
                            const isComplete = status === 'complete';
                            const isFailed = status === 'failed';
                            const isRendering = status === 'rendering';
                            const isQueued = status === 'queued' || status === 'processing';

                            let bgColor = 'rgba(255,255,255,0.1)'; // queued (dimmed)
                            let icon = (i + 1);
                            let extraStyle = '';

                            if (isComplete) {
                                bgColor = 'rgba(34, 197, 94, 0.4)';
                                icon = '';
                                extraStyle = 'border: 2px solid rgba(34, 197, 94, 0.6);';
                            } else if (isFailed) {
                                bgColor = 'rgba(239, 68, 68, 0.4)';
                                icon = '';
                                extraStyle = 'border: 2px solid rgba(239, 68, 68, 0.6);';
                            } else if (isRendering) {
                                bgColor = 'rgba(139, 92, 246, 0.4)';
                                extraStyle = 'animation: pulse 2s infinite; border: 2px solid rgba(139, 92, 246, 0.6);';
                            }

                            return `
                                <div style="width: 2.5rem; height: 2.5rem; border-radius: 50%; background: ${bgColor};
                                            display: flex; align-items: center; justify-content: center;
                                            font-size: 0.85rem; font-weight: 600; color: white;
                                            transition: all 0.3s ease; ${extraStyle}">
                                    ${icon}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="color: rgba(255,255,255,0.6); font-size: 0.85rem; margin-bottom: 1rem;">
                        ${scenesCompleted} of ${scenesTotal} scenes complete
                    </div>
                `;
            }

            return `
                <div class="content-card" style="text-align: center; padding: 3rem 2rem; margin-top: 1rem;">
                    <div style="font-size: 4rem; margin-bottom: 1.5rem;">
                        <div class="animate-pulse" style="display: inline-block;"></div>
                    </div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Rendering Your Video
                    </div>
                    <div id="export-stage-text" style="color: rgba(255,255,255,0.7); margin-bottom: 1.5rem; font-size: 1rem;">
                        ${currentStage}
                    </div>

                    <!-- Scene Indicators -->
                    ${sceneIndicatorsHtml}

                    <!-- Progress Bar -->
                    <div style="width: 100%; max-width: 400px; margin: 0 auto 1.5rem;">
                        <div style="height: 12px; background: rgba(255,255,255,0.1); border-radius: 6px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);">
                            <div id="export-progress-bar" style="height: 100%; width: ${progress}%; background: linear-gradient(90deg, #8b5cf6, #06b6d4); border-radius: 6px; transition: width 0.5s ease; box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 0.75rem; font-size: 0.9rem;">
                            <span style="color: rgba(255,255,255,0.5);">Progress</span>
                            <span id="export-progress-text" style="color: #8b5cf6; font-weight: 700;">${progress}%</span>
                        </div>
                    </div>

                    <!-- Processing indicator -->
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem;">
                        <div class="animate-spin" style="width: 1rem; height: 1rem; border: 2px solid rgba(139, 92, 246, 0.3); border-top-color: #8b5cf6; border-radius: 50%;"></div>
                        <span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">Processing on server...</span>
                    </div>

                    <!-- Cancel Button -->
                    <button onclick="cancelExport()"
                            style="padding: 0.6rem 1.5rem; border-radius: 0.5rem; border: 1px solid rgba(239, 68, 68, 0.4); background: rgba(239, 68, 68, 0.1); color: #ef4444; cursor: pointer; font-size: 0.85rem;">
                        Cancel Export
                    </button>

                    <div style="margin-top: 1.5rem; color: rgba(255,255,255,0.4); font-size: 0.75rem;">
                        Please don't close this page while exporting
                    </div>
                </div>
            `;
        }

        function renderExportComplete(exportState) {
            const outputUrl = exportState.outputUrl;
            const fileName = exportState.fileName || 'video.webm';
            const hasVideo = outputUrl && outputUrl.length > 0;

            // Calculate video stats
            const totalScenes = state.script.scenes?.length || 0;
            const totalDuration = state.script.scenes?.reduce((sum, s) => sum + (s.duration || 8), 0) || 0;

            return `
                <div class="content-card" style="text-align: center; padding: 3rem 2rem; margin-top: 1rem;">
                    <div style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Video Export Complete!
                    </div>
                    <div style="color: rgba(255,255,255,0.6); margin-bottom: 1.5rem;">
                        Your video is ready to download and share
                    </div>

                    <!-- Video Preview -->
                    ${hasVideo ? `
                        <div style="max-width: 700px; margin: 0 auto 2rem; border-radius: 1rem; overflow: hidden; border: 2px solid rgba(139, 92, 246, 0.3); box-shadow: 0 20px 60px rgba(0,0,0,0.4);">
                            <video id="export-preview-video" src="${outputUrl}" controls style="width: 100%; display: block; background: black;"></video>
                        </div>

                        <!-- Video Info -->
                        <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 2rem; color: rgba(255,255,255,0.6); font-size: 0.85rem;">
                            <span> ${totalScenes} scenes</span>
                            <span> ${formatDuration(totalDuration)}</span>
                            <span> ${state.export.exportType === 'server-render' ? 'MP4 format' : 'WebM format'}</span>
                        </div>
                    ` : `
                        <div style="padding: 2rem; color: rgba(255,255,255,0.5);">
                            No video available
                        </div>
                    `}

                    <!-- Action Buttons -->
                    <div style="display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 2rem;">
                        ${hasVideo ? `
                            <button onclick="downloadExportedVideo()"
                                    style="padding: 1rem 2.5rem; border-radius: 0.75rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 700; cursor: pointer; font-size: 1.1rem; display: flex; align-items: center; gap: 0.75rem; box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);">
                                <span style="font-size: 1.25rem;"></span>
                                <span>Download Video</span>
                            </button>
                        ` : ''}
                        <button onclick="exportAgain()"
                                style="padding: 1rem 1.5rem; border-radius: 0.75rem; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); color: white; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;">
                            <span></span>
                            <span>Export Again</span>
                        </button>
                    </div>

                    ${hasVideo ? `
                        <!-- Share Info -->
                        <div style="padding: 1.5rem; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 0.75rem; max-width: 500px; margin: 0 auto;">
                            <div style="font-size: 0.9rem; color: #10b981; margin-bottom: 0.5rem; font-weight: 600;">
                                 Ready to upload!
                            </div>
                            <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6);">
                                Download your video and upload it directly to YouTube, TikTok, Instagram, or any other platform.
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Download the exported video
        async function downloadExportedVideo() {
            const outputUrl = state.export.outputUrl;
            const isServerRender = state.export.exportType === 'server-render';

            // Generate filename based on export type
            const baseFileName = (state.script.title || 'video').replace(/[^a-z0-9]/gi, '_');
            const extension = isServerRender ? 'mp4' : 'webm';
            const fileName = state.export.fileName || `${baseFileName}_${Date.now()}.${extension}`;

            if (!outputUrl) {
                showToast('No video to download', 'error');
                return;
            }

            // Check if it's a cloud storage URL (Firebase or Google Cloud Storage)
            const isCloudUrl = outputUrl.includes('firebasestorage.googleapis.com') ||
                              outputUrl.includes('storage.googleapis.com') ||
                              outputUrl.includes('storage.cloud.google.com');

            try {
                if (isCloudUrl) {
                    // For Cloud Storage URLs, fetch and download as blob
                    showToast('Preparing download...', 'info');

                    const response = await fetch(outputUrl, { mode: 'cors' });
                    if (!response.ok) throw new Error(`Failed to fetch video: ${response.status}`);

                    const blob = await response.blob();
                    const blobUrl = URL.createObjectURL(blob);

                    const link = document.createElement('a');
                    link.href = blobUrl;
                    link.download = fileName;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // Clean up blob URL after a delay
                    setTimeout(() => URL.revokeObjectURL(blobUrl), 5000);
                    showToast('Download started!', 'success');
                } else {
                    // Direct download for blob URLs or simple URLs
                    const link = document.createElement('a');
                    link.href = outputUrl;
                    link.download = fileName;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showToast('Download started!', 'success');
                }
            } catch (error) {
                console.error('Download error:', error);
                // Fallback: open in new tab
                window.open(outputUrl, '_blank');
                showToast('Opening video in new tab...', 'info');
            }
        }

        // Download all storyboard images
        function downloadAllImages() {
            const imageScenes = state.storyboard.scenes.filter(s => s.imageUrl);
            if (imageScenes.length === 0) {
                showToast('No images to download', 'warning');
                return;
            }

            showToast('Downloading ' + imageScenes.length + ' images...', 'info');

            imageScenes.forEach((scene, index) => {
                const link = document.createElement('a');
                link.href = scene.imageUrl;
                link.download = 'scene_' + (index + 1) + '.png';
                link.target = '_blank';
                document.body.appendChild(link);
                setTimeout(() => {
                    link.click();
                    document.body.removeChild(link);
                }, index * 500); // Stagger downloads
            });
        }

        function renderExportFailed(exportState) {
            const error = exportState.error || 'An unknown error occurred';

            return `
                <div class="content-card" style="text-align: center; padding: 3rem 2rem; margin-top: 1rem;">
                    <div style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                        Export Failed
                    </div>
                    <div style="color: rgba(255,255,255,0.6); margin-bottom: 1rem;">
                        Something went wrong during export
                    </div>

                    <div style="max-width: 400px; margin: 0 auto 2rem; padding: 1rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 0.5rem;">
                        <div style="font-size: 0.85rem; color: #ef4444;">
                            ${error}
                        </div>
                    </div>

                    <button onclick="retryExport()"
                            style="padding: 0.75rem 2rem; border-radius: 0.5rem; border: none; background: linear-gradient(135deg, #8b5cf6, #06b6d4); color: white; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 0.5rem;">
                        <span></span>
                        <span>Try Again</span>
                    </button>
                </div>
            `;
        }

        // Export Functions

        /**
         * Save timeline state for export
         * Captures all timeline edits including scene order, durations, and transitions
         */
        function saveTimelineState() {
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];

            // Get scene order (from timeline or default)
            const sceneOrder = state.assembly.sceneOrder?.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            // Build scene data with timeline edits
            const scenes = sceneOrder.map((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = storyboardScenes.find(s => s.sceneId === sceneId);
                const transition = state.assembly.transitions?.[sceneId] || { type: 'fade', duration: 0.5 };

                return {
                    id: sceneId,
                    index,
                    duration: scriptScene?.duration || 8,
                    voiceoverDuration: animScene?.voiceoverDuration || null,
                    voiceoverOffset: scriptScene?.voiceoverOffset || 0,
                    transition: transition.type || 'fade',
                    transitionDuration: transition.duration || 0.5,
                    hasVideo: !!(animScene?.videoUrl),
                    hasImage: !!(storyboardScene?.imageUrl),
                    hasVoiceover: !!(animScene?.voiceoverUrl)
                };
            });

            // Calculate total duration
            const totalDuration = scenes.reduce((sum, s) => sum + s.duration, 0);

            return {
                version: 1,
                scenes,
                sceneOrder,
                totalDuration,
                music: {
                    enabled: state.assembly.music?.enabled || false,
                    trackId: state.assembly.music?.trackId || null,
                    volume: state.assembly.audioMix?.musicVolume || 30
                },
                captions: {
                    enabled: state.assembly.captions?.enabled !== false,
                    style: state.assembly.captions?.style || 'karaoke',
                    position: state.assembly.captions?.position || 'bottom'
                },
                audioMix: {
                    voiceVolume: state.assembly.audioMix?.voiceVolume || 100,
                    musicVolume: state.assembly.audioMix?.musicVolume || 30
                },
                editHistory: {
                    hasEdits: editHistory.position > 0,
                    editCount: editHistory.position
                }
            };
        }

        function setExportQuality(quality) {
            if (!state.export) state.export = {};
            state.export.selectedQuality = quality;
            render();
        }

        function setRenderQuality(quality) {
            if (!state.export) state.export = {};
            state.export.selectedRenderQuality = quality;
            render();
        }

        async function startExport() {
            // Check for exportable content: either AI videos OR storyboard images
            const animatedCount = (state.animation.scenes || []).filter(s => s.videoUrl).length;
            const imageCount = (state.storyboard.scenes || []).filter(s => s.imageUrl).length;
            const hasVoiceovers = (state.animation.scenes || []).some(s => s.voiceoverUrl);

            if (animatedCount === 0 && imageCount === 0) {
                showToast('Please add images or videos to your scenes first', 'error');
                return;
            }

            // Ensure project is saved before exporting
            if (!state.project.id) {
                showToast('Saving project before export...', 'info');
                await saveProject();
                if (!state.project.id) {
                    showToast('Please save your project first', 'error');
                    return;
                }
            }

            state.export.status = 'exporting';
            state.export.progress = 0;
            state.export.currentStage = 'Starting server-side export...';
            state.export.exportType = 'server-render';
            state.export.jobId = null;
            state.export.outputUrl = null;
            state.export.error = null;
            render();

            try {
                // Call Cloud Function to start server-side video export
                console.log('[Export] Starting server-side video rendering');

                const quality = state.export.selectedQuality || '1080p';
                const renderQuality = state.export.selectedRenderQuality || 'balanced';
                const format = 'mp4'; // Server-side always produces MP4

                const startExportFn = firebase.functions().httpsCallable('creationWizardStartExport');
                const result = await startExportFn({
                    projectId: state.project.id,
                    quality: quality,
                    renderQuality: renderQuality,  // fast, balanced, or best
                    format: format
                });

                if (!result.data.success) {
                    throw new Error(result.data.error || 'Failed to start export');
                }

                // Store job ID and start polling
                state.export.jobId = result.data.jobId;
                state.export.progress = 5;
                state.export.currentStage = 'Export job created, waiting for processing...';
                updateExportProgressBar(state.export.progress, state.export.currentStage);

                console.log('[Export] Job created:', result.data.jobId);
                console.log('[Export] Total duration:', result.data.totalDuration, 'seconds');
                console.log('[Export] Scenes:', result.data.sceneCount);

                // Start polling for status
                setTimeout(pollExportStatus, 2000);

            } catch (error) {
                console.error('Export error:', error);
                state.export.status = 'failed';
                state.export.error = error.message || 'Export failed';
                showToast('Export failed: ' + error.message, 'error');
                render();
            }
        }

        // Build scenes array for export engine
        function buildExportScenes() {
            const scriptScenes = state.script.scenes || [];
            const animationScenes = state.animation.scenes || [];
            const storyboardScenes = state.storyboard.scenes || [];
            const sceneOrder = state.assembly.sceneOrder?.length > 0
                ? state.assembly.sceneOrder
                : scriptScenes.map(s => s.id);

            return sceneOrder.map((sceneId, index) => {
                const scriptScene = scriptScenes.find(s => s.id === sceneId);
                const animScene = animationScenes.find(s => s.sceneId === sceneId);
                const storyboardScene = storyboardScenes.find(s => s.sceneId === sceneId);

                return {
                    id: sceneId,
                    index,
                    narration: scriptScene?.narration || '',
                    visualDuration: scriptScene?.visualDuration || scriptScene?.duration || 8,
                    duration: scriptScene?.duration || 8,
                    // Prefer video if available, otherwise image
                    videoUrl: animScene?.videoUrl || null,
                    imageUrl: storyboardScene?.imageUrl || null,
                    voiceoverUrl: animScene?.voiceoverUrl || null,
                    // Ken Burns parameters for images
                    kenBurns: {
                        startScale: 1.0 + Math.random() * 0.2,
                        endScale: 1.1 + Math.random() * 0.2,
                        startX: 0.4 + Math.random() * 0.2,
                        startY: 0.4 + Math.random() * 0.2,
                        endX: 0.4 + Math.random() * 0.2,
                        endY: 0.4 + Math.random() * 0.2
                    },
                    transition: state.assembly.transitions?.[sceneId]?.type || 'fade'
                };
            });
        }

        async function pollExportStatus() {
            if (!state.export.jobId) return;

            try {
                const checkStatus = firebase.functions().httpsCallable('creationWizardCheckExportStatus');
                const result = await checkStatus({ jobId: state.export.jobId });

                const statusChanged = state.export.status !== result.data.status;
                const completed = result.data.status === 'completed';
                const failed = result.data.status === 'failed' || result.data.status === 'error';

                // Track if scene progress changed (for UI updates)
                const prevScenesCompleted = state.export.scenesCompleted || 0;
                const newScenesCompleted = result.data.scenesCompleted || 0;
                const sceneProgressChanged = newScenesCompleted !== prevScenesCompleted;

                state.export.status = result.data.status;
                state.export.progress = result.data.progress || 0;
                state.export.currentStage = result.data.currentStage || '';
                state.export.outputUrl = result.data.outputUrl || null;
                state.export.error = result.data.error || null;
                state.export.exportType = result.data.exportType || null;
                state.export.exportNote = result.data.exportNote || null;
                state.export.imageUrls = result.data.imageUrls || null;
                state.export.previewThumbnail = result.data.previewThumbnail || null;

                // Scene progress tracking for parallel processing UI
                state.export.scenesCompleted = result.data.scenesCompleted || 0;
                state.export.scenesTotal = result.data.scenesTotal || 0;
                state.export.sceneStatuses = result.data.sceneStatuses || [];

                // Re-render when status changes OR when scene progress changes
                if (statusChanged || completed || failed || sceneProgressChanged) {
                    render();
                } else {
                    // Just update progress bar without full re-render (prevents flashing)
                    updateExportProgressBar(state.export.progress, state.export.currentStage);
                }

                if (completed) {
                    showToast('Export complete!', 'success');
                    saveProject();
                } else if (failed) {
                    showToast('Export failed: ' + (state.export.error || 'Unknown error'), 'error');
                } else if (result.data.status === 'processing' || result.data.status === 'pending' || result.data.status === 'exporting') {
                    // Continue polling
                    setTimeout(pollExportStatus, 2000);
                }
            } catch (error) {
                console.error('Poll status error:', error);
                // Retry polling
                setTimeout(pollExportStatus, 5000);
            }
        }

        // Update just the progress bar elements without full re-render
        function updateExportProgressBar(progress, currentStage) {
            const progressBar = document.getElementById('export-progress-bar');
            const progressText = document.getElementById('export-progress-text');
            const stageText = document.getElementById('export-stage-text');

            if (progressBar) progressBar.style.width = progress + '%';
            if (progressText) progressText.textContent = progress + '%';
            if (stageText) stageText.textContent = currentStage || 'Processing...';
        }

        async function cancelExport() {
            // If we have a jobId, try to cancel on server
            if (state.export.jobId) {
                try {
                    const cancelExportFn = firebase.functions().httpsCallable('creationWizardCancelExport');
                    await cancelExportFn({ jobId: state.export.jobId });
                    showToast('Export cancelled', 'info');
                } catch (error) {
                    console.error('Cancel error:', error);
                    // Still reset UI even if server cancel fails
                }
            } else {
                showToast('Export stopped', 'info');
            }

            // ALWAYS reset UI state so user can exit
            state.export.status = 'idle';
            state.export.jobId = null;
            state.export.progress = 0;
            state.export.currentStage = '';
            state.export.error = null;
            render();
        }

        function copyExportUrl() {
            if (state.export.outputUrl) {
                navigator.clipboard.writeText(state.export.outputUrl)
                    .then(() => showToast('Link copied to clipboard!', 'success'))
                    .catch(() => showToast('Failed to copy link', 'error'));
            }
        }

        function exportAgain() {
            state.export.status = 'idle';
            state.export.jobId = null;
            state.export.outputUrl = null;
            state.export.progress = 0;
            render();
        }

        function retryExport() {
            state.export.status = 'idle';
            state.export.error = null;
            render();
        }

        function shareToSocial(platform) {
            const url = state.export.outputUrl;
            if (!url) return;

            let shareUrl;
            switch (platform) {
                case 'twitter':
                    shareUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(url)}&text=${encodeURIComponent('Check out my new video!')}`;
                    break;
                default:
                    showToast(`Download the video to upload to ${platform}`, 'info');
                    return;
            }

            if (shareUrl) {
                window.open(shareUrl, '_blank', 'width=600,height=400');
            }
        }

        // ==========================================
        // 7.12 HELPER RENDERS
        // ==========================================

        function renderComingSoonStep(stepNum, title, description) {
            return `
                <div class="fade-in">
                    <div class="content-card" style="text-align: center; padding: 4rem 2rem;">
                        <div style="font-size: 4rem; margin-bottom: 1.5rem;"></div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">
                            Step ${stepNum}: ${title}
                        </div>
                        <div style="color: rgba(255,255,255,0.6); margin-bottom: 2rem;">
                            ${description}
                        </div>
                        <div style="color: rgba(139, 92, 246, 0.8); font-size: 0.9rem;">
                            Coming soon in Phase ${stepNum > 2 ? Math.ceil((stepNum - 2) / 2) + 1 : 1}...
                        </div>
                    </div>
                    ${renderNavButtons(stepNum - 1, stepNum < 7 ? stepNum + 1 : null)}
                </div>
            `;
        }

        // ==========================================
        // 7.8 NAVIGATION BUTTONS
        // ==========================================
        function renderNavButtons(backStep, nextStep) {
            let html = '<div class="nav-buttons">';

            if (backStep) {
                html += `
                    <button class="nav-button nav-button-back" onclick="goToStep(${backStep})">
                        <span></span>
                        <span>Back</span>
                    </button>
                `;
            } else {
                html += '<div></div>';
            }

            if (nextStep) {
                html += `
                    <button class="nav-button nav-button-next" onclick="goToStep(${nextStep})">
                        <span>Continue</span>
                        <span></span>
                    </button>
                `;
            } else if (state.currentStep < 7) {
                html += `
                    <button class="nav-button nav-button-next" disabled>
                        <span>Continue</span>
                        <span></span>
                    </button>
                `;
            }

            html += '</div>';
            return html;
        }

        // ==========================================
        // 7.9 EVENT LISTENERS
        // ==========================================
        function attachEventListeners() {
            // Duration slider continuous update
            const durationSlider = document.getElementById('duration-slider');
            if (durationSlider) {
                durationSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    state.platform.targetDuration = value;
                    // Update just the display without full re-render
                    const valueDisplay = document.querySelector('.duration-value');
                    if (valueDisplay) {
                        valueDisplay.textContent = formatDuration(value);
                    }
                });
            }

            // Topic input
            const topicInput = document.getElementById('topic-input');
            if (topicInput) {
                topicInput.addEventListener('input', function() {
                    state.content.topic = this.value;
                });
            }
        }

        // ==========================================
        // 7.10 INITIALIZATION
        // ==========================================
        async function init() {
            try {
                await initAuth();

                // Update loading text after auth
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Loading Video Creation Wizard...';
                }

                // Check if loading an existing project
                const projectId = checkUrlForProject();
                if (projectId) {
                    await loadProject(projectId);
                } else {
                    state.isLoading = false;
                    render();
                }
            } catch (error) {
                console.error('Init error:', error);
                state.isLoading = false;
                render();
            }
        }

        // Start the app
        init();
    </script>
</body>
</html>
